/**
 * \mainpage Flake
 *
 * The Flake library is a low level library for all kinds of graphical content
 * to be placed on any KOffice canvas. This includes a line to text-areas or
 * even movies.  Just as important, this library will include tools to manipulate
 * the graphical content. At least at the level of Flake objects.  This goes from
 * moving/rotating the object to a basis for complex brushes for a paint program.
 *
 * Use KoShape as a base object for any application-specific graphical
 * content, and extend KoShapeContainer for objects that can contain others.
 *
 * KoShape is the base class for all flake objects. Flake objects extend it
 * to allow themselves to be manipulated by the KoTool s. The content of such an
 * object is independent and based on the model of the data this object represents.
 *
 * If you want to be a supplier of shape objects; create a library with a KoShapeFactory
 * class and install a .desktop service file with the following content:
 * 
@verbatim
[Desktop Entry]
Encoding=UTF-8
Name=My Flake Shapes Plugin
ServiceTypes=KOffice/Shape
Type=Service
X-KDE-Library=myflakeshapesplugin
X-Flake-Version=1
@endverbatim
 *
 * To use Flake in your application you need to have a canvas that is ready for use
 * by flake, do this by implementing the KoCanvasBase interface.  Redirect mouse/key events
 * to the tool and paint events to the shapeManager.
 * Then you have to setup the KoToolManager (from KOfficeUI):
 * In your KoDocument instance:
@code
        KoToolManager::instance()->toolBox()->show();</pre>
@endcode
 * And use KoCanvasController KoCanvasView instance with your Canvas:
@code
class MyCanvas : public QWidget, public KoCanvasBase {
    Q_OBJECT
public:
    // KoCanvasBase interface methods.
    void gridSize(double *horizontal, double *vertical) const;
    bool snapToGrid() const;
    void addCommand(KCommand *command, bool execute = true);
    KoShapeManager *shapeManager() const { return m_shapeManager; }
    void updateCanvas(const QRectF& rc) {
        QRect clipRect(viewConverter()->normalToView(rc).toRect());
        clipRect.adjust(-2, -2, 2, 2); // grow for to anti-aliasing
        update(clipRect);
    }
    KoTool* tool() { return m_tool; }
    void setTool(KoTool *tool) { m_tool = tool; }
    KoViewConverter *viewConverter() { return view()->viewConverter(); }
    QWidget* canvasWidget() { return this; }

    // event handlers
    void mouseMoveEvent(QMouseEvent *e) {
        KoPointerEvent ev(e, QPointF( viewConverter()->viewToNormal(e->pos()) ));
        m_tool->mouseMoveEvent( &ev );
    }

    void mousePressEvent(QMouseEvent *e) {
        KoPointerEvent ev(e, QPointF( viewConverter()->viewToNormal(e->pos()) ));
        m_tool->mousePressEvent( &ev );
    }

    void mouseReleaseEvent(QMouseEvent *e) {
        KoPointerEvent ev(e, QPointF( viewConverter()->viewToNormal(e->pos()) ));
        m_tool->mouseReleaseEvent( &ev );
    }

    void keyReleaseEvent (QKeyEvent *e) {
        m_tool->keyReleaseEvent(e);
    }

    void KWCanvas::keyPressEvent( QKeyEvent *e ) {
        m_tool->keyPressEvent(e);
    }

    void paintEvent(QPaintEvent * ev) {
        QPainter painter( this );
        painter.setRenderHint(QPainter::Antialiasing);
        painter.setClipRect(ev->rect());

        m_shapeManager->paint( painter, *(viewConverter()), false );
        m_tool->paint( painter, *m_doc );

        painter.end();
    }

private:
    KoTool *m_tool;
    KoShapeManager *m_shapeManager;
};
@endcode
 *
 * And then:
 *
@code
    KoCanvasController *canvasController = new KoCanvasController(parentWidget);
    MyCanvas *canvas = new MyCanvas();
    canvasController->setCanvas(canvas);
    KoToolManager::instance()->addControllers(canvasController, m_document);
    parentLayout.addWidget(canvasController);</pre>
@endcode
 */
