%%BeginProlog
/OCol [ 0 0 0 ] def % Zeichenfarbe
/FCol [ 0 0 0 ] def % Fuellfarbe

/DOCol { % Definieren der Zeichenfarben (rot gruen blau)
	OCol astore pop
} bind def

/DFCol { % Definieren der Fullfarbe (rot grueen blau)
	FCol astore pop
} bind def

/SOCol { % Setzen der aktuellen Zeichenfarbe aus OCol
	OCol aload pop setrgbcolor
} bind def

/SFCol { % Setzen der aktuellen Fuellfarbe aus FCol
	FCol aload pop setrgbcolor
} bind def

/PStArr [ % Feld mit QT PenStyles
       []             % SolidLine
       [7 2]          % DashLine
       [1 5]          % DotLine
       [10 3 2 3]     % DashDotLine
       [10 3 2 3 2 3] % DashDotDotLine
] def

/SPSt { % Setzen des PenStyles
       /Style exch def
       Style 1 ge Style 5 le and
       { PStArr Style 1 sub get }
       { [] }
       ifelse
       0 setdash
} bind def

/SMatrix { % Initialisieren der Transformationsmatrix (Array)
	% Hinterlaesst Originalmatrix auf dem Stack !
	matrix currentmatrix % Originalmatrix sichern
	exch                 % Feld fuer neue Matrix nach oben
	concat               % mit CTM verknuepfen
} bind def

/RMatrix { % Wiederherstellen der originalen Transformationsmatrix
	setmatrix
} bind def

/DrawPolyline { % Zeichnen einer Polyline ([xn yn ... x1 y1])
	aload           % Feld entladen
	length          % Anzahl der Eintraege
	2 sub           % 2 fuer moveto
	2 div           % div fuer Wertepaare
	3 1 roll        % Koordinaten fuer moveto nach oben
	moveto          % Anfangspunkt
	cvi             % von real nach integer konvertieren
	{lineto} repeat % und entsprechend oft ausfuehren
	SOCol           % Zeichenfarbe setzen
	setmatrix       % Transformationsmatrix wiederherstellen
	stroke          % und nachziehen
} bind def

/DrawPolygon { % Zeichnen eines Polygons ([xn yn ... x1 y1] opaque)
	/Opaque exch def
	aload           % Feld entladen
	length          % Anzahl der Eintraege
	2 sub           % 2 fuer moveto
	2 div           % div fuer Wertepaare
	3 1 roll        % Koordinaten fuer moveto nach oben
	moveto          % Anfangspunkt
	cvi             % von real nach integer konvertieren
	{lineto} repeat % und entsprechend oft ausfuehren
	closepath       % Pfad beenden
	SOCol           % Zeichenfarbe setzen
	Opaque {        % wenn nicht transparent
	  gsave SFCol fill grestore     % fuellen
	} if
	setmatrix       % Transformationsmatrix wiederherstellen
	stroke          % und nachziehen
} bind def

/DrawEllipse { % Zeichnen einer Ellipse (x1 x2 x2 y2 opaque)
	/Opaque exch def
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	0 0                  % Ursprung auf den Stack
	newpath
	x1 x2 add 2 div      % Mittelpunkt bestimmen
	y1 y2 add 2 div
	translate            % entsprechend verschieben
	x2 x1 sub abs        % Seitenlaengen berechnen
	y2 y1 sub abs
	dup 2 div            % Radius sichern
	3 1 roll             % Seitenlaengen nach oben
	div                  % Seitenverhaeltnis berechnen
	1.0 scale            % entsprechend skalieren
	0 360 arc            % und Kreis zeichnen
	Opaque { 
	  gsave SFCol fill grestore
	} if
	setmatrix
	SOCol                % Zeichenfarbe setzen
	stroke
} bind def

/DrawArc { % Zeichnen ein Ellipsensegment (x1 x2 x2 y2 angle1 angle2)
           % ohne Verbindung zum Mittelpunkt
	/angle2 exch def
	/angle1 exch def
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	0 0                  % Ursprung auf den Stack
	newpath
	x1 x2 add 2 div      % Mittelpunkt bestimmen
	y1 y2 add 2 div
	translate            % entsprechend verschieben
	x2 x1 sub abs        % Seitenlaengen berechnen
	y2 y1 sub abs
	dup 2 div            % Radius sichern
	3 1 roll             % Seitenlaengen nach oben
	div                  % Seitenverhaeltnis berechnen
	1.0 scale            % entsprechend skalieren
	angle1 angle2 arcn   % und Kreis zeichnen
	setmatrix
	SOCol                % Zeichenfarbe setzen
	stroke
} bind def

/DrawPie { % Zeichnen ein Ellipsensegment (x1 x2 x2 y2 angle1 angle2 Opaque)
           % mit Verbindung zum Mittelpunkt
	/Opaque exch def
	/angle2 exch def
	/angle1 exch def
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	0 0                  % Ursprung auf den Stack
	newpath
	x1 x2 add 2 div      % Mittelpunkt bestimmen
	y1 y2 add 2 div
	translate            % entsprechend verschieben
	x2 x1 sub abs        % Seitenlaengen berechnen
	y2 y1 sub abs
	dup 2 div            % Radius sichern
	3 1 roll             % Seitenlaengen nach oben
	div                  % Seitenverhaeltnis berechnen
	1.0 scale            % entsprechend skalieren
	angle1 angle2 arcn   % und Kreis zeichnen
        0 0 lineto closepath % zum Mittelpunkt uns schliessen
	Opaque { 
	  gsave SFCol fill grestore
	} if
	setmatrix
	SOCol                % Zeichenfarbe setzen
	stroke
} bind def

/DSArc { % Zeichnet einen einfachen Kreisbogen an den aktuellen Pfad
         % (x y w h a1 a2)
	/a2 exch def
	/a1 exch def
	/h exch def
	/w exch def
	/y exch def
	/x exch def
	matrix currentmatrix % CTM sichern
	x y translate        % entspr. Ursprung verschieben
	w h div 1 scale      % und der Seitenverhaeltnisse skalieren
	0 0 h a1 a2 arc      % Bogen zeichnen
	setmatrix            % Original-CTM wiederherstellen
} bind def

/DrawRoundedRect { % Zeichnet ein abgerundetes Rechteck (x1 y1 x2 y2 opaque r)
  /r exch def
  /Opaque exch def
  /oy2 exch def
  /x2 exch def
  /oy1 exch def
  /x1 exch def
  /y1 oy2 oy1 lt { oy2 } { oy1 } ifelse def 
  /y2 y1 oy1 eq { oy2 } { oy1 } ifelse def 
  /w x2 x1 sub abs def
  /h y2 y1 sub abs def
  /wr r w mul 200 div def
  /hr r h mul 200 div def

  x1 wr add y1 moveto
  x2 wr sub y1 lineto
  x2 wr sub y1 hr add wr hr 270 360 DSArc

  x2 y2 hr sub lineto
  x2 wr sub y2 hr sub wr hr 0 90 DSArc

  x1 wr add y2 lineto
  x1 wr add y2 hr sub wr hr 90 180 DSArc

  x1 y1 hr add lineto
  x1 wr add y1 hr add wr hr 180 270 DSArc
  closepath

  Opaque {
    gsave SFCol fill grestore
  } if
  setmatrix
  SOCol
  stroke
} bind def

/FontHeight {                % Ermittelt die Hoehe des aktuellen Fonts
  currentfont /FontMatrix get
  3 get
  1000 mul
} bind def

/DrawText { % [ line1 ... linen] xpos ypos align font size
  /fsize exch def
  /fname exch def
  /align exch def
  /ypos exch def
  /xpos exch def
  /text exch def
  fname findfont
  fsize scalefont
  setfont
  /fheight FontHeight def
  /len 0 def              % maximale Zeilenlaenge
  0 1 text length 1 sub { % fuer jede Zeile
    text exch get stringwidth pop % Zeilenlaenge
    dup len gt { /len exch def } { pop } ifelse
  } for
  SOCol
  % Transformationsmatrix fuer Spiegelung
  0 ypos neg matrix translate
  1.0 -1.0 matrix scale
  matrix concatmatrix
  0 ypos matrix translate
  matrix concatmatrix
  concat
  0 1 text length 1 sub { % fuer jede Zeile
    dup                   % Zaehler duplizieren
    fheight mul ypos      % y-Position ermitteln
    exch sub fheight sub
    xpos exch moveto      % auf Anfangspunkt positionieren
    text exch get dup     % String besorgen
    stringwidth pop       % Laenge ermitteln
    align 0 eq {          % Ausrichtung: links
      pop
    }
    {
      align 1 eq {        % Ausrichtung: zentriert
        len exch sub 2 div 0 rmoveto
      }
      {                   % Ausrichtung: rechts
        len exch sub 0 rmoveto
      } ifelse
    } ifelse
    show                  % String ausgeben
  } for
  setmatrix
} bind def

/TransFont { 
  % Erzeugt neuen Font mit deutschen Umlauten und 
  % Sonderzeichen 
  % (Quelle: Weltner: Das grosse Buch zu PostScript, Data Becker)

  /newName exch def % Name des neuen Fonts
  /oldName exch def % Name des Stamm-Fonts

  % Stamm-Dictionary spechern
  /oldDict oldName findfont def
  % neues Dictionary erzeugen
  /newDict oldDict maxlength dict def

  % die alten Eintraege des Stamm-Dictionaries in das neue kopieren
  oldDict {
    1 index /FID ne {
      1 index /Encoding eq {
	% Encoding-Feld separat kopieren
	dup
	length array
	copy
	newDict 3 1 roll
	put
      } {
	% alle anderen Eintraege durch put
	newDict 3 1 roll put
      } ifelse
    } {
      % FID nicht kopieren
      pop pop
    } ifelse
  } forall

  % neues Dictionary kopieren
  newDict begin
    % die deutschen Umlaute an unbenutzten Stellen einfuegen
    Encoding 8#200 /Adieresis put % "Ä"
    Encoding 8#201 /Odieresis put % "Ö"
    Encoding 8#202 /Udieresis put % "Ü"
    Encoding 8#203 /adieresis put % "ä"
    Encoding 8#204 /odieresis put % "ö"
    Encoding 8#205 /udieresis put % "ü"
    % den Namen des Fonts eintragen
    /FontName newName 100 string cvs def
  end

  % Font in das FontDictionary eintragen
  newName newDict definefont
  pop
} bind def

/InitTMatrix {  % Initialisiert die CTM fuer das QT-Modell
  1.0 -1.0 scale
  0 PaperHeight neg translate
} def

%%EndProlog
