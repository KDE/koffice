%%BeginProlog
/OCol [ 0 0 0 ] def % Zeichenfarbe
/FCol [ 0 0 0 ] def % Fuellfarbe

/DOCol { % Definieren der Zeichenfarben (rot gruen blau)
	OCol astore pop
} bind def

/DFCol { % Definieren der Fullfarbe (rot grueen blau)
	FCol astore pop
} bind def

/SOCol { % Setzen der aktuellen Zeichenfarbe aus OCol
	OCol aload pop setrgbcolor
} bind def

/SFCol { % Setzen der aktuellen Fuellfarbe aus FCol
	FCol aload pop setrgbcolor
} bind def

/SMatrix { % Initialisieren der Transformationsmatrix (Array)
	% Hinterlaesst Originalmatrix auf dem Stack !
	matrix currentmatrix % Originalmatrix sichern
	exch                 % Feld fuer neue Matrix nach oben
	concat               % mit CTM verknuepfen
} bind def

/RMatrix { % Wiederherstellen der originalen Transformationsmatrix
	setmatrix
} bind def

/DrawPolyline { % Zeichnen einer Polyline ([xn yn ... x1 y1])
	aload           % Feld entladen
	length          % Anzahl der Eintraege
	2 sub           % 2 fuer moveto
	2 div           % div fuer Wertepaare
	3 1 roll        % Koordinaten fuer moveto nach oben
	moveto          % Anfangspunkt
	cvi             % von real nach integer konvertieren
	{lineto} repeat % und entsprechend oft ausfuehren
	SOCol           % Zeichenfarbe setzen
	setmatrix       % Transformationsmatrix wiederherstellen
	stroke          % und nachziehen
} bind def

/DrawPolygon { % Zeichnen eines Polygons ([xn yn ... x1 y1] opaque)
	/Opaque exch def
	aload           % Feld entladen
	length          % Anzahl der Eintraege
	2 sub           % 2 fuer moveto
	2 div           % div fuer Wertepaare
	3 1 roll        % Koordinaten fuer moveto nach oben
	moveto          % Anfangspunkt
	cvi             % von real nach integer konvertieren
	{lineto} repeat % und entsprechend oft ausfuehren
	closepath       % Pfad beenden
	SOCol           % Zeichenfarbe setzen
	Opaque {        % wenn nicht transparent
	  gsave SFCol fill grestore     % fuellen
	} if
	setmatrix       % Transformationsmatrix wiederherstellen
	stroke          % und nachziehen
} bind def

/DrawEllipse { % Zeichnen einer Ellipse (x1 x2 x2 y2 opaque)
	/Opaque exch def
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	0 0                  % Ursprung auf den Stack
	newpath
	x1 x2 add 2 div      % Mittelpunkt bestimmen
	y1 y2 add 2 div
	translate            % entsprechend verschieben
	x2 x1 sub abs        % Seitenlaengen berechnen
	y2 y1 sub abs
	dup 2 div            % Radius sichern
	3 1 roll             % Seitenlaengen nach oben
	div                  % Seitenverhaeltnis berechnen
	1.0 scale            % entsprechend skalieren
	0 360 arc            % und Kreis zeichnen
	Opaque { 
	  gsave SFCol fill grestore
	} if
	setmatrix
	SOCol                % Zeichenfarbe setzen
	stroke
} bind def

/DrawArc { % Zeichnen ein Ellipsensegment (x1 x2 x2 y2 angle1 angle2)
           % ohne Verbindung zum Mittelpunkt
	/angle2 exch def
	/angle1 exch def
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	0 0                  % Ursprung auf den Stack
	newpath
	x1 x2 add 2 div      % Mittelpunkt bestimmen
	y1 y2 add 2 div
	translate            % entsprechend verschieben
	x2 x1 sub abs        % Seitenlaengen berechnen
	y2 y1 sub abs
	dup 2 div            % Radius sichern
	3 1 roll             % Seitenlaengen nach oben
	div                  % Seitenverhaeltnis berechnen
	1.0 scale            % entsprechend skalieren
	angle1 angle2 arcn   % und Kreis zeichnen
	setmatrix
	SOCol                % Zeichenfarbe setzen
	stroke
} bind def

/DSArc { % Zeichnet einen einfachen Kreisbogen an den aktuellen Pfad
         % (x y w h a1 a2)
	/a2 exch def
	/a1 exch def
	/h exch def
	/w exch def
	/y exch def
	/x exch def
	matrix currentmatrix % CTM sichern
	x y translate        % entspr. Ursprung verschieben
	w h div 1 scale      % und der Seitenverhaeltnisse skalieren
	0 0 h a1 a2 arc      % Bogen zeichnen
	setmatrix            % Original-CTM wiederherstellen
} bind def

/DrawRoundedRect { % Zeichnet ein abgerundetes Rechteck (x1 y1 x2 y2 opaque r)
  /r exch def
  /Opaque exch def
  /oy2 exch def
  /x2 exch def
  /oy1 exch def
  /x1 exch def
  /y1 oy2 oy1 lt { oy2 } { oy1 } ifelse def 
  /y2 y1 oy1 eq { oy2 } { oy1 } ifelse def 
  /w x2 x1 sub abs def
  /h y2 y1 sub abs def
  /wr r w mul 200 div def
  /hr r h mul 200 div def

  x1 wr add y1 moveto
  x2 wr sub y1 lineto
  x2 wr sub y1 hr add wr hr 270 360 DSArc

  x2 y2 hr sub lineto
  x2 wr sub y2 hr sub wr hr 0 90 DSArc

  x1 wr add y2 lineto
  x1 wr add y2 hr sub wr hr 90 180 DSArc

  x1 y1 hr add lineto
  x1 wr add y1 hr add wr hr 180 270 DSArc
  closepath

  Opaque {
    gsave SFCol fill grestore
  } if
  setmatrix
  SOCol
  stroke
} bind def

/FontHeight {                % Ermittelt die Hoehe des aktuellen Fonts
  currentfont /FontMatrix get
  3 get
  1000 mul
} bind def

/DrawText { % [ line1 ... linen] xpos ypos font size
  /fsize exch def
  /fname exch def
  /ypos exch def
  /xpos exch def
  /text exch def
  fname findfont
  fsize scalefont
  setfont
  /fheight FontHeight def
  SOCol
  % Transformationsmatrix fuer Spiegelung
  0 ypos neg matrix translate
  1.0 -1.0 matrix scale
  matrix concatmatrix
  0 ypos matrix translate
  matrix concatmatrix
  concat
  0 1 text length 1 sub { % fuer jede Zeile
    dup                   % Zaehler duplizieren
    fheight mul ypos      % y-Position ermitteln
    exch sub fheight sub
    xpos exch moveto      % auf Anfangspunkt positionieren
    text exch get show    % String ausgeben
  } for
  setmatrix
} bind def

/InitTMatrix {  % Initialisiert die CTM fuer das QT-Modell
  1.0 -1.0 scale
  0 PaperHeight neg translate
} def

%%EndProlog
