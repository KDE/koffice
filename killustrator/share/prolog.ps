%%BeginProlog
/OCol [ 0 0 0 ] def /FCol [ 0 0 0 ] def /DOCol { OCol astore pop } bind def 
/DFCol { FCol astore pop } bind def /SOCol { OCol aload pop setrgbcolor } bind 
def /SFCol { FCol aload pop setrgbcolor } bind def /PStArr [ [] [7 2] [1 5] 
[10 3 2 3] [10 3 2 3 2 3] ] def /SPSt { /Style exch def Style 1 ge Style 5 le 
and { PStArr Style 1 sub get } { [] } ifelse 0 setdash } bind def /SMatrix { 
matrix currentmatrix exch concat } bind def /RMatrix { setmatrix } bind def 
/DrawPolyline { aload length 2 sub 2 div 3 1 roll moveto cvi {lineto} repeat 
SOCol setmatrix stroke } bind def /DrawPolygon { /Opaque exch def aload length 
2 sub 2 div 3 1 roll moveto cvi {lineto} repeat closepath SOCol Opaque { gsave 
SFCol fill grestore } if setmatrix stroke } bind def /DrawEllipse { /Opaque 
exch def /y2 exch def /x2 exch def /y1 exch def /x1 exch def 0 0 newpath x1 x2 
add 2 div y1 y2 add 2 div translate x2 x1 sub abs y2 y1 sub abs dup 2 div 3 1 
roll div 1.0 scale 0 360 arc Opaque { gsave SFCol fill grestore } if setmatrix 
SOCol stroke } bind def /DrawArc { /angle2 exch def /angle1 exch def /y2 exch 
def /x2 exch def /y1 exch def /x1 exch def 0 0 newpath x1 x2 add 2 div y1 y2 
add 2 div translate x2 x1 sub abs y2 y1 sub abs dup 2 div 3 1 roll div 1.0 
scale angle1 angle2 arcn setmatrix SOCol stroke } bind def /DrawPie { /Opaque 
exch def /angle2 exch def /angle1 exch def /y2 exch def /x2 exch def /y1 exch 
def /x1 exch def 0 0 newpath x1 x2 add 2 div y1 y2 add 2 div translate x2 x1 
sub abs y2 y1 sub abs dup 2 div 3 1 roll div 1.0 scale angle1 angle2 arcn 0 0 
lineto closepath Opaque { gsave SFCol fill grestore } if setmatrix SOCol 
stroke } bind def /DSArc { /a2 exch def /a1 exch def /h exch def /w exch def 
/y exch def /x exch def matrix currentmatrix x y translate w h div 1 scale 0 0 
h a1 a2 arc setmatrix } bind def /DrawRoundedRect { /r exch def /Opaque exch 
def /oy2 exch def /x2 exch def /oy1 exch def /x1 exch def /y1 oy2 oy1 lt { oy2 
} { oy1 } ifelse def /y2 y1 oy1 eq { oy2 } { oy1 } ifelse def /w x2 x1 sub abs 
def /h y2 y1 sub abs def /wr r w mul 200 div def /hr r h mul 200 div def x1 wr 
add y1 moveto x2 wr sub y1 lineto x2 wr sub y1 hr add wr hr 270 360 DSArc x2 
y2 hr sub lineto x2 wr sub y2 hr sub wr hr 0 90 DSArc x1 wr add y2 lineto x1 
wr add y2 hr sub wr hr 90 180 DSArc x1 y1 hr add lineto x1 wr add y1 hr add wr 
hr 180 270 DSArc closepath Opaque { gsave SFCol fill grestore } if setmatrix 
SOCol stroke } bind def /FontHeight { currentfont /FontMatrix get 3 get 1000 
mul } bind def /DrawText { /fsize exch def /fname exch def /ypos exch def 
/xpos exch def /text exch def fname findfont fsize scalefont setfont /fheight 
FontHeight def SOCol 0 ypos neg matrix translate 1.0 -1.0 matrix scale matrix 
concatmatrix 0 ypos matrix translate matrix concatmatrix concat 0 1 text 
length 1 sub { dup fheight mul ypos exch sub fheight sub xpos exch moveto text 
exch get show } for setmatrix } bind def /TransFont { /newName exch def 
/oldName exch def /oldDict oldName findfont def /newDict oldDict maxlength 
dict def oldDict { 1 index /FID ne { 1 index /Encoding eq { dup length array 
copy newDict 3 1 roll put } { newDict 3 1 roll put } ifelse } { pop pop } 
ifelse } forall newDict begin Encoding 8#200 /Adieresis put Encoding 8#201 
/Odieresis put Encoding 8#202 /Udieresis put Encoding 8#203 /adieresis put 
Encoding 8#204 /odieresis put Encoding 8#205 /udieresis put /FontName newName 
100 string cvs def end newName newDict definefont pop } bind def /InitTMatrix 
{ 1.0 -1.0 scale 0 PaperHeight neg translate } def 
%%EndProlog

