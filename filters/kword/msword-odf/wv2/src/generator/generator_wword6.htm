<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.4.3-20mdk i686) [Netscape]">
   <title>Microsoft Word 6.0 Binary File Format</title>
</head>
<body>

<div class="Section1">
<div class="code"><tt>/*</tt>
<br><tt>Copyright (C) 2001, S.R.Haque.</tt>
<p><tt>This file is a modified version of the original document published
by Microsoft. Copies of the original are available at various places including:</tt>
<p><tt>http://www.wotsit.org/download.asp?f=wword60</tt>
<p><tt>It has had its formatting regularised to facilitate automated extract
of the structure definitions contained within it. It also contains:</tt>
<p><tt>&nbsp;&nbsp; -some corrections for "obvious" mistakes in the original.</tt>
<p><tt>&nbsp;&nbsp; -rationalisation of the types used in the structure
definitions to use unsigned variables as the basic type.</tt>
<p><tt>&nbsp;&nbsp; -signed types might need adding back in specific instances
that I missed.</tt>
<p><tt>&nbsp;&nbsp; -rationalisation of the way bitfields are described.</tt>
<p><tt>MODIFICATION HISTORY</tt>
<p><tt>23-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; Merge Werner's changes.</tt>
<br><tt>19-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; Reconciled with Word
97 spec.</tt>
<br><tt>17-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; Reorder alphabetically
to ease comparison.</tt>
<br><tt>14-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; First pass of corrections/tidyup.</tt>
<br><tt>7-Jul-2001&nbsp; shaheedhaque&nbsp;&nbsp;&nbsp; First released.</tt>
<br><tt>*/</tt></div>

<h1>
Microsoft Word 6.0 Binary File Format</h1>

<h2>
Revision history</h2>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>12/02/93</td>

<td>Updated structures and sprm table for Windows Word 6.0 format</td>
</tr>

<tr>
<td>10/25/91</td>

<td>Reformatted document, removed revision marks and completed thesummary
of changes from Windows Word 1.x to 2.0 format.</td>
</tr>

<tr>
<td>5/10/91</td>

<td>Updated structures and sprm table for Windows Word 2.0 format.</td>
</tr>

<tr>
<td>1/23/90</td>

<td>Corrected offsets with the definition of the FIB</td>
</tr>

<tr>
<td>6/16/89</td>

<td>Updated structure definitions</td>
</tr>

<tr>
<td>1/9/89</td>

<td>Document Created</td>
</tr>
</table>

<h2>
Table of Contents</h2>

<ul>
<li>
<a href="#_Toc517856959">DEFINITIONS</a></li>

<li>
<a href="#_Toc517857003">NAMING CONVENTIONS.</a></li>

<li>
<a href="#_Toc517857004">WORD AND DOCFILES.</a></li>

<li>
<a href="#_Toc517857005">FORMAT OF THE SUMMARY INFO STREAM IN A WORD FILE
.</a></li>

<li>
<a href="#_Toc517857006">FORMAT OF THE MAIN STREAM IN A WORD NON-COMPLEX
FILE .</a></li>

<li>
<a href="#_Toc517857007">FORMAT OF THE MAIN STREAM IN A COMPLEX FILE</a></li>

<li>
<a href="#TocFIB">FIB</a></li>

<li>
<a href="#TocTEXT">TEXT</a></li>

<li>
<a href="#_Toc517857010">CHARACTER AND PARAGRAPH FORMATTING PROPERTIES</a></li>

<li>
<a href="#_Toc517857011">BIN TABLES</a></li>

<li>
<a href="#TocSTYLESHEET">STYLESHEET</a></li>

<li>
<a href="#_Toc517857013">Stylesheet File Format</a></li>

<ul>
<li>
<a href="#_Toc517857014">STSHI</a></li>

<li>
<a href="#_Toc517857015">STD</a></li>
</ul>

<li>
<a href="#TocSPRMS">SPRM DEFINITIONS.</a></li>

<li>
<a href="#_Toc517857017">COMPLEX FILE FORMAT.</a></li>

<ul>
<li>
<a href="#_Toc517857018">Algorithm to determine the bounds of a paragraph&nbsp;
containing a certain character in a complex file</a></li>

<li>
<a href="#_Toc517857019">Algorithm to determine paragraph properties for
a paragraph in a complex file</a></li>

<li>
<a href="#_Toc517857020">Algorithm to determine table properties for a
table row in a complex file</a></li>

<li>
<a href="#_Toc517857021">Algorithm to determine the character properties
of a character in a complex file</a></li>

<li>
<a href="#_Toc517857022">Algorithm to determine the section properties
of a section in a complex file .</a></li>

<li>
<a href="#_Toc517857023">Algorithm to determine the pic of a picture in
a complex file.</a></li>
</ul>

<li>
<a href="#_Toc517857024">FOOTNOTES</a></li>

<li>
<a href="#_Toc517857025">HEADERS AND FOOTERS.</a></li>

<li>
<a href="#_Toc517857026">Page Table.</a></li>

<li>
<a href="#_Toc517857027">Glossary Files.</a></li>

<li>
<a href="#_Toc517857028">STTBFASSOC(Table of Associated Strings)</a></li>

<li>
<a href="#_Toc517857029">STRUCTURE DEFINITIONS</a></li>

<ul>
<li>
<a href="#ANLD">Autonumbered List Data Descriptor (ANLD)</a></li>

<li>
<a href="#ANLV">Autonumber Level Descriptor (ANLV)</a></li>

<li>
<a href="#BKF">BooKmark First descriptor (BKF)</a></li>

<li>
<a href="#BKL">BooKmark Lim descriptor (BKL)</a></li>

<li>
<a href="#BRC">Border Code (BRC)</a></li>

<li>
<a href="#BRC10">Border Code for Windows Word 1.0 (BRC10)</a></li>

<li>
<a href="#BTE">Bin Table Entry (BTE)</a></li>

<li>
<a href="#CHP">Character Properties (CHP)</a></li>

<li>
<a href="#CHPX">Character Property Exceptions (CHPX)</a></li>

<li>
<a href="#DTTM">Date and Time (internal date format) (DTTM)</a></li>

<li>
<a href="#DCS">Drop Cap Specifier (DCS)</a></li>

<li>
<a href="#DOP">Document Properties (DOP)</a></li>

<li>
<a href="#DO">Drawing Object (Word) (DO)</a></li>

<li>
<a href="#DPHEAD">Drawing Primitive Header (Word) (DPHEAD)</a></li>

<li>
<a href="#DPLINE">DP data for a line (DPLINE)</a></li>

<li>
<a href="#DPTXBX">DP data for a textbox (DPTXBX)</a></li>

<li>
<a href="#DPRECT">DP data for a rectangle (DPRECT)</a></li>

<li>
<a href="#DPARC">DP data for an arc (DPARC)</a></li>

<li>
<a href="#DPELLIPSE">DP data for an ellipse (DPELLIPSE)</a></li>

<li>
<a href="#DPPOLYLINE">DP data for a polyline (DPPOLYLINE)</a></li>

<li>
<a href="#_Toc517857049">DP data for a callout textbox .</a></li>

<li>
<a href="#OBJHEADER">Embedded Object Properties (OBJHEADER)</a></li>

<li>
<a href="#FLD">Field Descriptor (FLD)</a></li>

<li>
<a href="#FDOA">File Drawn Object Address (Word) (FDOA)</a></li>

<li>
<a href="#FFN">Font Family Name (FFN)</a></li>

<li>
<a href="#FIB">File Information Block (Windows Word) (FIB)</a></li>

<li>
<a href="#CHPXFKP">Formatted Disk Page for CHPXs (CHPXFKP)</a></li>

<li>
<a href="#PAPXFKP">Formatted Disk Page for PAPXs (PAPXFKP)</a></li>

<li>
<a href="#LSPD">Line Spacing Descriptor (LSPD)</a></li>

<li>
<a href="#OLST">Outline LiST Data (OLST)</a></li>

<li>
<a href="#PGD">Page Descriptor (PGD)</a></li>

<li>
<a href="#PHE">Paragraph Height (PHE)</a></li>

<li>
<a href="#PAP">Paragraph Properties (PAP)</a></li>

<li>
<a href="#PAPX">Paragraph Property Exceptions (PAPX)</a></li>

<li>
<a href="#PIC">Picture Descriptor (PIC)</a></li>

<li>
<a href="#PCD">Piece Descriptor (PCD)</a></li>

<li>
<a href="#PLCF">Plex of CPs stored in File (PLCF)</a></li>

<li>
<a href="#_Toc517857066">Property Modifier(variant 1) (PRM1)</a></li>

<li>
<a href="#_Toc517857067">Property Modifier(variant 2) (PRM2)</a></li>

<li>
<a href="#SED">Section Descriptor (SED)</a></li>

<li>
<a href="#SEP">Section Properties (SEP)</a></li>

<li>
<a href="#SEPX">Section Property Exceptions (SEPX)</a></li>

<li>
<a href="#TBD">Tab Descriptor (TBD)</a></li>

<li>
<a href="#TC">Table Cell Descriptors (TC)</a></li>

<li>
<a href="#TLP">Table Autoformat Look sPecifier (TLP)</a></li>

<li>
<a href="#TAP">Table Properties (TAP)</a></li>
</ul>
</ul>
<a href="#_Toc517857075">Appendix A - Changes from version 1.x to 2.0 .</a>
<br><a href="#_Toc517857076">Changes to Structures</a>
<br><a href="#_Toc517857077">BRC..</a>
<br><a href="#_Toc517857078">CHP.</a>
<br><a href="#_Toc517857079">DOP.</a>
<br><a href="#_Toc517857080">DTTM..</a>
<br><a href="#_Toc517857081">FIB..</a>
<br><a href="#_Toc517857082">_OBJHEADER.</a>
<br><a href="#_Toc517857083">PAP.</a>
<br><a href="#_Toc517857084">PIC..</a>
<br><a href="#_Toc517857085">SEP.</a>
<br><a href="#_Toc517857086">DOP to SEP.</a>
<br><a href="#_Toc517857087">SED..</a>
<br><a href="#_Toc517857088">TAP.</a>
<br><a href="#_Toc517857089">TAP.</a>
<br><a href="#_Toc517857090">TC</a>
<br><a href="#_Toc517857091">Other changes</a>
<br><a href="#_Toc517857092">sttbfAssoc.</a>
<br><a href="#_Toc517857093">sttbfFn.</a>
<br><a href="#_Toc517857094">REVIEW DavidLu .</a>
<br><a href="#FTCL">FonT Code Link field (FTCL)</a>
<br><a href="#_Toc517857096">Index of Changes from version 1.x to 2.0</a>
<h1>
DEFINITIONS</h1>

<h2>
OLE 2.0:</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">Object Linking
and Embedding 2.0</div>

<h2>
API (Application Programming Interface):</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A set of libraries,
functions, definitions, etc. which describe an interface to a programming
environment or model.</div>

<h2>
docfile:</h2>

<div class="defnbody">An OLE 2.0 compatible multi-stream file</div>

<h2>
page (or sector):</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">512 byte segment
of the main stream within a Word docfile that begins on a 512-byte boundary.
(bytes 0-511 are in page 0, bytes 512-1023 are in page 1, etc.). In Word
data structures, an unsigned two-byte integer page number is given the
acronym <b>PN </b>(for <b>P</b>age <b>N</b>umber).</div>

<h2>
document:</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A named, multi-linked
list of data structures, representing an ordered stream of text with properties
that was produced by a user of Microsoft Word</div>

<h2>
stream:</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The physical encoding
of a Word document 's text and sub data structures in a random access stream
within a docfile.</div>

<h2>
main stream</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The stream within
a Word docfile containing the bulk Words binary data.</div>

<h2>
summary information stream</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The stream within
a Word docfile containing the document summary information.</div>

<h2>
object stream</h2>

<div class="defnbody">A stream containing binary data for an embedded OLE
2.0 object.</div>

<h2>
CP&nbsp; (Character Position)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A four-byte integer
which is the position coordinate of a character of text within the logical
text stream of a document.</div>

<h2>
FC (File Character position)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A four-byte integer
which is the byte offset of a character (or other object) from the beginning
of the main stream of the docfile. Before a file has been edited(ie. in
a full saved Word document), CPscan be transformed into <b>FC</b>s by adding
the <b>FC</b> coordinate of the beginning of a document's text stream to
the CP. After a file has been edited (ie. in a fast-saved Word document),
the mapping from <b>CP</b> to <b>FC</b> is recorded in the
<b>piece table</b>(see
below)</div>

<h2>
PLCF (PLex of Cps (or FCs) stored in File)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A data structure
consisting of two parallel arrays that allows a relation to be established
between a certain <b>CP</b> position in the document text stream (or <b>FC</b>
position in a file) and an arbitrary data structure. It consists of an
array of <b>n+1 CP</b>s or <b>FC</b>s followed by an array of <b>n</b>
instances of a particular arbitrary data structure. In typical usage, the
<b>nth
CP </b>or<b> FC</b> of the <b>PLCF</b> is in one-to-one correspondence
with the <b>nth </b>instance<b> </b>of the arbitrary data structure, with
the <b>n+1st</b> <b>CP </b>or<b> FC</b> marking the limit of the <b>nth</b>
instance's influence. When a <b>PLCF</b> is used to record a partitioning
of the document's text stream or a partitioning of the bytes stored in
a file, the 0th <b>CP/FC </b>stored in the <b>PLCF</b> will be 0. When
a <b>PLCF </b>is used to record the location of certain marks or links
within the document text stream, the 0th <b>CP/FC</b> stored in the
<b>PLCF
</b>will
record the position of the 0th mark or link. To properly interpret a <b>PLCF</b>
stored in a Word file, the length of the stored <b>PLCF</b> and the length
of the arbitrary data structure stored in the <b>PLCF </b>must be known<b>.
</b>The
length of the stored PLCF is recorded in the <b>FIB.
</b>The lengths of
the data structures stored in PLCFs within Word files are listed later
in this document.</div>

<h2>
piece table</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The <b>piece table
</b>is
a data structure that describes the logical sequence of characters in a
Word document and records recent changes to the formatting of a Word document.
It is stored in a Word file as a <b>PLCF</b> named the
<b>plcfpcd</b> (<b>PL</b>ex
of <b>C</b>ps containing <b>P</b>ie<b>c</b>e <b>D</b>escriptors).The piece
table relates a logical character number, called a <b>CP </b>(<b>C</b>haracter
<b>P</b>osition),
to a physical location within a Word file (an <b>FC</b>). The array of
<b>CP</b>s
in the <b>plcfpcd</b> defines a partitioning of the Word document into
disjoint pieces. The second array is an array of
<b>PCD</b>s (<b>P</b>ie<b>c</b>e
<b>D</b>escriptors)
which is in 1-to-1 correspondence to the array of <b>CP</b>s that records
the physical location in the Word file where the corresponding piece begins.
To find the physical location of a particular logical character in aWord
document, take the
<b>CP</b> coordinate of that character within the document
and find the piece that contains that character. This is done by finding
the index of the largest<b>CP </b>in the array of <b>CP</b>s that is less
than the character
<b>CP</b>. Thenreference the <b>PCD</b> with that index
in the array of
<b>PCD</b>s. The <b>FC</b> stored in the
<b>PCD </b>gives
the position of the beginning of the piece in the file. Finally, add the
offset of the desired character from the beginning of its piece to the
<b>FC</b>
of the beginning of the piece. This gives the actual file offset of the
character.</div>

<h2>
sprm&nbsp; (Single PRoperty Modifier)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">An instruction
to modify one or more properties within one of the property defining data
structures (<b>CHP</b>, <b>PAP</b>, <b>TAP</b>, <b>SEP, or PIC</b>). It
consists of an operation code which identifies the field(s) to be changed,
and anoperand which gives the value that a particular field is changed
to or else which is a parameter to a procedure which will change the field
or fields. The operand is omitted for <b>sprms</b> whose opcodes completely
specify the values that must be stored in the property data structure.
A synonym used for <b>sprm</b> in some data structure definitions is <b>prl
</b>(<b>pr</b>operty
modifiers stored in a <b>l</b>ist).</div>

<h2>
grpprl (group of prls)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A grpprl is a
data structure that records a set of<b>sprm</b>s. The 0th <b>sprm</b> is
recorded at offset 0 of the structure. Any succeeding <b>sprm</b> s are
recorded immediately after the end of the preceding <b>sprm</b> . To traverse
a <b>grpprl</b> and locate the <b>sprms</b> recorded within it, it?s necessary
to fetch the opcode of the first <b>sprm</b>, lookup the length of the
<b>sprm</b>
with that opcode, use that length to skip past the first
<b>sprm</b>, fetch
the opcode of the second <b>sprm</b>, lookup the length of that <b>sprm</b>,
use the length to skip the second <b>sprm</b>, and so on. See the table
in the ?<b>SPRM Definition</b>? topic to determine the length of a <b>sprm</b>.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The phrase ?<b>apply
the sprms of a grpprl</b> (or <b>papx</b> or <b>sepx)</b> ? used later
in this document means to fetch the 0th <b>sprm </b>recorded in the <b>grpprl</b>
and perform the action for that sprm, fetch the first <b>sprm</b> and perform
its action, and continue this procedure until all <b>sprms</b> in the <b>grpprl</b>
(or <b>papx</b> or <b>sepx) </b>have been processed.</div>

<h2>
prm&nbsp; (PRoperty Modifier)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A field in piece
table entries that records how the properties of text within a piece were
changed to reflect user formatting operations. The <b>prm</b> usually contains
an index to a <b>grpprl</b> which records the user?s formatting changes
as a group of <b>sprm</b>s. If the user has made only a small change to
formatting that can be expressed as a single 2 or 1-byte <b>sprm</b>, that
<b>sprm
</b>is
stored within the <b>prm</b>.</div>

<h2>
STTBF (STring TaBle stored in File)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">Word has many
tables of strings that are stored as Pascal type strings. Pascal strings
begin with a single byte length count which describes how many characters
follow the length byte in the string. If pst is a pointer to an array of
characters storing a pascal style string then the length of the string
is *pst+1. In an STTBF pascal style strings are concatenated one after
another until the length of the STTBF recorded in the FIB is exhausted.</div>

<h2>
full-saved (or non-complex) file</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A Word file in
which the physical order of characters stored in the file is identical
to the logical order of characters in the document that the file represents.
The text stream of a non-complex file can be described by an <b>fc</b>
(an offset from the beginning of the file) to mark where the text begins
and a <b>ccp </b>(<b>c</b>ount of <b>CP</b>s) to record how many characters
are stored in the text stream. When a file is stored in non-complex format,
the <b>fc</b> and <b>ccp </b>allow an initial piece table to be constructed
when the file is read.</div>

<h2>
fast-saved (or complex) file</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A Word file in
which the physical order of characters stored in the file does not match
the logical order of characters in the document that the file represents.
A <b>piece table</b> must be stored in the file to describe the text stream
of the document.</div>

<h2>
FIB (File Information Block)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The header of
a Windows Word file. Begins at offset 0 in file. Gives the beginning offsetand
lengths of the document's text stream and subsidiary data structures within
the file. Also stores other file status information.</div>

<h2>
paragraph</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A contiguous sequence
of characters within the text stream of a document that is delimited by
a paragraph mark, cell mark, row mark, or a section mark (These are special
characters described later in this document).</div>

<h2>
run of text</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A contiguous sequence
of characters within the text stream of a document that have the same character
formatting properties. A single run may cross paragraph boundaries and
may encompass the entire document.</div>

<h2>
section</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A contiguous sequence
of paragraphs within the text stream of a document that is delimited by
a section mark or by the final paragraph mark at the end of a document.
Users frequently treat sections as the equivalent of a chapter in a book.
The boundaries of sections mark locations where the layout rules for a
document (number of columns, text of headers and footers to use, whether
page numbers should be displayed, etc.) are changed.</div>

<h2>
paragraph style</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A named set of
character and paragraph properties that can be associated with any number
of <b>paragraphs</b> in a Word document's text stream. A
<b>paragraphstyle</b>
provides a set of character and paragraph property defaults for the text
of any paragraph tagged with that style. When a new paragraph is created
and given a particular style, newly typed text is given the character and
paragraph properties of that style unless the user makes an exception to
the paragraph style definition by performing other editing operations.</div>

<h2>
CHP (CHaracter Properties)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The data structure
describing the character properties of a run of text.</div>

<h2>
CHPX (Character Property EXception)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A data structure
which describes how a particular <b>CHP</b> differs from a reference <b>CHP</b>.
In Win Word 6.0, the <b>CHPX</b> simply consists of a <b>grpprl</b> which
is applied to the reference <b>CHP</b> to produce the originally encoded
<b>CHP</b>.
By applying a <b>CHPX </b>to the character properties (<b>CHP)</b> inherited
by a particular paragraph from its <b>style</b> ,it is possible to reconstitute
the <b>CHP </b>for the portion of the character run that intersects that
paragraph</div>

<h2>
character style</h2>

<div class="defnbody">A named character property exception that can be
associated with any number of runs of text in a Word document?s text stream.
When a run of text is tagged with a particular <b>character style</b>,
a <b>chpx</b> recorded for the character style is applied to the character
properties that are defined for the paragraph style of the paragraph that
contains the text. This means that the character style can change one or
more of the character property field settings specified by the paragraph
style of a paragraph to a particular setting without changing the value
of any other field.</div>

<h2>
PAP (PAragraph Properties)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The data structure
which describes the properties of a particular paragraph.</div>

<h2>
PAPX (PAragraph Property EXception)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A data structure
describing how a particular paragraph?s properties differ from the paragraph
properties of the style assigned to the paragraph. By applying a <b>PAPX</b>
to the paragraph properties (<b>PAP</b>) inherited by a particular paragraph
from its <b>style</b>, it is possible to reconstitute the <b>PAP</b> for
that paragraph. The <b>PAPX</b> contains an <b>ISTD </b>(a style code to
identify the style in control of the paragraph and a <b>grpprl</b> which
specifies how the style's paragraph properties must be changed to produce
the paragraph properties of the paragraph.</div>

<h2>
table row</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A contiguous sequence
of paragraphs within the text stream of a document that is partitioned
into subsequences of paragraphs called <b>cells.</b> The last paragraph
of each cell is terminated by a special paragraph mark called a <b>cell
mark.</b> Following the cell mark that ends the last cell of a table row,
the table row is terminated by a special paragraph mark called a <b>row
mark</b>. When Word displays a table row, it assigns a rectangular shaped
display area to each cell in the row. All of the cell display area?s top?s
are aligned at the same vertical position on a page. The leftmost display
area in a table row is assigned to the 0th cell of the row; the next display
area to the right is assigned to the 1st cell of the row, etc. The text
of the cell is wrapped to fit its display area.As more text is added to
the cell, the cell display area extends downward. A set of table properties
that determine how many cells are in a row, where the horizontal boundaries
of cell display areas are, and what borders are drawn around each cell
in the table is stored for the <b>row mark</b> that marks the end of the
table row.</div>

<h2>
TAP&nbsp; (TAble Properties)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The data structure
which describes the properties of a single table row. The information in
the <b>TAP</b> for a table row is stored in a Word file as a list of sprms
that modify a <b>TAP </b>which has been cleared to zeros. This list of
table sprms is appended to the <b>grpprl</b> of paragraph sprms that is
recorded in the <b>PAPX</b> for the <b>row mark</b> that delimits the end
of a <b>table row</b>.</div>

<h2>
STSH&nbsp; (STyle SHeet)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A data structure
which represents every style defined within the Word document. The <b>STSH</b>
records a unique name string for every style and associates each name with
a particular <b>CHP</b> and/or a <b>PAP. </b>The indexes used to refer
to individual styles are called <b>ISTD</b>s (<b>I</b>ndexesto<b> ST</b>yle<b>
D</b>escriptors). Every <b>PAPX </b>for every paragraph recorded in a documentcontains
an <b>ISTD</b>which identifies the style from which a paragraph inherited
its default character and paragraph properties. <b>CHPX</b>s recorded for
the text within the paragraph and <b>PAPX</b>s recorded for the paragraph
itself encode changes that the user has made with respect to the style?s
default properties.</div>

<h2>
FKP&nbsp; (Formatted disK&nbsp; Page)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A data structure
that fits in one 512-byte page that encodes either the character properties
or the paragraph properties of a certain portion of a Microsoft Word file.
An <b>FKP </b>consists of four components:</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">1) a count of
the number of runs or paragraphs described by the page.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">2) an array of
<b>FC</b>s
recorded in ascending order demarcating the boundaries between runs or
paragraphs that are recorded adjacent to one another in the Word file.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">3) In <b>character
FKP</b>s an array of offsets within the <b>FKP </b>in one to one correspondence
with the array of <b>FC</b>s that locate the properties of the run that
begins at a particular <b>FC.</b></div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">In <b>paragraph
FKP</b>s an array of <b>BX </b>structures follows the array of <b>FC</b>s
in one to one correspondence with the array of <b>FC</b>s. Each <b>BX</b>
begins with an offset that locates the properties of the paragraph that
begins at a particular FC. The remainder of the <b>BX</b> contains a
<b>PHE
</b>structure
that encodes information about the height of the paragraph that begins
at that <b>FC</b>.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">4) a group of
<b>CHPX</b>s
if the <b>FKP</b> stores character properties or a group of
<b>PAPX</b>s
if the <b>FKP</b> stores paragraphand table properties.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">To find the <b>CHPX</b>/<b>PAPX</b>
corresponding to a particular character in a document, calculate the <b>FC</b>
coordinate for that character. Then search through the <b>bin table</b>
(see next entry)for the type of property you want to produce, to find the
<b>FKP</b>
in the document stream whose array of <b>FC</b>s encompasses the <b>FC</b>
of the documentcharacter.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">Then search within
the <b>FKP</b> to find the index of the largest <b>FC
</b>entry that is
less than or equal to the <b>FC</b> of the document character. Use this
index to look up an offset in the array of offsets (for <b>character FKPs</b>)
or look up an offset in the array of <b>Bx</b>s (for <b>paragraph FKPs</b>)
within the <b>FKP</b>. Add this offset to the beginning address of the
<b>FKP
</b>in
memory. This will be the first byte of the desired <b>CHPX</b>/<b>PAPX.</b></div>

<h2>
bin table</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">Each <b>FKP</b>
can be viewed as bucket or <b>bin</b> that contains the properties of a
certain range of <b>FC</b>s in the Word file. In Word files, a <b>PLC</b>
,the <b>plcfbte </b>(<b>PL</b>ex of F<b>C</b>s containing <b>B</b>in <b>T</b>
able <b>E</b>ntries) is maintained. Itrecords the association between a
particular range of <b>FC</b>s and the <b>PN </b>(<b>P</b>age <b>N</b>umber)
of the <b>FKP </b>that contains the properties for that <b>FC</b> range
in the file. In a <b>complex (fast-saved)</b> Word document,<b>FKP </b>pages
are intermingled with pages of textin a random pattern which reflects the
history of past fast saves. In a complex document, a <b>plcfbteChpx</b>
which records the location of every <b>CHPX FKP</b> must be stored and
a <b>plcfbtePapx</b> which records the location of every <b>PAPX FKP </b>must
be stored<b>. </b>In a <b>non-complex, full-saved</b> document, all of
the <b>CHPX FKPS </b>are recorded in consecutive 512-byte pages with the
<b>FKP</b>s
recorded in ascending <b>FC </b>order, as are all of the <b>PAPX FKPS</b>.In
a non-complex document, at least the first <b>FKP</b> page number will
be recorded so that the beginning of the consecutive range of pages may
be located. However, the bin table may be incomplete because of resource
constraints placed on Word's save procedures.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">If a <b>plcfbte</b>
is incomplete, the page numbers of the first <b>n FKP</b> s will be recorded
but the last <b>mFKPs </b>would not be represented. The complete <b>plcfbte</b>
may be reconstructed by the reader because the total number of <b>CHPXFKPs
</b>and<b>
PAPX FKPs</b> is recorded in the <b>FIB.
</b>Whena reader notices that
the number of entries in a <b>plcfbte</b> is less than the number of FKP
pages that was recorded in the <b>FIB</b>, the reader must locate the last
PN recorded in the <b>plcfbte</b>, call it pnLast. If the number of missing
page entries is <b>m</b>, the reader would have to read pages pnLast+1
through pnLast+m and record the first <b>fc</b> stored in each of the tables
plus the last <b>fc </b>of page pnLast+1 to produce a complete
<b>plcfbte</b>.</div>

<h2>
SEP (SEction Properties)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The data structure
describing the properties of a particular section.</div>

<h2>
SEPX (SEction Property EXceptions)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A data structure
describing how the properties of a particular section differ from a Word-defined
standard <b>SEP</b>. As in the <b>PAPX</b>, the differences between the
<b>SEP</b>
for a section and the standard <b>SEP</b> are encoded as list of sprms
that describe how the standard <b>SEP</b> can be transformed into the section's
<b>SEP</b>.By
applying a <b>SEPX</b>'s sprms to the standard <b>SEP</b>, it is possible
to reconstitute the <b>SEP</b> for that section.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The <b>PLCFSED</b>,
a data structure stored in a Word file,<b> </b>records the locations of
all <b>SEPX</b>s stored in a Word file. The array of <b>CP</b>s in the
<b>plcfsed</b>
records the boundaries of sections in the Word document . The second array
in the <b>plcf</b>,an array of <b>SED</b>s (<b> SE</b>ction
<b>D</b>escriptors),
is in 1-to-1 correspondence to the array of <b>CP</b>s. Each <b>SED </b>stores
the beginning <b>FC</b> of the <b>SEPX
</b>that records the properties
for a section. If the <b>FC</b> stored in a <b>SED
</b>is -1, the section
properties of the section are exactly equal to the standard section properties.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The <b>SEP</b>
for a particular section may be constructed if a CP of a character in that
section is known. First search the array of <b>CP</b>s in the <b>PLCSED</b>
for the index of the largest <b>CP</b> that is less than or equal to the
<b>CP</b>
of the character. Use this index to locate the <b>SED</b> in the plcfsed
which describes the section. The <b>FC</b> stored in the
<b>SED
</b>is
the offset from the beginning of the Word file at which the
<b>SEPX</b>
is stored. If the stored <b>FC</b> is equal to 0xFFFFFFFF, then the <b>SEP</b>
for the section is exactly equal to the standard SEP (see SEP structure
definition)Otherwise, read the <b>SEPX </b>into memory and create a copy
of the standard <b>SEP</b> . Finally, apply the <b>sprms</b> stored in
the <b>SEPX</b> to the standard
<b>SEP </b>to produce the <b>SEP </b>for
a section.</div>

<h2>
DOP (DOcument Properties)</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">The data structure
describing properties that apply to the document as a whole.</div>

<h2>
sub-document</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A separate logical
stream of text with properties for which correspondences with the main
document text are maintained. Word's headers/footers, footnotes, endnotes,macro
procedure text, annotation text, and text within textboxes are kept in
separate subdocuments. Each subdocument has its own CP coordinate space.
In other words, data structures are stored in Word files that are components
of these subdocuments. These data structures contain CP coordinates whose
0 point is the beginning of the subdocument text stream instead of the
beginning of the main document text stream.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">In<b>full-saved
documents</b>, a simple calculation with values stored in the <b>FIB </b>producesthe
file offset of the beginning of the subdocument text streams (if they exist).
The length of these streams is also stored.</div>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">In <b>fast-saved
documents</b>, the <b>piece tables</b> of subdocuments are concatenated
to the end of the main document piece table. In this case, to identify
the beginning of subdocument text , you must sum the length of the main
document text stream with the lengths of any subdocument text streams stored
ahead of the subdocument (information stored in the <b>FIB</b>) and treat
this sum as a <b>CP</b> coordinate. To retrieve the text of the subdocument,
you must do lookups in the piece table, starting with the piece that contains
the beginning <b>CP</b> coordinate, to find the physical location of each
piece of the subdocument text stream.</div>

<h2>
field</h2>

<div class="defnbody">A field is a two-part structure that may be recorded
in the CP stream of a document. The first part of the structure contains
<b>field
codes</b> which instruct Window's Word to insert text into the second part
of the structure, the <b>field result</b>. Fields in Window's Word are
used to insert text from an external file or to quote another part of a
document, to mark index and table of contents entries and produce indexes
and tables of contents, maintain DDE links to other programs, to produce
dates, times,page numbers, sequence numbers, etc. There are 84 different
field types.</div>

<div class="defnbody">A <b>field begin mark</b> delimits the beginning
of a field and precedes any of the field codes stored in the field. The
end of the field codes and the beginning of the field result is marked
with the
<b>field separator</b> and the field result and the field itself
are terminated by a <b>field end mark.</b></div>

<div class="defnbody">The CP locations of the field begin mark, field separator,
and field end mark are recorded in <b>plcfld</b> data structures that are
maintained for the main document and all of the subdocuments of the main
document whenever a field is inserted or edited. An array of two-byte <b>FLD</b>
structures is stored in the <b>plcfld</b> in one-to-one correspondence
with the CP entries recorded. An <b>FLD</b> associated with a <b>field
begin mark</b> records the type of the field. An <b>FLD</b> associated
with the <b>field end mark</b> records the current status of the field
(ie. whether the result is dirty or has been edited, whether the result
has been locked, etc.)</div>

<div class="defnbody">Fields may be nested. 20 levels of nesting are permitted.</div>

<h2>
bookmark</h2>

<div class="defnbody">A <b>bookmark</b> associates a user definable name
with a range of text within a document. A bookmark is frequently used as
an operand in <b>field code</b> instructions within a field. In Window's
Word a bookmark is represented by three parallel data structures, the <b>sttbBkmk</b>,
the
<b>plcbkf</b> and the <b>plcbkl</b>. The <b>sttbBkmk </b>is a string
table which contains the name of each bookmark that is defined. The <b>plcbkf</b>
records the beginning CP position of each bookmark. The <b>plcbkl </b>records
the limit CP position that delimits the end of a bookmark. Since bookmarks
may be nested within one another to any level, the <b>BKF</b> structure
stored in the <b>plcbkf</b> consists of a single index which specifies
which <b>plcbkl </b>marks the end of the bookmark. Similarly, the <b>BKL</b>
structure stored in the <b>plcbkl</b> consists of a single index which
specifies which
<b>plcbkf </b>marks the beginning of the bookmark.</div>

<h2>
picture</h2>

<div class="defnbody" style="defnbodymargin-left: 0pt; ">A picture is represented
in the document text stream as a special character, an ASCII 1 whose CHP
has the fSpec bit set to 1. The file location of the picture in the Word
binary file is stored in the character?s CHP in chp.fcPic. For Windows
Word, a picture may be a Window's metafile, a bitmap or a reference to
a TIFF file<b>. </b>Beginning at the position recorded in chp.fcPic, a
header data structure, the PIC, will be stored. If the picture is a Window's
metafile or a bitmap, the metafile or bitmap will immediately follow the
PIC. If the picture is a TIFF file, the filename of the TIFF file will
be recorded immediately following the PIC.</div>

<h2>
embedded object</h2>

<div class="defnbody">The native data for Embedded objects (OBJs) is stored
similarly to pictures (PICs).To locate the native data for Embedded objects,
scan the plc of field codes for the mother, header, footnote and annotation,
textbox and header textbox documents (fib.PlcffldMom/Hdr/Ftn/Atn/Txbx/HdrTxbx).For
each separator field, get the chp.If chp.fSpec=1 and chp.fObj=1, then this
seperator field has an associated embedded object. The file location of
the object data is stored in chp.fcObj.At the specified location an object
header is stored followed by the native data for the object. See the _OBJHEADER
structure.</div>

<h2>
drawing object</h2>

<div class="defnbody"><b>REVIEW</b> Dave</div>

<div class="defnbody">A drawing object is represented in the document stream
as a special character, an ASCII 8, which has chp.fSpec set to 1 for the
run of text containing the character . Only main documents and header documents
contain drawing objects.The native data for the drawing object my be obtained
by taking the CP for the special character and using this to find the corresponding
entry in the <b>plcfdoa</b> .An entry in this plc consists of an FC pointing
to the <b>DO</b> structure and a <b>ctxbx</b>, which is the count of text
boxes in the drawing object.Text for the textboxes is stored separately
in the textbox subdocument of the main or header document.The textbox subdocument
contains a <b>plctxbx</b> where the text from CP n to CP n+1 in the subdocument
is the text which is contained in the n<sup>th</sup> textbox of the superior
document.Ordering of textboxes is based upon CP order of the <b>DOs</b>
in the superior document, and order of the textboxes within the <b>DO</b>
itself.For example, if a document contains 1 <b>DO</b> at CP 500 which
contains 3 textboxes and a <b>DO</b> at CP 600 which contains 10 textboxes,
then the text for the 4th textbox in the second <b>DO</b> would be stored
at the CP specified by the 6th entry in the <b>plctxbx</b>.</div>
<b>Note:In this document, bit 0 is the low-order bit. Structures are described
as they would be declared in C for the Intel architecture. When numbering
bytes in a word from low offset towards high offset, two-byte integers
will have their least significant eight bits stored in byte 0 and most
significant eight bits in byte 1. If bit 31 is the most significant bit
in a four-byte integer, bits 31 through 24 will be stored in byte 3 of
a four-byte integer, bits 23 through 16 will be stored in byte 2, bits
15 through 8 will be stored in byte 1, and bits 7 through 0 will be stored
in byte 0.</b>
<h1>
NAMING CONVENTIONS</h1>
The names in Word data structures usually consist of a lower case sequence
of characters followed by an optional upper case modifier. The following
tags are used in the lower case parts of field names to document the data
type of a field:
<p>f used to name a flag (a variable containing a Boolean value). Usually
the object referred to will contain either 1 (<i>fTrue</i>, <i>TRUE</i>)
or 0 (<i>fFalse</i>, <i>FALSE</i>). (eg. fWidowControl, fShadow)
<p>l used to name a4 byte integer value ( a long). (eg. lcb)
<p>w used to name a 2 byte integer value (a short ).
<p>b used to name a 1 byte integer value
<p>cp used to name a variable that contains a character position within
the document. always a 4 byte quantity.
<p>fc used to name a variable that contains an offset from the beginning
of a file. always a 4 byte quantity.
<p>xa used to name a variable that contains a width of an objectimaged
on screen or on hard copy that is measured in units of 1/1440 of an inch.
This unit which is one-twentieth of a point size (1/20 * 1/72?) is called
a <b>twip</b> in this documentation. (eg. xaPage is the width of a page).
<p>ya used to name a variable that contains a height of an object imaged
on screen or on hard copy that is measured in twips.
<p>dxa used to name a variable that contains the horizontal distance of
an object measured from some reference point expressed in twips. (eg. pap.dxaLeft
is the distance of the left boundary of a paragraph measured from the left
margin of the page)
<p>dya used to name a variable that contains the vertical distance of an
object measured from some reference point expressed in twips. (eg. pap.dyaAbs
is the vertical distance of the top of a paragraph from a reference frame
declared in the pap).
<p>dxp used to name a variable that contains the horizontal distance of
an object measured from some reference point expressed in Macintosh pixel
units (1/72?). (eg. dxpSpace)
<p>dyp used to name a variable that contains the vertical distance of an
object measured from some reference point expressed in Macintosh pixel
units (1/72?).
<p>rg prefix used to signify that the data structure being defined is an
array. (eg.rgb (an array of bytes), rgcp (an array of cps), rgfc (an array
of fcs), rgfoo (an array of foos).
<p>i prefix used to signify that an integer value is used as an index into
an array. (eg. itbd is an index into rgtbd, itc is an index into rgtc.)
<p>c prefix used to signify that an integer value is a count of some number
of objects. (eg. a cb is a count of bytes, a cl is a count of lines, ccol
is a count of columns, a cpe.is a count of picture elements.)
<p>grp prefix used to name an array of bytes that contains one or more
copies of a variable length data structure with the instances of the data
structure stored one after the other in the array. (eg. a grpprl is a array
of bytes that stores a group of prls.)
<p>grpf prefix used to name an integer or byte value whose bits are used
as flags. (eg. grpfIhdt is a group of flags that records the types of headers
that are stored for a particular section of a document).
<p>The two following modifiers are used occasionally in this documentation:
<p>First means that variable marks the first of a range of objects. For
example, cpFirst would mark the first character position of a range of
characters in a document. fcFirst would mark the file offset of the first
byte of a range of bytes stored in a file.
<p>Lim means the variable marks the limit of a range of objects (ie. is
the index of the last object in a range plus 1). For example, cpLim would
be the limit CP of a range of characters in a document. fcLim would be
the limit file offset of a range of bytes stored in a file.
<h1>
WORD AND DOCFILES</h1>
Word 6.0 is an OLE 2.0 application.A Word binary file is a docfile and
Word binary data is written into streams within the docfile using the OLE
2.0 docfile APIs. To access data within a Word binary file, the file must
be opened using the OLE 2.0 docfile APIs.
<p>A word docfile consists of a main stream, a summary information stream,&nbsp;
and 0 or more object streams which contain private data for OLE 2.0 objects&nbsp;
embedded within the Word document. The summary information stream is described
in the section immediately following&nbsp; this one.The object streams
contain binary data for embedded objects.Word&nbsp; has no knowledge of
the contents of these streams; this information is accessed and manipulated
though the OLE 2.0 APIs.The main stream of the Word docfile contains all
other binary data.The majority of this document describes the contents
of the main stream.
<h1>
FORMAT OF THE SUMMARY INFO STREAM IN A WORD FILE</h1>
Summary information is stored with the stream named ?SummaryInformation?.This
summary information consists of the following elements:
<h1>
FORMAT OF THE MAIN STREAM IN A WORD NON-COMPLEX FILE</h1>
The main stream of a Word docfile (non-complex format) consists of the
Word file header (FIB), the text, and the formatting information.
<p><b>FIB</b>
<p>Stored at beginning of page 0 of the file. fib.fComplex will be set
to zero.
<p><b>text of body, footnotes, headers</b>
<p>Text begins at the position recorded in fib.fcMin.
<p><b>group of SEPXs</b>
<p>SEPXs immediately follow the text and are concatenated one after the
other. A SEPX may not span a 512-byte page boundary. If a SEPX will not
fit in the space that remains in a page from recording previous text or
SEPXs, space is skipped to allow the SEPX to start on a page boundary.
A SEPX is guaranteed to be less than 512 bytes in length. If all sections
in the document have default properties, no SEPXs would be stored.
<p><b>pictures</b>
<p>Word picture structures immediately follow the preceding text/SEPXs
and are concatenated one after the other if the document contains pictures.
<p><b>embedded objects-native data</b>
<p>Word embedded object structures immediately follow the preceding text/SEPXs/picture
and are concatenated one after the other if the document contains embedded
objects.
<p><b>FKPs for CHPs</b>
<p>The first CHP FKP begins at the first 512-byte boundary after the last
byte of text\SEPX\picture\embedded objectswritten. The remaining CHP FKPs
are recorded in the 512-byte pages that immediately follow.
<p><b>FKPs for PAPs</b>
<p>The first PAP FKP is written in the 512-byte page that immediately follows
the page used to record the last CHP FKP. The remaining PAP FKPs are recorded
in the 512-byte pages that follow.
<p><b>stsh </b>(style sheet)
<p>The style sheet is written at the beginning ofthe 512-byte page that
immediately follows the last PAP FKP. This is recorded in all Windows Word
documents.
<p><b>plcffndRef </b>(footnote reference position table)
<p>Written immediately after the <b>stsh</b> if the document contains footnotes.
<p><b>plcffndTxt</b> (footnote text position table)
<p>Written immediately after the <b>plcffndRef</b>.if the document contains
footnotes.
<p><b>plcfandRef </b>(annotation reference position table)
<p>Written immediately after the <b>plcffndTxt</b> if the document contains
annotations.
<p><b>plcfandTxt</b> (annotation text position table)
<p>Written immediately after the <b>plcfandRef</b>.if the document contains
footnotes.
<p><b>plcfsed</b> (section table)
<p>Written immediately after the previously recorded table. Recorded in
all Windows Word documents.
<p><b>plcfphe </b>(paragraph height table)
<p>Written immediately after the <b>plcfsed</b>, if paragraph heights have
beenrecorded.
<p><b>plcfpgd </b>(page table)
<p>Written immediately after the previously recorded table, if page boundary
information is recorded.
<p><b>sttbGlsy </b>(glossary name string table)
<p>Written immediately after the previously recorded table, if the document
stored is a glossary.
<p><b>plcfglsy </b>(glossary entry text position table)
<p>Written immediately after the <b>sttbGlsy</b>, if the document stored
is a glossary.
<p><b>plcfhdd </b>(header text position table)
<p>Written immediately after the previously recorded table, if the documentcontains
headers or footers.
<p><b>plcfbteChpx </b>(bin table for CHP FKPs)
<p>Written immediately after the previously recorded table. This is recorded
in all Windows Word documents.
<p><b>plcfbtePapx </b>(bin table for PAP FKPs)
<p>Written immediately after the <b>plcfbteChpx</b>. This is recorded in
all Windows Word documents.
<p><b>sttbfFn</b>(table of font name strings)
<p>Written immediately after the <b>plcfbtePapx</b>. This is recorded in
all Windows Word documents.The names of the fonts correspond to the ftc
codes in the CHP structure.For example, the first font name listed corresponds
is the name for ftc = 0<a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a NAME="_ftnref1" href="#_ftn1" style="mso-footnote-id:ftn1" title=""></a><a href="#_ftn1" style="mso-footnote-id:ftn1" name="_ftnref1" title="">[1]</a>.
<p><b>plcffldMom</b>(table of field positions and statuses for main document)
<p>Written immediately after the <b>sttbfFn</b> if the main document contains
fields.
<p><b>plcffldHdr</b>(table of field positions and statuses for headersubdocument)
<p>Written immediately after the previously recorded table, if the header
subdocument contains fields.
<p><b>plcffldFtn</b>(table of field positions and statuses for footnote
subdocument)
<p>Written immediately after the previously recorded table, if the footnote
subdocument contains fields.
<p><b>plcffldAtn</b>(table of field positions and statuses for annotation
subdocument)
<p>Written immediately after the previously recorded table, if the annotation
subdocument contains fields.
<p><b>plcffldMcr</b>(table of field positions and statuses for macro subdocument)
<p>Written immediately after the previously recorded table, if the macro
subdocument contains fields.
<p><b>sttbfBkmk</b>(table of bookmark name strings)
<p>Written immediately after the previously recorded table, if the document
contains bookmarks.
<p><b>plcfBkmkf</b>(table recording beginning CPs of bookmarks)
<p>Written immediately after the <b>sttbfBkmk</b>, if the document contains
bookmarks.
<p><b>plcfBkmkl</b>(table recording limit CPs of bookmarks)
<p>Written immediately after the <b>plcfBkmkf</b>, if the document contains
bookmarks.
<p><b>cmds </b>(recording of command data structures)
<p>Written immediately after the previously recorded table, if special
commands are linked to this document.
<p><b>plcfmcr </b>(macro text position table -- delimits boundaries of
text for macros stored in macro subdocument)
<p>Written immediately after the previously recorded table, if a macro
subdocument is recorded.
<p><b>sttbfMcr </b>(table of macro name strings)
<p>Written immediately after the <b>plcfmcr</b>, if a macro subdocument
is recorded.
<p><b>PrEnv </b>(data structures recording the print environment for document)
<p>Written immediately after the previously recorded table, if a print
environment is recorded for the document.
<p><b>wss </b>(window state structure)
<p>Written immediately after the end of previously recorded structure,
if the document was saved while a window was open.
<p><b>dop </b>(document properties record)
<p>Written immediately after the end of previously recorded structure..
This is recorded in all Windows Word documents.
<p><b>sttbfAssoc</b> (table of associated strings)
<p><b>Autosave source</b>(name of original)
<p>Written immediately after the sttbfAssoc table.This field only appears
in autosave files.These files are normal Word for Windows document in every
other way.Also, autosaved files are typically in the complex file format
except thatwe don't overwrite the tables (plcf*, etc.).I.e., an autosaved
file is typically longer than the equivalent Word for Windows documen
<h1>
FORMAT OF THE MAIN STREAM IN A COMPLEX FILE</h1>
The main stream of a Word binary file (complex format) consists of the
Word file header (FIB), the text, and the formatting information.
<p><b>FIB</b>
<p><b>Text of body, footnotes, headers stored during last full save</b>
<p>Text begins at the position recorded in fib.fcMin.
<p><b>Group of SEPXs stored during last full save</b>
<p><b>Pictures stored during last full save</b>
<p><b>Embedded Ojbects stored during last full save</b>
<p><b>Drawing Objects stored during last full save</b>
<p><b>FKPs for CHPs during last full save</b>
<p>The first CHP FKP begins at the first 512-byte boundary after the last
byte of text\SEPX\picture\embedded object written. The remaining CHP FKPs
are recorded in the 512-byte pages that immediately follow.
<p><b>FKPs for PAPs during last full save</b>
<p>The first PAP FKP is written in the 512-byte page that immediately follows
the page used to record the last CHP FKP. The remaining PAP FKPs are recorded
in the 512-byte pages that follow.
<p><b>STSH </b>(if style sheet has not grown since last full save)
<p><b>Any text, SEPXs, pictures, embedded objects, or drawing objects stored
during first fast save</b>
<p><b>Any CHP FKPs stored during first fast save</b>
<p><b>Any PAP FKPs stored during first fast save</b>
<p><b>Any text, SEPXs,pictures, embedded objects, or drawing objects stored
during second fast save</b>
<p><b>Any CHP FKPs stored during second fast save</b>
<p><b>Any PAP FKPs stored during second fast save</b>
<p><b>...</b>
<p><b>Any text, SEPXs, pictures, embedded objects, or drawing objects stored
during nth fast save</b>
<p><b>Any CHP FKPs stored during nth fast save</b>
<p><b>Any PAP FKPs stored during nth fast save</b>
<p><b>stsh </b>(if style sheet has grown since last full save)
<p><b>plcffndRef </b>(footnote reference position table)
<p>Written immediately after the <b>stsh</b> if the document contains footnotes.
<p><b>plcffndTxt</b> (footnote text position table)
<p>Written immediately after the <b>plcffndRef</b>.if the document contains
footnotes.
<p><b>plcfandRef </b>(annotation reference position table)
<p>Written immediately after the <b>plcffndTxt</b> if the document contains
annotations.
<p><b>plcfandTxt</b> (annotation text position table)
<p>Written immediately after the <b>plcfandRef</b>.if the document contains
footnotes.
<p><b>plcfsed</b> (section table)
<p>Written immediately after the previously recorded table. Recorded in
all Windows Word documents.
<p><b>plcfphe </b>(paragraph height table)
<p>Written immediately after the <b>plcfsed</b>, if paragraph heights have
beenrecorded.
<p><b>plcfpgd </b>(page table)
<p>Written immediately after the previously recorded table, if page boundary
information is recorded.
<p><b>sttbGlsy </b>(glossary name string table)
<p>Written immediately after the previously recorded table, if the document
stored is a glossary.
<p><b>plcfglsy </b>(glossary entry text position table)
<p>Written immediately after the <b>sttbGlsy</b>, if the document stored
is a glossary.
<p><b>plcfhdd </b>(header text position table)
<p>Written immediately after the previously recorded table, if the documentcontains
headers or footers.
<p><b>plcfbteChpx </b>(bin table for CHP FKPs)
<p>Written immediately after the previously recorded table. This is recorded
in all Windows Word documents.
<p><b>plcfbtePapx </b>(bin table for PAP FKPs)
<p>Written immediately after the <b>plcfbteChpx</b>. This is recorded in
all Windows Word documents.
<p><b>sttbfFn</b> (table of font name strings)
<p>Written immediately after the <b>plcfbtePapx</b>. This is recorded in
all Windows Word documents.The names of the fonts correspond to the ftc
codes in the CHP structure.For example, the first font name listed corresponds
is the name for ftc = 0&nbsp;<a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a NAME="_ftnref2" href="#_ftn2" style="mso-footnote-id:ftn2" title=""></a><a href="#_ftn2" style="mso-footnote-id:ftn2" name="_ftnref2" title="">[1]</a>
.
<p><b>sttbRMark </b>(table of Author names for Revision Marking)
<p>Written immediately after the <b>plcfbtePapx </b>if revision marking
is being tracked in the document.(<b>REVIEW</b> davidlu Each record in
the sttb stores a 2-byte length extra portion, which contains undefined
data.David, no definition of an sttb is given in this document, thus no
definition of ?extra? data in an sttb is given.)
<p><b>plcffldMom</b>(table of field positions and statuses for main document)
<p>Written immediately after the <b>sttbfFn</b> if the main document contains
fields.
<p><b>plcffldHdr</b>(table of field positions and statuses for headersubdocument)
<p>Written immediately after the previously recorded table, if the header
subdocument contains fields.
<p><b>plcffldFtn</b>(table of field positions and statuses for fotnote
subdocument)
<p>Written immediately after the previously recorded table, if the footnote
subdocument contains fields.
<p><b>plcffldAtn</b>(table of field positions and statuses for annotation
subdocument)
<p>Written immediately after the previously recorded table, if the annotation
subdocument contains fields.
<p><b>plcffldMcr</b>(table of field positions and statuses for macro subdocument)
<p>Written immediately after the previously recorded table, if the macro
subdocument contains fields.
<p><b>sttbfBkmk</b>(table of bookmark name strings)
<p>Written immediately after the previously recorded table, if the document
contains bookmarks.
<p><b>plcfBkmkf</b>(table recording beginning CPs of bookmarks)
<p>Written immediately after the <b>sttbfBkmk</b>, if the document contains
bookmarks.
<p><b>plcfBkmkl</b>(table recording limit CPs of bookmarks)
<p>Written immediately after the <b>plcfBkmkf</b>, if the document contains
bookmarks.
<p><b>cmds </b>(recording of command data structures)
<p>Written immediately after the previously recorded table, if special
commands are linked to this document.
<p><b>plcfmcr </b>(macro text position table -- delimits boundaries of
text for macros stored in macro subdocument)
<p>Written immediately after the previously recorded table, if a macro
subdocument is recorded.
<p><b>sttbfMcr </b>(table of macro name strings)
<p>Written immediately after the <b>plcfmcr</b>, if a macro subdocument
is recorded.
<p><b>PrEnv </b>(data structures recording the print environment for document)
<p>Written immediately after the previously recorded table, if a print
environment is recorded for the document.
<p><b>wss </b>(window state structure)
<p>Written immediately after the end of previously recorded structure,
if the document was saved while a window was open.
<p><b>pms </b>(print/mail merge state information structure)
<p>Written immediately after the end of previously recorded structure,
(<b> REVIEW</b> davidlu;stevebu;jayb)
<p><b>sttbEmbeddedFonts </b>(table of font name strings for Embedded True
Type Fonts stored in the file)
<p>Written immediately after the end of the previously recorded structure,
if Embedded True Type Fonts were stored in the document when it was saved.
<p><b>rgfcEmbeddedFonts </b>(array of FCs bounding the Embedded font data)
<p>Written immediately after the end of the <b>sttbEmbeddedFonts</b>, if
the file contains an <b>sttbEmbeddedFonts</b>. The binary data for the
embedded font corresponding to font n in <b>sttbEmbeddedFonts</b> is stored
in the main stream at file position rgfc[n], and has a length of rgfc[n+1]
- rgfc[n].
<p><b>Clx </b>(encoding of the sprm lists and piece table for a complex
file)
<p>Written immediately after the end of previously recorded structure.
This is recorded in all complex Windows Word documents.
<p><b>dop </b>(document properties record)
<p>Written immediately after the end of previously recorded structure..
This is recorded in all Windows Word documents.
<p><b>sttbfAssoc</b> (table of associated strings)
<p><b>Autosave source </b>(documented above)
<a NAME="TocFIB"></a>
<h1>
FIB</h1>
The FIB contains a "magic word" and pointers to the various other parts
of the file, as well as information about the length of the file.The FIB
starts at the beginning of the file and fits within the first page of the
file.The FIB is defined in the structure definition section of this document.
<a NAME="TocTEXT"></a>
<h1>
TEXT</h1>
The text of the file starts at fib.fcMin. fib.fcMin is usually set to the
next 128 byte boundary after the end of the FIB. The text in a Word document
is ASCII text with the following restrictions (ASCII codes given in decimal):
<p>-<b>Paragraph ends</b> are stored as a single &lt;Carriage Return >
character (ASCII 13).No other occurrences of this character sequence are
allowed.
<p>-<b>Hard line breaks</b> which are not paragraph ends are stored as
ASCII 11.Other line break or word wrap information is not stored.
<p>-<b>Breaking hyphens</b> are stored as ASCII 45 (normal hyphen code);
<b>Non-required
hyphens</b> are ASCII 31. <b>Non-breaking hyphens</b> are stored as ASCII
30.
<p>-<b>Non-breaking spaces</b> are stored as 160.Normal <b>spaces</b> are
ASCII 32.
<p>-<b>Page breaks </b>and <b>Sectionmarks </b>are ASCII 12 (normal form
feed); if there's an entry in the section table, it's a section mark, otherwise
it's a page break.
<p>-<b>Column breaks</b> are stored as ASCII 14.
<p>-<b>Tab </b>characters are ASCII 9 (normal).
<p>-The <b>field begin mark</b> which delimits the beginning of a field
is ASCII 19. The <b>field end mark</b> which delimits the end of a field
is ASCII 21. The <b>field separator</b> ,which marks the boundary between
the preceding field code text and following field expansion text within
a field, is ASCII 20. The <b>field escape character</b> is the '\' character
which also serves as the <b>formula mark</b>.
<p>-The <b>cell mark</b> which delimits the end of a cell in a table row
is stored as ASCII 7 and has the fInTable paragraph property set to fTrue
(pap.fInTable == 1).
<p>-The <b>row mark</b> which delimits the end of a table row is stored
as ASCII 7 and has the fInTable paragraph property and fTtp paragraph property
set to fTrue (pap.fInTable == 1 &amp;&amp; pap.fTtp == 1).
<p>The following ASCII codes are treated as "special" characters when they
have the character property <i>special</i> on (chp.fSpec == 1):
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>0</td>

<td>Current page number</td>
</tr>

<tr>
<td>1</td>

<td>Picture</td>
</tr>

<tr>
<td>2</td>

<td>Autonumbered footnote reference.</td>
</tr>

<tr>
<td>3</td>

<td>Footnote separator character</td>
</tr>

<tr>
<td>4</td>

<td>Footnote continuation character</td>
</tr>

<tr>
<td>5</td>

<td>Annotation reference</td>
</tr>

<tr>
<td>6</td>

<td>Line number</td>
</tr>

<tr>
<td>7</td>

<td>Hand Annotation picture (Generated in Pen Windows)</td>
</tr>

<tr>
<td>8</td>

<td>Drawn object</td>
</tr>

<tr>
<td>10</td>

<td>Abbreviated date (eg. ?Wed, Dec 1, 1993?)</td>
</tr>

<tr>
<td>11</td>

<td>Time in hours:minutes:seconds</td>
</tr>

<tr>
<td>12</td>

<td>Current section number</td>
</tr>

<tr>
<td>14</td>

<td>Abbreviated day of week (eg. ?Thu? for ?Thursday?)</td>
</tr>

<tr>
<td>15</td>

<td>Day of week (eg. ?Thursday?)</td>
</tr>

<tr>
<td>16</td>

<td>Day short (eg. ?9? for the ninth day of the month)</td>
</tr>

<tr>
<td>22</td>

<td>Hour of current time with no leading zero</td>
</tr>

<tr>
<td>23</td>

<td>Hour of current time (two digit with leading zero when necessary)</td>
</tr>

<tr>
<td>24</td>

<td>Minute of current time with no leading zero</td>
</tr>

<tr>
<td>25</td>

<td>Minute of current time(two digit with leading zero when necessary)</td>
</tr>

<tr>
<td>26</td>

<td>Seconds of current time</td>
</tr>

<tr>
<td>27</td>

<td>AM/PM for current time&nbsp;</td>
</tr>

<tr>
<td>28</td>

<td>Current time in hours:minutes:seconds in old format</td>
</tr>

<tr>
<td>29</td>

<td>Date M (eg. ?December 2, 1993?)</td>
</tr>

<tr>
<td>30</td>

<td>Short Date (eg. ?12/2/93?)</td>
</tr>

<tr>
<td>33</td>

<td>Short Month (eg. ?12? to represent ?December?)</td>
</tr>

<tr>
<td>34</td>

<td>Long Year (eg. ?1993?)</td>
</tr>

<tr>
<td>35</td>

<td>Short Year (eg. ?93?)</td>
</tr>

<tr>
<td>36</td>

<td>Abbreviated month (eg. ?Dec? to represent ?December?)</td>
</tr>

<tr>
<td>37</td>

<td>Long month (eg. ?December?)</td>
</tr>

<tr>
<td>38</td>

<td>Current time in hours:minutes (eg. ?2:01?)</td>
</tr>

<tr>
<td>39</td>

<td>Long date (eg. ?Thursday, December 2, 1993?)</td>
</tr>

<tr>
<td>41</td>

<td>Print Merge Helper field</td>
</tr>
</table>

<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p>Note:The end of a section is also the end of a paragraph. The last character
of a section is a section mark which stands in place of the paragraph marknormally
required to end a paragraph. An exception is made for the last character
of a document which is always a paragraph mark although the end of a document
is always an implicit end of section.
<p>If !fib.fComplex, thedocument text stream is represented by the text
beginning at fib.fcMin up to (but not including) fib.fcMac. Otherwise,
the document is represented by the piece table stored in the file in the
data beginning at .fib.fcClx.
<p>The document text stream includes text that is part of the main document,
plus any text that exists for the footnote, header, macro, or annotation
subdocuments. The sizes of the main document and the header, footnote,
macro and annotation subdocuments are stored in the fib, in variables fib.ccpText,
fib.ccpFtn, fib.ccpHdr, fib.ccpMcr, fib.ccpEdn, fib.ccpTxbx, fib.ccpHdrTxbox
and fib.ccpAtn respectively. In a non-complex file, this means that the
text of the main document begins atfib.fcMinin the file and continues.through
fib.fcMin + fib.ccpText; that the text of the footnote subdocument begins
at fib.fcMin + fib.ccpText and extends to fib.fcMin + fib.ccpText + fib.ccpFtn;that
the text of the header subdocument begins at fib.fcMin + fib.ccpText +
fib.ccpFtn and extends to fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr;
that the text of the annotation subdocument begins at .fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr and extends to fib.fcMin + fib.ccpText + fib.ccpFtn
+ fib.ccpHdr + ccpAtn;that the text of the endnote subdocument begins at
.fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr +ccpAtn and extends
to fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpEdn; that
the text of the textbox subdocument begins at .fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr +fib.ccpAtn + fib.ccpEdn and extends to fib.fcMin
+ fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpEdn + fib.ccpTxbx andthat
the text of the header textbox subdocument begins at .fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr +fib.ccpAtn + fib.ccpEdn+ fib.ccpTxbxand extends
to fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpEdn + fib.ccpTxbx+
fib.ccpHdrTxbx.
<p>In a complex, fast-saved file, the main document text must be located
by examining the piece table entries from the 0th piece table entry through
the piece table entry that describes cp = fib.ccpText.
<p>A footnote subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText through
the entry that describes cp = fib.ccpText + fib.ccpFtn.
<p>A header subdocument's text must be located by examining the piece table
entries beginning with the one that describes cp=fib.ccpText + ccpFtn through
the entry that describes cp = fib.ccpText +fib.ccpFtn + fib.ccpHdr.
<p>Anannotation subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText + ccpFtn
+ fib.ccpHdr through the entry that describes cp = fib.ccpText +fib.ccpFtn
+ fib.ccpHdr +fib.ccpAtn.
<p>An endnote subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText + ccpFtn
+ fib.ccpHdr + fib.ccpAtn through the entry that describes cp = fib.ccpText
+fib.ccpFtn + fib.ccpHdr +fib.ccpAtn.+ fib.ccpEdn
<p>A textbox subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText + ccpFtn
+ fib.ccpHdr + fib.ccpAtn + fib.ccpEdn through the entry that describes
cp = fib.ccpText +fib.ccpFtn + fib.ccpHdr +fib.ccpAtn.+ fib.ccpEdn + fib.ccpTxbx
<p>A header textbox subdocument's text must be located by examining the
piece table entries beginning with the one that describes cp=fib.ccpText
+ ccpFtn + fib.ccpHdr + fib.ccpAtn + fib.ccpEdn + fib.ccpTxbx through the
entry that describes cp = fib.ccpText +fib.ccpFtn + fib.ccpHdr +fib.ccpAtn.+
fib.ccpEdn + fib.ccpTxbx+ fib.ccpHdrTxbx
<h1>
CHARACTER AND PARAGRAPH FORMATTING PROPERTIES</h1>
Character and paragraph properties in Word documents are stored in a compressed
format. The information that is stored on disk is not the actual properties
of a particular sequence of text but the difference of the properties of
a sequence from some reference property.
<p>The <b>PAP </b>is a data structure that holds uncompressed paragraph
property information; the <b>CHP </b>(pronounced like "chip") is a structure
that holds uncompressed character property information .Each paragraph
in a Word document inherits a default set of paragraph and character properties
from one of the <b>paragraph</b> <b>styles</b> recorded in the style sheet
data structure (<b>STSH</b>).
<p>A particular<b>PAP </b>is converted into its compressed form, the <b>PAPX</b>
, by first comparing the pap for a paragraph with the pap stored in the
style sheet for the paragraph's style. Any properties in the paragraph's
<b>PAP
</b>that
are different from those stored in the style sheet <b>PAP
</b>are encoded
as a list of <b>sprms</b> (<b>grpprl</b>).<b> sprms</b> express how the
content of the style sheet <b>PAP</b> should be transformed to create the
properties for the paragraph. A <b>PAPX</b> is a variable-length data structure
that begins with a count of words that encodes the PAPX length. It contains
a <b>istd </b>(index to style descriptor) which specifies which style entry
in the style sheet contains the default paragraph and character properties
for the paragraph, paragraph height information, and the list of difference
sprms. If the only difference between the paragraph's
<b>PAP
</b>and the
style's <b>PAP</b> were in the justification code field, which is one byte
long, one two-byte sprm, sprmPJc,would be generated to express that difference;
thus the total <b>PAPX</b> size would be 5 bytes. This is better than 54-1
compression since the total size of a <b>PAP </b>is 274 bytes.
<p>To convert a <b>CHP</b> for a sequence of characters contained within
a single paragraph into its compressed form, the <b>CHPX</b>, it's first
necessary to know the <b>paragraph style</b> that is assigned to the paragraph
containing those characters and any character style that may be tagging
the character run. The character properties inherited from the paragraph
style are moved into a buffer. If the chp.istd of the chp to be compressed
is not istdNormalChar, the changes recorded for that character style are
applied to buffer. Thenthe character properties of the character sequence
are compared with the character properties generated usingthe paragraph's
style and the run?s character style. . Any properties in the paragraph's
<b>CHP
</b>that
are different from those stored in the generated CHP are encoded as a list
of <b>sprms</b> (<b>grpprl</b> ).The <b>sprms</b> express how the content
of the CHP generated from the paragraph and character styles should be
transformed to create the character properties for the text run. A <b>CHPX</b>
is a variable-length data structure that begins with a count of words that
encodes the CHPX length followed by the list of difference sprms.
<p>If one of the bit fields in the CHP to be compressed such as fBold is
different from the reference CHP, you would build a difference sprm using
sprmCFBold in the first byte and the bytes pattern 0x81 in the second byte
which signifies that the value of the bit in the CHP to be compressed is
of opposite value from the value stored in the reference CHP. If there
was no difference, sprmCFBold would not be recorded in the grrprl to be
generated. If there were difference in a field larger than a single bit
such as the chp.hps,a sprmCHps would be generated to record the value of
chp.hps in the chp to be compressed. If the chp.hps were equal in both
the chp to be compressed and the reference CHP, sprmCHps would not be recorded
in the grrprl that is generated. If a sequence of characters has the same
character properties and the sequence spans more than one paragraph, it's
necessary to examine each paragraph's properties and to generate a different
<b>CHPX</b>
every time there is a change of style.
<p>In Word documents, the fundamental unit of text for which character
exception information is kept is the <b>run of exception text</b>, a contiguous
sequence of characters stored on disk that all have the same exception
properties with respect to their underlying style character properties.
Each run would have an entry recorded in a <b>CHPX FKP</b>. If a user neverchanged
the character properties inherited from the styles used in his document
and did a complete save of his document, although each of those styles
may have different properties, the entire document stream would be one
large <b>run of exception text</b> and one <b>CHPX </b>would suffice to
describe the character properties of the entire document.
<p>The fundamental unit of text for which paragraph properties are recorded
is the <b>paragraph</b>. Every paragraphhas an entry recorded in a <b>PAPX
FKP.</b>
<p>The<b> CHPX FKP</b> and the <b>PAPX FKP</b> have similarphysical structures.
An <b>FKP </b>is a 512-byte data structure that is stored in one page of
a Word file. At offset511 is a 1-byte count named <b>crun</b>, which is
a count of runs of exception text for <b>CHPX FKP</b>s and which is a count
of paragraphs in <b>PAPX FKP</b>s. Beginning at offset 0 of the <b>FKP</b>
is an array of <b>crun+1 FC</b>s, named <b>rgfc</b>, which records the
beginning and limit <b>FC</b>s of <b>crun</b> runs of exception text or
paragraphs.
<p>For CHPX FKPs, immediately following fkp.<b>rgfc </b>is a byte array
of
<b>crun </b>word offsets to <b>CHPX</b>s from the beginning of the <b>FKP.
</b>This
byte array, named <b>rgb</b>,is in 1-to-1 correspondence with the
<b>rgfc</b>.
The <b>ith</b> <b>rgb </b>gives the word offset of the exception property
that belongs to the run\paragraph whose beginning
<p>For <b>PAPX FKPSs</b>, immediately following the <b>fkp.rgfc</b> is
an array of 7 byte entries called <b>BXs</b>. This array called the <b>rgbx</b>
is in 1-to-1 correspondence with the <b>rgfc</b>. The first byte of the
<b>ith
BX</b> entry contains a single byte field which gives the word offset of
the <b>PAPX</b> that belongs to the paragraph whose beginning in <b>FC</b>
space is <b>rgfc</b>[i] and whose limit is <b>rgfc[i+1]</b> in <b>FC</b>
space. The last six bytes of the<b> ith BX</b> entry contain a <b>PHE</b>
structure that stores the current paragraph height of the paragraph whose
beginning in <b>FC</b> space is <b>rgfc</b>[i] and whose limitis <b>rgfc[i+1]</b>
in <b>FC</b> space.
<p>The fact that the offset to propertystored in the <b>rgb </b>or <b>rgbx
</b>is
a word offset implies that<b>CHPX</b>s and <b>PAPX</b>s are stored in <b>FKP</b>s
beginning on word boundaries. Since the values stored in the
<b>rgb/rgbx</b>
allow random access throughout the <b>FKP,</b> space within an <b>FKP </b>can
be conserved by storing the offset of the same physical
<b>CHPX/PAPX</b>
in <b>rgb/rgbx </b>entries when severalruns or paragraphs in the FKP have
the same properties. Word uses this optimization.
<p>An <b>rgb or rgbx[].b </b>value of 0 is used in another optimization.
When a <b>rgb</b> or <b>rgbx[].b</b> value of 0 is stored in an <b>FKP,</b>
it means that instead of referring to a particular CHPX/PAPX in the FKP
the 0 value is a signal thatthe reader should constructfor itself a commonly
encountered predefined set of properties.
<p>For <b>CHPX FKP</b>s a 0 <b>rgb</b> value means that the properties
of the run of text were exactly equal to the character properties inherited
from the style of the paragraph it was in. For <b>PAPX FKP</b>s, a 0 <b>rgbx[].b
</b>valuemeans
that the paragraph?s properties were exactly equal to the paragraph properties
of the Normal style (stc == 0) and the paragraph contained 1 line of 240
pixels, with acolumn width of 7980 dxas.
<p>Whennew entries are added to an <b>FKP</b>, there must be unallocated
space in the middle of the <b>FKP</b> equal to 5 bytes for CHPXs (size
of an <b>FC</b> plus size of one-byte word offset) or 11 bytes for PAPXs
(size of an <b>FC</b> plus the size of a seven byte BX entry), plus the
size of the new <b>CHPX</b> or <b>PAPX</b> if the property being added
is not already recorded in the <b>FKP</b> and is not the property coded
with a 0 <b>rgb/rgbx[].b
</b>value. To add a new property in a CHPX FKP,
existing <b>rgb </b>entries are moved four bytes to the right in the <b>FKP</b>.
. To add a new property in a PAPX FKP, existing <b>rgbx </b>entries are
moved four bytes to the right in the <b>FKP</b>. The new <b>FC </b>is added
at the end of the <b>rgfc</b> . The new <b>CHPX </b>or <b>PAPX </b>is recorded
on a 2-byte boundary before the previously recorded properties stored at
the end of the block. The word offset of the beginning of the <b>CHPX</b>
or <b>PAPX </b>is stored as the last entry of the relocated <b>rgb/rgbx[].b,</b>
and finally, the <b>crun</b> stored at offset 511 is incremented.
<h1>
BIN TABLES</h1>
A bin table (<b>plcfbte</b>) partitions the total extent of the Word file
that contains text characters into a set of contiguous intervals marked
by a fcFirst and an fcLim. The fcFirst for the <b>nth</b> interval would
be plcfbte.rgfc[<b>n</b>] and the fcLim for the <b>nth</b> interval would
be plcfbte.rgfc[<b>n+1</b>]. Associated with each interval is a <b>BTE.
</b>A
<b>BTE
</b>holds
a two-byte <b>PN</b> (page number) which identifies the
<b>FKP
</b>page
in the file which contains the formatting information for that interval.
A <b>CHPX</b> <b>FKP</b> further partitions an interval into runs of exception
text. A <b>PAPX FKP</b> in a non-complex, full-saved file, partitions the
text within intervals into paragraphs. If a file is in complex format (has
been fast-saved),the <b>PAPX FKP</b> only records the FCs within the text
that are preceded by a paragraph mark. Even though a sequence of text may
be physically located between two paragraph end marks, it may reside in
a paragraph differentfrom the one defined by the following paragraph end
mark, because the text may have been moved by the user into a different
paragraph. In the logical text stream represented by the document's piece
table, the paragraph mark that follows the moved text is stored in a non-adjacent
physical location in the file.
<a NAME="TocSTYLESHEET"></a>
<h1>
STYLESHEET</h1>
A stylesheet is a collection of styles.In Word, each document has its own
stylesheet.
<p>A style is a set of formatting information collected together and given
a name.Word 6.0 supports paragraph and character styles, previous versions
supported only paragraph styles.Character styles have just one type of
formatting, paragraph styles have both character and paragraph formatting.The
style sheet establishes a correspondence between a style code and a style
definition.
<p>Note that the storage and behavior of styles has changed radically since
WinWord 2, beginning with nFib 63. Some of the differences are:
<br><pindent><b>Error! Bookmark not defined.</b>Character styles are supported.<pindent><b>
Error! Bookmark not defined.</b>The style code is called an istd, rather
than an stc.<pindent><b> Error! Bookmark not defined.</b>The istd is a
short, where the stc was a byte.<pindent><b> Error! Bookmark not defined.</b>The
range of the istd is 0-4095, where 4095 is the null style.The range of
the stc was 0-256, with 222 as the null style.<pindent><b> Error! Bookmark
not defined.</b>PAPX's have a short istd at the beginning, rather than
a byte stc.<pindent><b> Error! Bookmark not defined.</b>CHPX's are a grpprl,
not a CHP.<pindent><b> Error! Bookmark not defined.</b>Many other changes...
<p>This document describes only the final Word 6.0 version of the stylesheet,
not the Word 2.x version.
<p>The styles for a document (both paragraph and character styles) are
stored in an array in each document.<a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a NAME="_ftnref3" href="#_ftn3" title=""></a><a href="#_ftn3" name="_ftnref3" title="">
[2]</a> When new styles are created, they are added to the end of the array.The
array can have unused slots.Some slots at the beginning of the array are
reserved for specific styles, whether they have been created yet or not.<a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a NAME="_ftnref4" href="#_ftn4" style="mso-footnote-id:ftn4" title=""></a><a href="#_ftn4" style="mso-footnote-id:ftn4" name="_ftnref4" title="">
[3]</a>Paragraph and character styles are stored in the same array.Each
document has a separate array, so the same style will usually<a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a NAME="_ftnref5" href="#_ftn5" title=""></a><a href="#_ftn5" name="_ftnref5" title="">
[4]</a> have a different istd in two different documents. Thus style matching
between documents must be done by name (or by sti if the styles are built-in.)
<p>Styles are usually referred to using an istd.The istd is an index into
an array of STD's (STyle Descriptions).A (doc, istd) pair uniquely identifies
a style because it tells which style in which array.
<p>Parts of a style (for more information, see the STD structure below):
<ul>
<li>
sti: A style identifier. Built-in styles have an sti that indicates which
built-in style they are.User-defined styles all have stiUser.</li>

<li>
sgc: The type of style, either paragraph or character.</li>

<li>
istdBase: The style that this style is based on.</li>

<li>
istdNext: The style that should be applied after this one.</li>

<li>
stzName: The name of a style, unique within its stylesheet.</li>

<li>
UPX: The difference between this style and the one it is based on.</li>

<li>
UPE: The properties of this style (a PAP, CHP, and/or grpprl).</li>
</ul>
Every paragraph has a paragraph style.Every character has a character style.The
default paragraph style is Normal (stiNormal, istdNormal).The default character
style is Default Paragraph Font (stiNormalChar, istdNormalChar).
<p>The formatting of a paragraph (the PAP) and a character (the CHP) depend
on the paragraph and character styles applied to them, as well as any additional
formatting stored in the FKPs.The PAP and CHP are constructed in a layered
fashion:
<p>For a PAP:
<br><pindent>1. An initial PAP is determined by getting the PAP from the
paragraph's style.<pindent>2. Any paragraph formatting stored in the file
(the FKP papx's) is then applied to that PAP.
<p>For a CHP:
<br><pindent>1. An initial CHP is determined by getting the CHP from the
paragraph's style.<pindent>2. Properties from the character's style (the
UPX.chpx.grpprl) are then applied to that CHP.<pindent>3. Any character
formatting stored in the file (the FKP chpx's) is the applied to that CHP.
<p>Note that the resulting PAP and CHP have fields that indicate what style
was applied: PAP.istd, CHP.istd.
<h2>
Stylesheet File Format</h2>
The style sheet (STSH)is stored in the file in two parts, a STSHI and then
an array of STDs.The STSHI contains general information about the following
stylesheet, including how many styles are in it.After the STSHI, each style
is written as an STD.Both the STSHI and each STD are preceded by a ushort
that indicates their length.
<p><i><u>FieldSize Comment</u></i>
<p>cbStshi 2 bytes size of the following STSHI structure<!--[if !supportFootnotes]--><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a NAME="_ftnref6" href="#_ftn6" style="mso-footnote-id:ftn6" title=""></a><a href="#_ftn6" style="mso-footnote-id:ftn6" name="_ftnref6" title="">[5]</a>
<p>STSHI (cbStshi) Stylesheet Information
<p>Then for each style in the stylesheet (stshi.cstd), the following is
stored:
<p>cbStd 2 bytes size of the following STD structure
<p>STD (cbStd)the style description
<h3>
STyleSHeet Information (STSHI)</h3>
The STSHI structure has the following format:

<pre>// STSHI: STyleSHeet Information, as stored in a file
//&nbsp; Note that new fields can be added to the STSHI without invalidating
//&nbsp; the file format, because it is stored preceded by it's length.
//&nbsp; When reading a STSHI from an older version, new fields will be zero.</pre>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cstd</td>

<td>U16</td>

<td></td>

<td></td>

<td>Count of styles in stylesheet</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cbSTDBaseInFile</td>

<td>U16</td>

<td></td>

<td></td>

<td>Length of STD Base as stored in a file</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fStdStylenamesWritten</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>Are built-in stylenames stored?</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused4_2</td>

<td>U16</td>

<td>:15</td>

<td>FFFE</td>

<td>Spare flags</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>stiMaxWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>Max sti known when this file was written</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>istdMaxFixedWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>How many fixed-index istds are there?</td>
</tr>

<tr>
<td>10</td>

<td>0xA</td>

<td>nVerBuiltInNamesWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>Current version of built-in stylenames</td>
</tr>

<tr>
<td>12</td>

<td>0xC</td>

<td>ftcStandardChpStsh</td>

<td>U16</td>

<td></td>

<td></td>

<td>ftc used by StandardChpStsh for this document</td>
</tr>
</table>

<p>The cb preceding the STSHI in the file is the length of the STSHI as
stored in the file.The current definition of the STSHI structure might
be longer or shorter than that stored in the file, the stylesheet reader
routine needs to take this into account.
<p><b>stshi.cstd:</b> The number of styles in this stylesheet.There will
be stshi.cstd (cbSTD, STD) pairs in the file following the STSHI.Note that
styles can be empty, ie. cbSTD == 0.
<p><b>stshi.cbSTDBaseInFile:</b> The STD structure (see below) is divided
into a fixed-length "base", and a variable length part.The stshi.cbSTDBaseInFile
indicates the size in bytes of the fixed-length base of the STD as it was
written in this file.If the STD base is grown in a future version, the
file format doesn't change, because the stylesheet reader can discard parts
it doesn't know about, or use defaults if the file's STD is not as large
as it was expecting.(Currently, stshi.cbSTDBaseInFile is 8.)
<p><b>stshi.fStdStylenamesWritten:</b> Previous versions of Word did not
store the style name if the style was a built-in style; Word 6.0 does,
for compatibility with future versions.Note that the built-in stylenames
may need to be "regenerated" if the file is opened in a different language
or if stshi.nVerBuiltInNamesWhenSaved doesn't match the expected value.
<p><b>stshi.stiMaxWhenSaved:</b> This indicates the last built-in style
known to the version of Word that saved this file.
<p><b>stshi.istdMaxFixedWhenSaved:</b> Each array of styles has some fixed-index
styles at the beginning.This indicates the number of fixed-index positions
reserved in the stylesheet when it was saved.
<p><b>stshi.nVerBuiltInNamesWhenSaved:</b> Since built-in stylenames are
saved with the document, this provides an way to see if the saved names
are the same "version" as the names in the version of Word that is loading
the file.If not, the built-in stylenames need to be "regenerated", ie.
the old names need to be replaced with the new.
<p><b>stshi.ftcStandardChpStsh:</b> This is the default font for this stylesheet.
<h3>
STD</h3>
The style description is stored in an STD structure as follows:

<p class="code">// STD: STyle Definition

<p class="code">//The STD contains the entire definition of a style.

<p class="code">//It has two parts, a fixed-length base (cbSTDBase bytes
long)

<p class="code">//and a variable length remainder holding the name, and
the upx and upe

<p class="code">//arrays (a upx and upe for each type stored in the style,
std.cupx)

<p class="code">//Note that new fields can be added to the BASE of the
STD without

<p class="code">//invalidating the file format, because the STSHI contains
the length

<p class="code">//that is stored in the file.When reading STDs from an
older version,

<p class="code">//new fields will be zero.

<p class="code">typedef struct _STD

<p class="code">{

<p class="code">// Base part of STD:

<p class="code">ushortsti :12;/* invariant style identifier */

<p class="code">ushortfScratch :1; /* spare field for any temporary use,

<p class="code">always reset back to zero! */

<p class="code">ushortfInvalHeight :1; /* PHEs of all text with this style
are wrong */

<p class="code">ushortfHasUpe :1;/* UPEs have been generated */

<p class="code">ushortfMassCopy :1; /* std has been mass-copied; if unused
at

<p class="code">save time, style should be deleted */

<p class="code">ushortsgc : 4;/* style type code */

<p class="code">ushortistdBase :12; /* base style */

<p class="code">ushortcupx : 4;/* # of UPXs (and UPEs) */

<p class="code">ushortistdNext :12; /* next style */

<p class="code">ushortbchUpe;/* offset to end of upx's, start of upe's
*/
<br>&nbsp;
<br>&nbsp;

<p class="code">// Variable length part of STD:

<p class="code">ucharstzName[2];/* sub-names are separated by chDelimStyle
*/

<p class="code">/* chargrupx[]; */

<p class="code">/* the UPEs are not stored on the file; they are a cache
of the based-on

<p class="code">chain */

<p class="code">/* chargrupe[]; */

<p class="code">} STD;
<p>The cb preceding each STD is the length of the data, which includes
all of the STD except the grupe array (which is derived after the file
is read in, by building each UPE from the base style UPE plus the exceptions
in the UPX.)A cb of zero indicates an empty slot in the style array, ie.
no style has that istd.Note that the STD structure may be longer or shorter
than the one stored in the file, stshi.cbSTDBaseInFile indicates the length
of the base of the STD (up to stzName) as stored in the file.The stylesheet
reader routine has to take this into account.
<p>The variable-length part of the STD actually has three variable-length
subparts, the stzName, the grupx, and the grupe.Since this doesn?t fit
well into a C structure declaration, some processing is needed to figure
out where one part stops and the next part begins.An important note is
that all variable-length parts and subparts of the STD begin on EVEN-BYTE
OFFSETS within the STD, even if the length of the preceding variable-length
part was odd.
<p><b>std.sti:</b> The sti is an identifier which built-in style this is,
or stiUser for a user-defined style.An sti is intended to be permanent
through versions of Word, although new sti's may be added in new versions.The
sti definitions are:

<p class="code">// standard sti codes - these are invariant identifiers
for built-in styles

<p class="code">// and must remain the same (ie. don't renumber them, or
old files will be

<p class="code">// messed up.)

<p class="code">// NOTE: sti and istd are the same for Normal and level
styles

<p class="code">// If you want to define a new built-in style:

<p class="code">//1) Decide if you really need one--it will exist in all
future versions!

<p class="code">//2) Add a new sti below.You can take the first available
slot.

<p class="code">//3) Change stiMax, and stiPapMax or stiChpMax

<p class="code">//4) Add entry to _dnsti, and the two ids's in strman.pp

<p class="code">//5) Add case in GetDefaultUpdForSti

<p class="code">//6) Change cstiMaxBuiltinDependents if necessary

<p class="code">// If you want to change the definition of a built-in style

<p class="code">//1) In order to make WinWord 2 documents that use the
style look like

<p class="code">//they did in WinWord 2, add a case in GetDefaultUpdForSti
to handle

<p class="code">//fOldDef.This definition will be used when converting
WinWord 2

<p class="code">//stylesheets.

<p class="code">//2) If you change the name of a built-in style, increment
nVerBuiltInNames

<p class="code">#define stiNormal0// 0x0000
<br>&nbsp;
<br>&nbsp;

<p class="code">#define stiLev11// 0x0001

<p class="code">#define stiLev22// 0x0002

<p class="code">#define stiLev33// 0x0003

<p class="code">#define stiLev44// 0x0004

<p class="code">#define stiLev55// 0x0005

<p class="code">#define stiLev66// 0x0006

<p class="code">#define stiLev77// 0x0007

<p class="code">#define stiLev88// 0x0008

<p class="code">#define stiLev99// 0x0009

<p class="code">#define stiLevFirststiLev1

<p class="code">#define stiLevLaststiLev9
<br>&nbsp;
<br>&nbsp;

<p class="code">#define stiIndex110// 0x000A

<p class="code">#define stiIndex211// 0x000B

<p class="code">#define stiIndex312// 0x000C

<p class="code">#define stiIndex413// 0x000D

<p class="code">#define stiIndex514// 0x000E

<p class="code">#define stiIndex615// 0x000F

<p class="code">#define stiIndex716// 0x0010

<p class="code">#define stiIndex817// 0x0011

<p class="code">#define stiIndex918// 0x0012

<p class="code">#define stiIndexFirststiIndex1

<p class="code">#define stiIndexLaststiIndex9
<br>&nbsp;
<br>&nbsp;

<p class="code">#define stiToc119// 0x0013

<p class="code">#define stiToc220// 0x0014

<p class="code">#define stiToc321// 0x0015

<p class="code">#define stiToc422// 0x0016

<p class="code">#define stiToc523// 0x0017

<p class="code">#define stiToc624// 0x0018

<p class="code">#define stiToc725// 0x0019

<p class="code">#define stiToc826// 0x001A

<p class="code">#define stiToc927// 0x001B

<p class="code">#define stiTocFirststiToc1

<p class="code">#define stiTocLaststiToc9
<br>&nbsp;
<br>&nbsp;

<p class="code">#define stiNormIndent28// 0x001C

<p class="code">#define stiFtnText29// 0x001D

<p class="code">#define stiAtnText30// 0x001E

<p class="code">#define stiHeader31// 0x001F

<p class="code">#define stiFooter32// 0x0020

<p class="code">#define stiIndexHeading 33// 0x0021

<p class="code">#define stiCaption34// 0x0022

<p class="code">#define stiToCaption35// 0x0023

<p class="code">#define stiEnvAddr36// 0x0024

<p class="code">#define stiEnvRet37// 0x0025

<p class="code">#define stiFtnRef38// 0x0026char style

<p class="code">#define stiAtnRef39// 0x0027char style

<p class="code">#define stiLnn40// 0x0028char style

<p class="code">#define stiPgn41// 0x0029char style

<p class="code">#define stiEdnRef42// 0x002Achar style

<p class="code">#define stiEdnText43// 0x002B

<p class="code">#define stiToa44// 0x002C

<p class="code">#define stiMacro45// 0x002D

<p class="code">#define stiToaHeading46// 0x002E

<p class="code">#define stiList47// 0x002F

<p class="code">#define stiListBullet48// 0x0030

<p class="code">#define stiListNumber49// 0x0031

<p class="code">#define stiList250// 0x0032

<p class="code">#define stiList351// 0x0033

<p class="code">#define stiList452// 0x0034

<p class="code">#define stiList553// 0x0035

<p class="code">#define stiListBullet2 54// 0x0036

<p class="code">#define stiListBullet3 55// 0x0037

<p class="code">#define stiListBullet4 56// 0x0038

<p class="code">#define stiListBullet5 57// 0x0039

<p class="code">#define stiListNumber2 58// 0x003A

<p class="code">#define stiListNumber3 59// 0x003B

<p class="code">#define stiListNumber4 60// 0x003C

<p class="code">#define stiListNumber5 61// 0x003D

<p class="code">#define stiTitle&nbsp; 62// 0x003E

<p class="code">#define stiClosing63// 0x003F

<p class="code">#define stiSignature64// 0x0040

<p class="code">#define stiNormalChar65// 0x0041char style

<p class="code">#define stiBodyText66// 0x0042

<p class="code">#define stiBodyText267// 0x0043

<p class="code">#define stiListCont68// 0x0044

<p class="code">#define stiListCont269// 0x0045

<p class="code">#define stiListCont370// 0x0046

<p class="code">#define stiListCont471// 0x0047

<p class="code">#define stiListCont572// 0x0048

<p class="code">#define stiMsgHeader73// 0x0049

<p class="code">#define stiSubtitle74// 0x004A
<br>&nbsp;
<br>&nbsp;

<p class="code">#define stiMax75// number of defined sti's
<br>&nbsp;
<br>&nbsp;

<p class="code">#define stiUser0x0ffe// user styles are distinguished by
name

<p class="code">#define stiNil0x0fff// max for 12 bits
<p>See below for the names of these styles.
<p><b>std.stc:</b> The type of each style is indicated by std.sgc.The two
types currently in use are:

<p class="code">sgcPara1// A paragraph style

<p class="code">sgcChp2// A character style
<p>More style types may exist in the future, so styles of an unknown type
should be discarded.
<p><b>std.istdBase:</b> The style that this style is based on.A style is
always based on another style or the null style (istdNil).Following a "chain"
of based-on styles will always end at the null style, because a based-on
chain cannot have a loop in it.A style can have up to 11 "ancestors" in
its based-on chain, including the null style.A style's definition is built
up from the style that it is based on.See std.cupx, std.grupx, std.grupe.
<p><b>std.istdNext:</b> The style that should be applied after this one.For
a paragraph style, this is the style that is applied when Enter is pressed
at the end of a paragraph.For a character style, the next style is essentially
ignored, but should be the same as the current style.
<p><b>std.stzName:</b> The name of the style, including aliases.The name
is stored as an stz (preceded by a length byte, followed by a null-terminator.)A
style name can contain multiple "aliases", separated by commas.Aliases
are alternate names for the same style (eg. a style named "a,b,c" has three
aliases, and can be referred to by "a", "b", or "c", or any combination.)WinWord
2.x did not have aliases, but MacWord 5.x did.If a style is a built-in
style, the built-in stylename is always stored first.
<p>All names (and aliases) must be unique within a stylesheet (eg. styles
"a,b" and "b,c" should not exist in the same stylesheet, as "b" matches
multiple stylenames.)
<p>A stylename (including all its aliases and comma separators) can be
up to 253 characters long.So the stz format of that name can be up to 255
characters.
<p>The built-in stylenames (corresponding to each sti above) are defined
for each language version of Word.For the USA, the names are:

<p class="code">// These are the names of the built-in styles as we want
to present them

<p class="code">// to the user.

<p class="code">Normal

<p class="code">Heading 1

<p class="code">Heading 2

<p class="code">Heading 3

<p class="code">Heading 4

<p class="code">Heading 5

<p class="code">Heading 6

<p class="code">Heading 7

<p class="code">Heading 8

<p class="code">Heading 9

<p class="code">Index 1

<p class="code">Index 2

<p class="code">Index 3

<p class="code">Index 4

<p class="code">Index 5

<p class="code">Index 6

<p class="code">Index 7

<p class="code">Index 8

<p class="code">Index 9

<p class="code">TOC 1

<p class="code">TOC 2

<p class="code">TOC 3

<p class="code">TOC 4

<p class="code">TOC 5

<p class="code">TOC 6

<p class="code">TOC 7

<p class="code">TOC 8

<p class="code">TOC 9

<p class="code">Normal Indent

<p class="code">Footnote Text

<p class="code">Annotation Text

<p class="code">Header

<p class="code">Footer

<p class="code">Index Heading

<p class="code">Caption

<p class="code">Table of Figures

<p class="code">Envelope Address

<p class="code">Envelope Return

<p class="code">Footnote Reference

<p class="code">Annotation Reference

<p class="code">Line Number

<p class="code">Page Number

<p class="code">Endnote Reference

<p class="code">Endnote Text

<p class="code">Table of Authorities

<p class="code">Macro Text

<p class="code">TOA Heading

<p class="code">List

<p class="code">List 2

<p class="code">List 3

<p class="code">List 4

<p class="code">List 5

<p class="code">List Bullet

<p class="code">List Bullet 2

<p class="code">List Bullet 3

<p class="code">List Bullet 4

<p class="code">List Bullet 5

<p class="code">List Number

<p class="code">List Number 2

<p class="code">List Number 3

<p class="code">List Number 4

<p class="code">List Number 5

<p class="code">Title

<p class="code">Closing

<p class="code">Signature

<p class="code">Default Paragraph Font

<p class="code">Body Text

<p class="code">Body Text Indent

<p class="code">List Continue

<p class="code">List Continue 2

<p class="code">List Continue 3

<p class="code">List Continue 4

<p class="code">List Continue 5

<p class="code">Message Header

<p class="code">Subtitle
<p><b>std.cupx: </b>This is the number of UPXs in the std.grupx array.See
below.
<p><b>std.grupx:</b> This is an array<a NAME="_ftnref7" href="#_ftn7" title=""></a><!--[if !supportFootnotes]--><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a NAME="_ftnref7" href="#_ftn7" title=""></a><a href="#_ftn7" name="_ftnref7" title="">
[6]</a> of variable-length UPXs, with std.cupx UPXs in the array.This array
begins after the variable-length stzName field, at the next even-byte offset
within the STD.A UPX (Universal Property eXception) describes the difference
in formatting of this style as compared to its based-on style.The UPX structure
looks like this:

<p class="code">typedef union _UPX

<p class="code">{

<p class="code">struct

<p class="code">{

<p class="code">uchar grpprl[cbMaxGrpprlStyleChpx];

<p class="code">} chpx;

<p class="code">struct

<p class="code">{

<p class="code">ushort istd;

<p class="code">uchar grpprl[cbMaxGrpprlStylePapx];

<p class="code">} papx;

<p class="code">ucharrgb[1];

<p class="code">} UPX;
<p>Each UPX stored in a file is not a complete UPX, rather it is a UPX
with all trailing zero bytes lopped off, and preceded by a ushort length
field.So it is stored like:
<p><i><u>FieldSize Comment</u></i>
<p>cbUPX 2 bytes size of the following UPX structure
<p>UPX (cbUPX)Nonzero prefix of a UPX structure
<p>Each UPX begins on an even-byte offset within the STD, even if the length
of the previous UPX (cbUPX) was odd.
<p>The meaning of each UPX depends on the style type (std.sgc).For a paragraph
style, std.cupx is 2.The first UPX is a paragraph UPX (UPX.papx) and the
second UPX is a character UPX (UPX.chpx).For a character style, std.cupx
is 1, and that UPX is a character UPX (UPX.chpx).Note that new UPXs may
be added in the future, so std.cupx might be larger than expected.Any UPXs
past those expected should be discarded.
<p>The grpprl within each UPX contains the differences of this property
type for this style from the UPE of that property type for the based on
style.For example, if two paragraph styles, A and B, were identical except
that B was bold where A was not, and B was based on A, B would have two
UPXs, where the paragraph UPX would have an empty grpprl<a NAME="_ftnref8" href="#_ftn8" title=""></a><a NAME="_ftnref8" href="#_ftn8" title=""></a><a href="#_ftn8" name="_ftnref8" title="">
[7]</a>, and the character UPX would have a bold sprm in the grpprl.Thus
B looks just like A (since B is based on A), with the exception that B
is bold.
<p><b>std.grupe:</b> This is an array (group) of variable-length UPEs.<b>
These are not stored in the file!</b>Rather, they are constructed using
the std.istdBase and std.grupx fields.A UPE (Universal Property Expansion)
describes the ?end-result? of the property formatting, ie. what the style
looks like.The UPE structure is the non-zero prefix of a UPD structure.The
UPD structure looks like this:

<p class="code">typedef union _UPD
<div class="code">{</div>

<div class="code">&nbsp;&nbsp;&nbsp; PAP pap;</div>

<div class="code">&nbsp;&nbsp;&nbsp; CHP chp;</div>

<div class="code">&nbsp;&nbsp;&nbsp; struct</div>

<div class="code">&nbsp;&nbsp;&nbsp; {</div>

<div class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ushort istd;</div>

<div class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uchar cbGrpprl;</div>

<div class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uchar grpprl[cbMaxGrpprlStyleChpx];</div>

<div class="code">&nbsp;&nbsp;&nbsp; } chpx;</div>

<div class="code">} UPD;</div>
The std.grupe and std.grupx arrays are similar: there is one UPE for each
UPX, and internally they are stored similarly (a length ushort followed
by a non-zero prefix), though remember that the UPEs are not stored in
the file.The meaning of each UPE depends on the style type (std.sgc).For
a paragraph style, the first UPE is a PAP (UPE.pap).The second UPE is a
CHP (UPE.chp).For a character style, the first UPE is a CHPX (UPE.chpx).
<p>The UPEs for a style are constructed by taking the UPEs from the based-on
style, and applying the UPXs to them. Obviously, if the UPEs for the based-on
style haven?t yet been constructed, that style?s UPEneeds to be constructedfirst.Eventually
by following the based-on chain, a style will be based on the null style
(istdNil). The UPEs for the null style are predefined:
<br>The UPE.pap for the null style is all zeros, except fWidowControl which
is 1, dyaLine which is 240, and fMultLinespace which is 1.<pindent> &middot;The
UPE.chp for the null style is all zeros, except istd which is 10 (istdNormalChar),
hps which is 20, lid which is 0x0400, and ftc which is set to the STSHI.ftcStandardChpStsh.
The UPE.chpx for the null style has an istd of zero, a cbGrpprl of zero
(and an empty grpprl).
<p>So, for a paragraph style, the first UPE is a UPE.pap.It can be constructed&nbsp;
by starting the with first UPE from the based-on style (std.istdBase),
and then applying the first UPX (UPX.papx) in std.grupx to that UPE.To
apply a UPX.papx to a UPE.pap, set UPE.pap.istd equal to UPX.papx.istd,
and then apply the UPX.papx.grpprl to UPE.pap.Similarly, the second UPE
is a UPE.chp.It can be constructed by starting with the second UPE from
the based-on style, and then applying the second UPX (UPX.chpx) in std.grupx
to that UPE.To apply a UPX.chpx to a UPE.chp, apply the UPX.chpx.grpprl
to UPE.chp.Note that a UPE.chp for a paragraph style should always have
UPE.chp.istd == istdNormalCh
<p>For a character style, the first (and only) UPE (a UPE.chpx) can be
constructed by starting with the first UPE from the based-on style (std.istdBase),
and then applying the first UPX (UPX.chpx) in std.grupx to that UPE.To
apply a UPX.chpx to a UPE.chpx, take the grpprl in UPE.chpx.grpprl (which
has a length of UPE.chpx.cbGrpprl) and merge the grpprl in UPX.chpx.grpprl
into it.Merging grpprls is a tricky business, but for character styles
it is easy because no prls in character style grpprls should interact with
each other.Each prl from the source (the UPX.chpx.grpprl) should be inserted
into the destination (the UPE.chpx.grpprl) so that the sprm of each prl
is in increasing order, and any prls that have the same sprm are replaced
by the prl in the source. UPE.chpx.cbGrpprl is then set to the length of
resulting grpprl, and UPE.chpx.istd is set to the style?s istd.
<a NAME="TocSPRMS"></a>
<h1>
SPRM DEFINITIONS</h1>
A <b>sprm</b> is an instruction to modify one or more properties within
one of the property defining data structures (<b>CHP</b>, <b>PAP</b>, <b>TAP</b>
, <b>SEP, or PIC</b>). A <b>sprm </b>always begins with a one byte opcode
at offset 0 which identifies the operation to be performed. If necessary
information for the operation can always be expressed with a fixed length
parameter, the fixed length parameter is recorded immediately after the
opcode beginning at offset 1. The length of a fixed length sprm is always
1 plus the size of the sprm?s parameter. If the parameter for the sprm
is variable length, the count of bytes of the following parameter is stored
in the byte at offset 1.
<p>Three sprms, sprmPChgTabs , sprmTDefTable, and sprmTDefTable10 can be
longer than 256 bytes. The method for calculating the length of sprmPChgTabs
is recorded below with the description of the sprm.For sprmTDefTable and
sprmTDefTable10, the length of the parameter plus 1 is recorded in the
two bytes beginning at offset 1.
<p>For variable length sprms, the total length of the sprm is the countrecorded
at offset 1 plus two. The parameter immediately follows the count.

<p style="margin-top: 12pt; margin-bottom: 12pt; margin-left: 0pt; ">Unless
otherwise noted, when a sprm is applied to a property the sprm's parameter
changes the old value of the property in question to the value stored in
the sprm parameter.
<br>&nbsp;
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Name</td>

<td>op code</td>

<td>Property Modified</td>

<td>Parameter</td>

<td>Parameter size</td>
</tr>

<tr>
<td>sprmPIstd</td>

<td>2</td>

<td>pap.istd</td>

<td>istd (style code)</td>

<td>U16</td>
</tr>

<tr>
<td>sprmPIstdPermute</td>

<td>3</td>

<td>pap.istd</td>

<td>permutation vector (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPIncLvl</td>

<td>4</td>

<td>pap.istd</td>

<td>difference between istd of base PAP and istd of PAP to be produced
(see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPJc</td>

<td>5</td>

<td>pap.jc</td>

<td>jc (justification)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFSideBySide</td>

<td>6</td>

<td>pap.fSideBySide</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFKeep</td>

<td>7</td>

<td>pap.fKeep</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFKeepFollow</td>

<td>8</td>

<td>pap.fKeepFollow</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFPageBreakBefore</td>

<td>9</td>

<td>pap.fPageBreakBefore</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPBrcl</td>

<td>10</td>

<td>pap.brcl</td>

<td>brcl</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPBrcp</td>

<td>11</td>

<td>pap.brcp</td>

<td>brcp</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPAnld</td>

<td>12</td>

<td>pap.anld</td>

<td>anld</td>

<td>variable length (the length of an ANLD structure)</td>
</tr>

<tr>
<td>sprmPNLvlAnm</td>

<td>13</td>

<td>pap.nLvlAnm</td>

<td>nn</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFNoLineNumb</td>

<td>14</td>

<td>pap.fNoLnn</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPChgTabsPapx</td>

<td>15</td>

<td>pap.itbdMac, pap.rgdxaTab, pap.rgtbd</td>

<td>complex - see below</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPDxaRight</td>

<td>16</td>

<td>pap.dxaRight</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaLeft</td>

<td>17</td>

<td>pap.dxaLeft</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPNest</td>

<td>18</td>

<td>pap.dxaLeft</td>

<td>dxa-see below</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaLeft1</td>

<td>19</td>

<td>pap.dxaLeft1</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaLine</td>

<td>20</td>

<td>pap.lspd</td>

<td>an LSPD, a long word structure consisting of a short of dyaLine followed
by a short of fMultLinespace - see below</td>

<td>U32</td>
</tr>

<tr>
<td>sprmPDyaBefore</td>

<td>21</td>

<td>pap.dyaBefore</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaAfter</td>

<td>22</td>

<td>pap.dyaAfter</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPChgTabs</td>

<td>23</td>

<td>pap.itbdMac, pap.rgdxaTab, pap.rgtbd</td>

<td>complex - see below</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPFInTable</td>

<td>24</td>

<td>pap.fInTable</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFTtp</td>

<td>25</td>

<td>pap.fTtp</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPDxaAbs</td>

<td>26</td>

<td>pap.dxaAbs</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaAbs</td>

<td>27</td>

<td>pap.dyaAbs</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaWidth</td>

<td>28</td>

<td>pap.dxaWidth</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPPc</td>

<td>29</td>

<td>pap.pcHorz, pap.pcVert</td>

<td>complex - see below</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPBrcTop10</td>

<td>30</td>

<td>pap.brcTop</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcLeft10</td>

<td>31</td>

<td>pap.brcLeft</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBottom10</td>

<td>32</td>

<td>pap.brcBottom</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcRight10</td>

<td>33</td>

<td>pap.brcRight</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBetween10</td>

<td>34</td>

<td>pap.brcBetween</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBar10</td>

<td>35</td>

<td>pap.brcBar</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPFromText10</td>

<td>36</td>

<td>pap.dxaFromText</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPWr</td>

<td>37</td>

<td>pap.wr</td>

<td>wr (see description of PAP for definition</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPBrcTop</td>

<td>38</td>

<td>pap.brcTop</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcLeft</td>

<td>39</td>

<td>pap.brcLeft</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBottom</td>

<td>40</td>

<td>pap.brcBottom</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcRight</td>

<td>41</td>

<td>pap.brcRight</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBetween</td>

<td>42</td>

<td>pap.brcBetween</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBar</td>

<td>43</td>

<td>pap.brcBar</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPFNoAutoHyph</td>

<td>44</td>

<td>pap.fNoAutoHyph</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPWHeightAbs</td>

<td>45</td>

<td>pap.wHeightAbs</td>

<td>w</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDcs</td>

<td>46</td>

<td>pap.dcs</td>

<td>DCS</td>

<td>U16</td>
</tr>

<tr>
<td>sprmPShd</td>

<td>47</td>

<td>pap.shd</td>

<td>SHD</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaFromText</td>

<td>48</td>

<td>pap.dyaFromText</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaFromText</td>

<td>49</td>

<td>pap.dxaFromText</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPFLocked</td>

<td>50</td>

<td>pap.fLocked</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPFWidowControl</td>

<td>51</td>

<td>pap.fWidowControl</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPRuler</td>

<td>52</td>

<td></td>

<td></td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCFStrikeRM</td>

<td>65</td>

<td>chp.fRMarkDel</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFRMark</td>

<td>66</td>

<td>chp.fRMark</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFFldVanish</td>

<td>67</td>

<td>chp.fFldVanish</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCPicLocation</td>

<td>68</td>

<td>chp.fcPic and chp.fSpec</td>

<td>see below</td>

<td>variable length, length recorded is always 4</td>
</tr>

<tr>
<td>sprmCIbstRMark</td>

<td>69</td>

<td>chp.ibstRMark</td>

<td>index into sttbRMark</td>

<td>U16</td>
</tr>

<tr>
<td>sprmCDttmRMark</td>

<td>70</td>

<td>chp.dttm</td>

<td>DTTM</td>

<td>U32</td>
</tr>

<tr>
<td>sprmCFData</td>

<td>71</td>

<td>chp.fData</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCRMReason</td>

<td>72</td>

<td>chp.idslRMReason</td>

<td>an index to a table of strings defined in Word 6.0 executables</td>

<td>U16</td>
</tr>

<tr>
<td>sprmCChse</td>

<td>73</td>

<td>chp.fChsDiff and chp.chse</td>

<td>see below</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmCSymbol</td>

<td>74</td>

<td>chp.fSpec, chp.chSym and chp.ftcSym</td>

<td>see below</td>

<td>variable length, length recorded is always 3</td>
</tr>

<tr>
<td>sprmCFOle2</td>

<td>75</td>

<td>chp.fOle2</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCIstd</td>

<td>80</td>

<td>chp.istd</td>

<td>istd, see stylesheet definition</td>

<td>U16</td>
</tr>

<tr>
<td>sprmCIstdPermute</td>

<td>81</td>

<td>chp.istd</td>

<td>permutation vector (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCDefault</td>

<td>82</td>

<td>whole CHP (see below)</td>

<td>none</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCPlain</td>

<td>83</td>

<td>whole CHP (see below)</td>

<td>none</td>

<td>0</td>
</tr>

<tr>
<td>sprmCFBold</td>

<td>85</td>

<td>chp.fBold</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFItalic</td>

<td>86</td>

<td>chp.fItalic</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFStrike</td>

<td>87</td>

<td>chp.fStrike</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFOutline</td>

<td>88</td>

<td>chp.fOutline</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFShadow</td>

<td>89</td>

<td>chp.fShadow</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFSmallCaps</td>

<td>90</td>

<td>chp.fSmallCaps</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFCaps</td>

<td>91</td>

<td>chp.fCaps</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFVanish</td>

<td>92</td>

<td>chp.fVanish</td>

<td>0,1, 128, or 129 (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCFtc</td>

<td>93</td>

<td>chp.ftc</td>

<td>ftc</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCKul</td>

<td>94</td>

<td>chp.kul</td>

<td>kul</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCSizePos</td>

<td>95</td>

<td>chp.hps, chp.hpsPos</td>

<td>(see below)</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmCDxaSpace</td>

<td>96</td>

<td>chp.dxaSpace</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCLid</td>

<td>97</td>

<td>chp.lid</td>

<td>LID</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCIco</td>

<td>98</td>

<td>chp.ico</td>

<td>ico</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCHps</td>

<td>99</td>

<td>chp.hps</td>

<td>hps</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCHpsInc</td>

<td>100</td>

<td>chp.hps</td>

<td>(see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCHpsPos</td>

<td>101</td>

<td>chp.hpsPos</td>

<td>hps</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCHpsPosAdj</td>

<td>102</td>

<td>chp.hpsPos</td>

<td>hps (see below)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCMajority</td>

<td>103</td>

<td>chp.fBold, chp.fItalic, chp.fSmallCaps, chp.fVanish, chp.fStrike, chp.fCaps,
chp.ftc, chp.hps, chp.hpsPos, chp.kul, chp.dxaSpace, chp.ico, chp.lid</td>

<td>complex (see below)</td>

<td>variable length,length byte plus size of following grpprl</td>
</tr>

<tr>
<td>sprmCIss</td>

<td>104</td>

<td>chp.iss</td>

<td>iss</td>

<td>U8</td>
</tr>

<tr>
<td>sprmCHpsNew50</td>

<td>105</td>

<td>chp.hps</td>

<td>hps</td>

<td>variable width, length always recorded as 2</td>
</tr>

<tr>
<td>sprmCHpsInc1</td>

<td>106</td>

<td>chp.hps</td>

<td>complex (see below)</td>

<td>variable width, length always recorded as 2</td>
</tr>

<tr>
<td>sprmCHpsKern</td>

<td>107</td>

<td>chp.hpsKern</td>

<td>hps</td>

<td>U16</td>
</tr>

<tr>
<td>sprmCMajority50</td>

<td>108</td>

<td>chp.fBold, chp.fItalic, chp.fSmallCaps, chp.fVanish, chp.fStrike, chp.fCaps,
chp.ftc, chp.hps, chp.hpsPos, chp.kul, chp.dxaSpace, chp.ico,</td>

<td>complex (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCHpsMul</td>

<td>109</td>

<td>chp.hps</td>

<td>percentage to grow hps</td>

<td>U16</td>
</tr>

<tr>
<td>sprmCCondHyhen</td>

<td>110</td>

<td>chp.ysri</td>

<td>ysri</td>

<td>U16</td>
</tr>

<tr>
<td>sprmCFSpec</td>

<td>117</td>

<td>chp.fSpec&nbsp;</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFObj</td>

<td>118</td>

<td>chp.fObj</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmPicBrcl</td>

<td>119</td>

<td>pic.brcl</td>

<td>brcl (see PIC structure definition)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmPicScale</td>

<td>120</td>

<td>pic.mx, pic.my, pic.dxaCropleft,&nbsp;
<p>pic.dyaCropTop&nbsp;
<p>pic.dxaCropRight,&nbsp;
<p>pic.dyaCropBottom</td>

<td>complex (see below)</td>

<td>length byte plus 12 bytes</td>
</tr>

<tr>
<td>sprmPicBrcTop</td>

<td>121</td>

<td>pic.brcTop</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPicBrcLeft</td>

<td>122</td>

<td>pic.brcLeft</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPicBrcBottom</td>

<td>123</td>

<td>pic.brcBottom</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPicBrcRight</td>

<td>124</td>

<td>pic.brcRight</td>

<td>BRC</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSScnsPgn</td>

<td>131</td>

<td>sep.cnsPgn</td>

<td>cns</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSiHeadingPgn</td>

<td>132</td>

<td>sep.iHeadingPgn</td>

<td>heading number level</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSOlstAnm</td>

<td>133</td>

<td>sep.olstAnm</td>

<td>OLST</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmSDxaColWidth</td>

<td>136</td>

<td>sep.rgdxaColWidthSpacing</td>

<td>complex (see below)</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmSDxaColSpacing</td>

<td>137</td>

<td>sep.rgdxaColWidthSpacing</td>

<td>complex (see below)</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmSFEvenlySpaced</td>

<td>138</td>

<td>sep.fEvenlySpaced</td>

<td>1 or 0</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSFProtected</td>

<td>139</td>

<td>sep.fUnlocked</td>

<td>1 or 0</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSDmBinFirst</td>

<td>140</td>

<td>sep.dmBinFirst</td>

<td></td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDmBinOther</td>

<td>141</td>

<td>sep.dmBinOther</td>

<td></td>

<td>S16</td>
</tr>

<tr>
<td>sprmSBkc</td>

<td>142</td>

<td>sep.bkc</td>

<td>bkc</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSFTitlePage</td>

<td>143</td>

<td>sep.fTitlePage</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSCcolumns</td>

<td>144</td>

<td>sep.ccolM1</td>

<td># of cols - 1</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaColumns</td>

<td>145</td>

<td>sep.dxaColumns</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSFAutoPgn</td>

<td>146</td>

<td>sep.fAutoPgn</td>

<td>obsolete</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSNfcPgn</td>

<td>147</td>

<td>sep.nfcPgn</td>

<td>nfc</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSDyaPgn</td>

<td>148</td>

<td>sep.dyaPgn</td>

<td>dya</td>

<td>U16</td>
</tr>

<tr>
<td>sprmSDxaPgn</td>

<td>149</td>

<td>sep.dxaPgn</td>

<td>dya</td>

<td>U16</td>
</tr>

<tr>
<td>sprmSFPgnRestart</td>

<td>150</td>

<td>sep.fPgnRestart</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSFEndnote</td>

<td>151</td>

<td>sep.fEndnote</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSLnc</td>

<td>152</td>

<td>sep.lnc</td>

<td>lnc</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSGprfIhdt</td>

<td>153</td>

<td>sep.grpfIhdt</td>

<td>grpfihdt (see Headers and Footers topic)</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSNLnnMod</td>

<td>154</td>

<td>sep.nLnnMod</td>

<td>non-neg int.</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaLnn</td>

<td>155</td>

<td>sep.dxaLnn</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaHdrTop</td>

<td>156</td>

<td>sep.dyaHdrTop</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaHdrBottom</td>

<td>157</td>

<td>sep.dyaHdrBottom</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSLBetween</td>

<td>158</td>

<td>sep.fLBetween</td>

<td>0 or 1</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSVjc</td>

<td>159</td>

<td>sep.vjc</td>

<td>vjc</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSLnnMin</td>

<td>160</td>

<td>sep.lnnMin</td>

<td>lnn</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSPgnStart</td>

<td>161</td>

<td>sep.pgnStart</td>

<td>pgn</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSBOrientation</td>

<td>162</td>

<td>sep.dmOrientPage</td>

<td>dm</td>

<td>U8</td>
</tr>

<tr>
<td>sprmSBCustomize</td>

<td>163</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>sprmSXaPage</td>

<td>164</td>

<td>sep.xaPage</td>

<td>xa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSYaPage</td>

<td>165</td>

<td>sep.yaPage</td>

<td>ya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaLeft</td>

<td>166</td>

<td>sep.dxaLeft</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaRight</td>

<td>167</td>

<td>sep.dxaRight</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaTop</td>

<td>168</td>

<td>sep.dyaTop</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaBottom</td>

<td>169</td>

<td>sep.dyaBottom</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDzaGutter</td>

<td>170</td>

<td>sep.dzaGutter</td>

<td>dza</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDMPaperReq</td>

<td>171</td>

<td>sep.dmPaperReq</td>

<td>dm</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTJc</td>

<td>182</td>

<td>tap.jc</td>

<td>jc</td>

<td>S16 (low order byte is significant)</td>
</tr>

<tr>
<td>sprmTDxaLeft</td>

<td>183</td>

<td>tap.rgdxaCenter (see below)</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDxaGapHalf</td>

<td>184</td>

<td>tap.dxaGapHalf, tap.rgdxaCenter (see below)</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTFCantSplit</td>

<td>185</td>

<td>tap.fCantSplit</td>

<td>1 or 0</td>

<td>U8</td>
</tr>

<tr>
<td>sprmTTableHeader</td>

<td>186</td>

<td>tap.fTableHeader</td>

<td>1 or 0</td>

<td>U8</td>
</tr>

<tr>
<td>sprmTTableBorders</td>

<td>187</td>

<td>tap.rgbrcTable</td>

<td>complex(see below)</td>

<td>12 bytes</td>
</tr>

<tr>
<td>sprmTDefTable10</td>

<td>188</td>

<td>tap.rgdxaCenter, tap.rgtc</td>

<td>complex (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmTDyaRowHeight</td>

<td>189</td>

<td>tap.dyaRowHeight</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDefTable</td>

<td>190</td>

<td>tap.rgtc</td>

<td>complex (see below)</td>

<td></td>
</tr>

<tr>
<td>sprmTDefTableShd</td>

<td>191</td>

<td>tap.rgshd</td>

<td>complex (see below)</td>

<td></td>
</tr>

<tr>
<td>sprmTTlp</td>

<td>192</td>

<td>tap.tlp</td>

<td>TLP</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTSetBrc</td>

<td>193</td>

<td>tap.rgtc[].rgbrc</td>

<td>complex (see below)</td>

<td>5 bytes</td>
</tr>

<tr>
<td>sprmTInsert</td>

<td>194</td>

<td>tap.rgdxaCenter,tap.rgtc</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTDelete</td>

<td>195</td>

<td>tap.rgdxaCenter, tap.rgtc</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDxaCol</td>

<td>196</td>

<td>tap.rgdxaCenter</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTMerge</td>

<td>197</td>

<td>tap.fFirstMerged, tap.fMerged</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTSplit</td>

<td>198</td>

<td>tap.fFirstMerged, tap.fMerged</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTSetBrc10</td>

<td>199</td>

<td>tap.rgtc[].rgbrc</td>

<td>complex (see below)</td>

<td>5 bytes</td>
</tr>

<tr>
<td>sprmTSetShd</td>

<td>200</td>

<td>tap.rgshd</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmMax</td>

<td>208</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>

<p>The paragraph sprms used to encode paragraph properties in a PAPX are:
sprmPJc, sprmPFSideBySide, sprmPFKeep, sprmPFKeepFollow, sprmPFPageBreakBefore,
sprmPBrcp, sprmPPc, sprmPBrcl,sprmPNLvelAnm, sprmPFNoLineNumb, sprmPFSideBySide,sprmPDxaRight,
sprmPDxaLeft., sprmPDxaLeft1, sprmPDyaLine, sprmPDyaBefore, sprmPDyaAfter,
sprmPFNoAutoHyph,sprmPFInTable, sprmPFTtp, sprmPDxaAbs, sprmPDyaAbs, sprmPDxaWidth,
sprmPBrcTop, sprmPBrcLeft, sprmPBrcBottom, sprmPBrcRight, sprmPBrcBetween,
sprmPBrcBar, sprmPDxaFromText, sprmPDyaFromText, sprmPWr,sprmPWHeightAbs,
sprmPShd, sprmPDcs,sprmPAnld and sprmPChgTabsPapx.
<p>The table sprms used to encode table properties in a PAPX stored in
a PAPX FKP are: sprmTJc, sprmTDxaGapHalf, sprmTDyaRowHeight, sprmTDefTableShd
, and sprmTDefTable.
<p>The section sprms used to encode section properties in a SEPX are:
<br>sprmSBkc, sprmSFTitlePage, sprmSCcolumns, sprmSNfcPgn, sprmSPgnStart,
sprmSFAutoPgn, sprmSDyaPgn, sprmSDxaPgn, sprmSFPgnRestart, sprmSFEndnote,
sprmSLnc, sprmSGrpfIhdt, sprmSNLnnMod, sprmSDxaLnn, sprmSDyaHdrTop, sprmSDyaHdrBottom.
<p>sprmPIstdPermute (opcode 3) is a complex sprm which is applied to a
piece when the style codes of paragraphs within a piece must be mapped
to other style codes. It has the following format:
<br>&nbsp;
<p>&nbsp;&nbsp; Field&nbsp;&nbsp;&nbsp; Size&nbsp;&nbsp;&nbsp; Comment
<p>&nbsp;&nbsp; sprm&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; opcode( ==3)
<br>&nbsp;&nbsp; cch&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; count of
bytes (not including sprm and cch)
<br>&nbsp;&nbsp; fLongg&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; always
0
<br>&nbsp;&nbsp; fSpare&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; always
0
<br>&nbsp;&nbsp; istdFirst&nbsp;&nbsp;&nbsp; U16&nbsp;&nbsp;&nbsp; index
of first style in range to which permutation stored in rgistd applies
<br>&nbsp;&nbsp; istdLast&nbsp;&nbsp;&nbsp; U16&nbsp;&nbsp;&nbsp; index
of last style in range to which permutation stored in rgistd applies
<br>&nbsp;&nbsp; rgistd[]&nbsp;&nbsp;&nbsp; U16&nbsp;&nbsp;&nbsp; array
of istd entries that records the mapping of istds for text copied from
a source document to istds that exists in the destination document after
the text has been pasted
<br>&nbsp;
<p>To interpret sprmPIstdPermute, first check if pap.istd is greater than
the istdFirst recorded in the sprm and less than or equal to the istdLast
recorded in the sprm If not, the sprm has no effect. If it is, pap.istd
is set to rgistd[pap.istd - istdFirst]. sprmPIstdPermute is only stored
in <b>grpprls</b> linked to a piece table. It should never be recorded
in a PAPX.
<p>sprmPIncLvl (opcode 4) is applied to pieces in the piece table thatcontain
paragraphs with style codes
<br>(istds)greater thanor equal to1 and less than or equal to9. These style
codes identify heading levels in a Word outline structure. The sprm causes
a set of paragraphs to be changed to a new heading level. The sprm is two
bytes long and consists of the sprm code and a one byte two?s complement
value.
<p>If pap.stc is &lt; 1 or > 9, sprmPIncLvl has no effect. Otherwise, if
the value stored in the byte has its highest order bit off, the value is
a positive difference which should be added tofrom pap.istd and then pap.stc
should be set to min(pap.istd, 9). If the byte value has its highest order
bit on, the value is a negative difference which should be sign extended
to a word and then subtracted from pap.istd. Then pap.stc should be set
to max(1, pap.istd). sprmPIncLvl is only stored in <b>grpprls</b> linked
to a piece table.
<p>The sprmPAnld (opcode 12) sets the pap.anld which is a data structure
which describes what Word will display as an automatically generated sequence
number at the beginning of an autonumbered paragraph. See the description
of the ANLD in the data structure descriptions.
<p>The sprmPChgTabsPapx (opcode 15) is a complex sprm that describes changes
in tab settings from the underlying style. It is only stored as part of
PAPXs stored in <b>FKPs</b> and in the <b>STSH</b>. It has the following
format:
<p>&nbsp;&nbsp; Field&nbsp;&nbsp;&nbsp; Size&nbsp;&nbsp;&nbsp; Comment
<p>&nbsp;&nbsp; sprm&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; opcode
<br>&nbsp;&nbsp; cch&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; count of
bytes (not including sprm and cch)
<br>&nbsp;&nbsp; itbdDelMax&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; number
of tabs to delete
<br>&nbsp;&nbsp; rgdxaDel&nbsp;&nbsp;&nbsp; int[itbdDelMax]&nbsp;&nbsp;&nbsp;
array of tab positions for which tabs should be deleted
<br>&nbsp;&nbsp; itbdAddMax&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; number
of tabs to add
<br>&nbsp;&nbsp; rgdxaAdd&nbsp;&nbsp;&nbsp; int[itbdAddMax]&nbsp;&nbsp;&nbsp;
array of tab positions for which tabs should be added
<br>&nbsp;&nbsp; rgtbdAdd&nbsp;&nbsp;&nbsp; byte[itbdAddMax]&nbsp;&nbsp;&nbsp;
array of tab descriptors corresponding to rgdxaAdd
<p>WhensprmPChgTabsPapx is interpreted, the rgdxaDel of the sprm is applied&nbsp;
first to the pap that is being transformed. This is done by deleting from&nbsp;
the pap the rgdxaTab entry and rgtbd entry of any tab whose rgdxaTab value&nbsp;
is equal to one of the rgdxaDel values in the sprm. It is guaranteed that&nbsp;
the entries in pap.rgdxaTab and the sprm?s rgdxaDel and rgdxaAdd are recorded&nbsp;
in ascending dxa order.
<p>Then the rgdxaAdd and rgtbdAdd entries are merged into the pap?s rgdxaTab
and rgtbd arrays so that the resulting pap rgdxaTab is sorted in ascending
order with no duplicates.
<p>sprmPNest (opcode 18) causes its operand, a two-byte dxa value to be
added to pap.dxaLeft. If the result of the addition is less than 0, 0 is
stored into pap.dxaLeft. It is used to shift the left indent of a paragraph
to the right or left. sprmPNest is only stored in <b>grpprls</b> linked
to a piece table.
<p>sprmPDyaLine (opcode 20) moves a 4 byte LSPD structure into pap.lspd.
Two short fields are stored in this data structure. The first short in
the structure is named lspd.dyaLine and the second is named lspd.fMultLinespace.
When lspd.fMultLinespace is 0, the magnitude of lspd.dyaLine specifies
the amount of space that will be provided for lines in the paragraph in
twips. When lspd.dyaLine is positive, Word will ensure that AT LEAST the
magnitude of lspd.dyaLine will be reserved on the page for each line displayed
in the paragraph. If the height of a line becomes greater than lspd.dyaLine,
the size calculated for that line will be reserved on the page. When lspd.dyaLine
is negative, Word will ensure that EXACTLYthe magnitude of lspd.dyaLine
(-lspd.dyaLine) will be reserved on the page for each line displayed in
the paragraph. When lspd.fMultLinespace is 1, Word will reserve for each
line the (maximal height of the line*lspd.dyaLine)/240.
<p>The sprmPChgTabs (opcode 23) is a complex sprm which describes changes&nbsp;
tab settings for any paragraph within a piece. It is only stored as part
of a <b>grpprl</b> linked to a piece table. It has the following format:
<br>&nbsp;
<p>&nbsp;&nbsp; Field&nbsp;&nbsp;&nbsp; Size&nbsp;&nbsp;&nbsp; Comment
<br>&nbsp;&nbsp; sprm&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; opcode
<br>&nbsp;&nbsp; cch&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; count of
bytes (not including sprm and cch)
<br>&nbsp;&nbsp; itbdDelMax&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; number
of tabs to delete
<br>&nbsp;&nbsp; rgdxaDel&nbsp;&nbsp;&nbsp; int[itbdDelMax]&nbsp;&nbsp;&nbsp;
array of tab positions for which tabs should be deleted
<br>&nbsp;&nbsp; rgdxaClose&nbsp;&nbsp;&nbsp; int[itbdDelMax]&nbsp;&nbsp;&nbsp;
array of tolerances corresponding to rgdxaDel where each tolerance defines
an interval around corresponding rgdxaDel entry within which all tabs should
be removed
<br>&nbsp;&nbsp; itbdAddMax&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; number
of tabs to add
<br>&nbsp;&nbsp; rgdxaAdd&nbsp;&nbsp;&nbsp; int[itbdAddMax]&nbsp;&nbsp;&nbsp;
array of tab positions for which tabs should be added
<br>&nbsp;&nbsp; rgtbdAdd&nbsp;&nbsp;&nbsp; byte[itbdAddMax]&nbsp;&nbsp;&nbsp;
array of tab descriptors corresponding to rgdxaAdd
<br>&nbsp;
<p>itbdDelMax and itbdAddMax are defined to be equal to 50. This means
that the largest possible instance of sprmPChgTabs is 354. When the length
of the sprm is greater than or equal to 255, the cch field will be set
equal to 255. When cch == 255, the actual length of the sprm can be calculated
as follows: length= 2 + itbdDelMax * 4 + itbdAddMax * 3.
<p>WhensprmPChgTabs is interpreted, the rgdxaDel of the sprm is applied
first to the pap that is being transformed. This is done by deleting from
the pap the rgdxaTab entry and rgtbd entry of any tab whose rgdxaTab value
is within the interval [rgdxaDel[i] - rgdxaClose[i], rgdxaDel[i] + rgdxaClose[i]]
It is guaranteed that the entries in pap.rgdxaTab and the sprm?s rgdxaDel
and rgdxaAdd are recorded in ascending dxa order.
<p>Then the rgdxaAdd and rgtbdAdd entries are merged into the pap?s rgdxaTab
and rgtbd arrays so that the resulting pap rgdxaTab is sorted in ascending
order with no duplicates.
<p>The sprmPPc (opcode 29) is a complex sprm which describes changes in
the pap.pcHorz and pap.pcVert. Itis able to change both fields? contents
in parallel. It has the following format:
<br>&nbsp;
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sprm</td>

<td>U8</td>

<td></td>

<td></td>

<td>opcode</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>reserved</td>

<td>U16</td>

<td>:4</td>

<td>F0</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcVert</td>

<td>U16</td>

<td>:2</td>

<td>0C</td>

<td>if pcVert ==3, pap.pcVert should not be changed. Otherwise, contains
new value of pap.pcVert.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcHorz</td>

<td>U16</td>

<td>:2</td>

<td>03</td>

<td>if pcHorz==3, pap.pcHorz should not be changed. Otherwise, contains
new value of pap.pcHorz.</td>
</tr>
</table>
Length of sprmPPc is two bytes.
<p>sprmPPc is interpreted by moving pcVert to pap.pcVert if pcVert != 3
and by moving pcHorz to pap.pcHorz if pcHorz != 3. sprmPPc is stored in
PAPX FKPs and also in <b>grpprls</b> linked to piece table entries.
<p>sprmCPicLocation (opcode 68) is used ONLY IN CHPX FKPs. This sprm moves
the 4 bytes of data stored at offset 2 in the sprm into the chp.fcPic field.
It simultaneously sets chp.fSpec to 1. This sprm is also when the chp.lTagObj
field that is unioned with chp.fcPic is to be set for OLE objects.
<p>sprmCChse (opcode 73) is used to record a character set id for text
that was pasted into the Word document that used a character set different
than Word?s default character set. When chp.fChsDiff is 0, the character
set used for a run of text is the default character set for the version
of Word that last saved the document. When chp.fChsDiff is 1, chp.chse
specifies the character set used for this run of text. When this sprm is
interpreted, the byte at offset 1 in the sprm is moved to chp.fChsDiff
and the word stored at offset 2 is moved to chp.chse.
<p>sprmCSymbol (opcode 74) is used to specify the font and the character
that will be used within that font to display a symbol character in Word.The
length byte recorded at offset 1 in this sprm will always be 3. When this
sprm is interpreted the two byte font code recorded at offset 2 is moved
to chp.ftcSym, the single byte character specifier recorded at offset 4
is moved to chp.chSym and chp.fSpec is set to 1.
<p>sprmCIstdPermute (opcode 81) (which has the same format as sprmPIstdPermute&nbsp;
(opcode 3)). is a complex sprm which is applied to a piece when the style&nbsp;
codes for character styles tagging character runs within a piece must be
mapped to other style codes. It has the following format:
<br>&nbsp;
<p>&nbsp;&nbsp; Field&nbsp;&nbsp;&nbsp; Size&nbsp;&nbsp;&nbsp; Comment
<p>&nbsp;&nbsp; sprm&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; opcode( ==81)
<br>&nbsp;&nbsp; cch&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; count of
bytes (not including sprm and cch)
<br>&nbsp;&nbsp; fLongg&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; always
0
<br>&nbsp;&nbsp; fSpare&nbsp;&nbsp;&nbsp; byte&nbsp;&nbsp;&nbsp; always
0
<br>&nbsp;&nbsp; istdFirst&nbsp;&nbsp;&nbsp; U16&nbsp;&nbsp;&nbsp; index
of first style in range to which permutation stored in rgistd applies
<br>&nbsp;&nbsp; istdLast&nbsp;&nbsp;&nbsp; U16&nbsp;&nbsp;&nbsp; index
of last style in range to which permutation stored in rgistd applies
<br>&nbsp;&nbsp; rgistd[]&nbsp;&nbsp;&nbsp; U16&nbsp;&nbsp;&nbsp; array
of istd entries that records the mapping of istds for text copied from
a source document to istds that exists in the destination document after
the text has been pasted
<br>&nbsp;
<p>To interpret sprmCIstdPermute, first check if chp.istd is greater than&nbsp;
the istdFirst recorded in the sprm and less than or equal to the istdLast&nbsp;
recorded in the sprm If not, the sprm has no effect. If it is, chp.istd
is set to rgstd[chp.istd - istdFirst] and any chpx stored in that rgstd
entry is applied to the chp. sprmCIstdPermute is only stored in <b>grpprls</b>
linked to a piece table. It should never be recorded in a CHPX.
<p>Note that it is possible that an istd may be recorded in the rgistd
that refers to a paragraph style. This will no harmful consequences since
the istd for a paragraph style should never be recorded in chp.istd.
<p>sprmCDefault (opcode 82) clears the fBold, fItalic, fOutline,fStrike,
fShadow, fSmallCaps, fCaps, fVanish, kul and ico fields of the chp to 0.
It was first defined for Word 3.01 and had to be backward compatible with
Word 3.00 so it is a variable length sprm whose count of bytes is 0. It
consists of the sprmCDefault opcode followed by a byte of 0. sprmCDefaultis
stored only in
<b>grpprls</b> linked to piece table entries.
<p>sprmCPlain (opcode 83) is used to make the character properties of runs
of text equal to the style character properties of the paragraph that contains
the text. When Word interprets this sprm, the style sheet CHP is copied
over the original CHP preserving the fSpec setting from the original CHP.
sprmCPlainis stored only in <b>grpprls</b> linked to piece table entries.
<p>sprms 85 through 92 (sprmCFBold through sprmCFVanish) set single bit
properties in the CHP. When the parameter of the sprm is set to 0 or 1,
then the CHP property is set to the parameter value.
<p>When the parameter of the sprm is 128, then the CHP property is set
to the value that is stored for the property in the style sheet. CHP When
the parameter of the sprm is 129, the CHP property is set to the negation
of the value that is stored for the property in the style sheet CHP. sprmCFBold
through sprmCFVanish are stored only in <b>grpprls</b> linked to piece
table entries.
<p>sprmCSizePos (opcode 95) is a four byte sprm consisting of the sprm
opcode and a three byte parameter. The sprm has the following format:
<br>&nbsp;
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sprm</td>

<td>U8</td>

<td></td>

<td></td>

<td>opcode</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>hpsSize</td>

<td>U16</td>

<td>:8</td>

<td>FF</td>

<td>when != 0, contains new size of chp.hps</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cInc</td>

<td>U16</td>

<td>:7</td>

<td>FE</td>

<td>contains the number of font levels to increase or decrease size of
chp.hps as a twos complement value.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAdjust</td>

<td>U16</td>

<td>:1</td>

<td>01</td>

<td>when == 1, means that chp.hps should be adjusted up/down by one font
level for super/subscripting change</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>hpsPos</td>

<td>U16</td>

<td>:8</td>

<td>FF</td>

<td>when != 128, contains super/subscript position as a twos complement
number</td>
</tr>
</table>

<p>When Word interprets this sprm, if hpsSize != 0 then chp.hps is set
to hpsSize. If cInc is != 0, the cInc is interpreted as a 7 bittwos complement
number and the procedure described below for interpreting sprmCHpsInc is
followed to increase or decrease the chp.hps by the specified number of
levels. If hpsPos is != 128, then chp.hpsPos is set equal to hpsPos. If
fAdjust is on , hpsPos != 128 and hpsPos != 0 and the previous value of
chp.hpsPos == 0, then chp.hps is reduced by one level following the method
described for sprmCHpsInc. If fAdjust is on, hpsPos == 0 and the previous
value of chp.hpsPos != 0, then the chp.hps value is increased by one level
using the method described below for sprmCHpsInc.
<p>sprmCHpsInc(opcode 100) is a two-byte sprm consisting of the sprm opcode
and a one-byte parameter. Word keeps an ordered array of the font sizes
that are defined for the fonts recorded in the system file with each font
size transformed into an hps. The parameter is a one-byte twos complement
number. Word uses this number to calculate an index in the font size array
to determine the new hps for a run. When Word interprets this sprm and
the parameter is positive, it searches the array of font sizes to find
the index of the smallest entry in the font size table that is greater
than the current chp.hps.It then adds the parameter minus 1 to the index
and maxes this with theindex of the last array entry. It uses the result
as an index into the font size array and assigns that entry of the array
to chp.hps.
<p>When the parameter is negative, Word searches the array of font sizes
to find the index of the entry that is less than or equal to the current
chp.hps. It then adds the negative parameter to the index and does a min
of the result with 0. The result of the min function is used as an index
into the font size array and that entry of the array is assigned to chp.hps.
sprmCHpsInc is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmCHpsPosAdj (opcode 102) causes the hps of a run to be reduced the
first time time text is superscripted or subscripted and causes the hps
of a run to be increased when superscripting/subscripting is removed from
a run. The one byte parameter of this sprm is the new hpsPos value that
is to be stored in chp.hpsPos. If the new hpsPos is not equal 0 (meaning
that the text is to be super/subscripted), Word first examines the current
value of chp.hpsPos to see if it is equal to 0. If so, Word uses the algorithm
described for sprmCHpsInc to decrease chp.hps by one level. If the new
hpsPos== 0 (meaning the text is not super/subscripted), Word examines the
current chp.hpsPos to see if it is not equal to 0. If it is not (which
means text is being restored to normal position), Word uses the sprmCHpsInc
algorithm to increase chp.hps by one level. After chp.hps is adjusted,
the parameter value is stored in chp.hpsPos. sprmCHpsPosAdj is stored only
in <b>grpprls</b> linked to piece table entries.
<p>The parameter of sprmCMajority (opcode 103) is itself a list of character
sprms
<br>which encodes a criterion under which certain fields of the chp are
to be set equal to the values stored in a style?s CHP. Byte 0 of sprmCMajority
contains the opcode, byte 1 contains the length of the following list of
character sprms. . Word begins interpretation of this sprm by applying
the stored character sprm list to a standard chp. That chp has chp.istd
= istdNormalChar. chp.hps=20, chp.lid=0x0400and chp.ftc = 4. WordthencomparesfBold,
fItalic, fStrike, fOutline, fShadow, fSmallCaps, fCaps, ftc, hps, hpsPos,
kul, qpsSpace and ico in the original CHP with the values recorded for
these fields in the generated CHP.. If a field in the original CHP has
the same value as the field stored in the generated CHP, then that field
is reset to the value stored in the style?s CHP. If the two copies differ,
then the original CHP value is left unchanged. sprmCMajority is stored
only in <b>grpprls</b> linked to piece table entries.
<p>sprmCHpsInc1 (opcode 106) is used to increase or decrease chp.hps by
increments of 1. This sprm is interpreted by adding the two byte increment
stored at byte 2 of the sprm to chp.hps. If this result is less than 8,
the chp.hps is set to 8. If the result is greater than 32766, the chp.hps
is set to 32766.
<p>sprmCMajority50 (opcode 108) has the same format as sprmCMajority and
is interpreted in the same way.
<p>sprmPicScale (opcode 120) is used to scale the x and y dimensions of
a Word picture and to set the cropping for each side of the picture. The
sprm begins with the one byte opcode, followed by the length of the parameter
(always 12) stored in a byte. The 12-byte long operand consists of an array
of 6 two-byte integer fields. The 0th integer contains the new setting
for pic.mx. The 1st integer contains the new setting for pic.my. The 2nd
integer contains the new setting for pic.dxaCropLeft. The 3rd integer contains
the new setting for pic.dyaCropTop. The 4th integer contains the new setting
for pic.dxaCropRight. The 5th integer contains the new setting of pic.dxaCropBottom.
sprmPicScale is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmTDxaLeft (opcode 183) is called to adjust the x position within
a column which marks the left boundary of text within the first cell of
a table row.This sprm causes a whole table row to be shifted left or right
within its column leaving the horizontal width and vertical height of cells
in the row unchanged. Byte 0 of the sprm contains the opcode, and the new
dxa position, call it dxaNew, is stored as an integer in bytes 1 and 2.
Word interprets this sprm by adding
<br>dxaNew - (rgdxaCenter[0] + tap.dxaGapHalf) to every entry of tap.rgdxaCenter
whose index is less than tap.itcMac. sprmTDxaLeft is stored only in <b>grpprls</b>
linked to piece table entries.
<p>sprmTDxaGapHalf (opcode 184) adjusts the white space that is maintained
between columns by changing tap.dxaGapHalf. Because we want the left boundary
of text within the leftmost cell to be at the same location after the sprm
is applied, Word also adjusts tap.rgdxCenter[0] by the amount that tap.dxaGapHalf
changes. Byte 0 of the sprm contains the opcode, and the new dxaGapHalf,
call it dxaGapHalfNew, is stored in bytes 1 and 2. When the sprm is interpreted,
the change between the old and new dxaGapHalf values, tap.dxaGapHalf -
dxaGapHalfNew, is added to tap.rgdxaCenter[0] and thendxaGapHalfNew is
moved to tap.dxaGapHalf. sprmTDxaGapHalf is stored in PAPXs and also in
<b>grpprls</b>
linked to piece table entries.
<p>sprmTTableBorders (opcode 187) sets the tap.rgbrcTable. The sprm is
interpreted by moving 12 bytes beginning at byte 1 of the sprm to tap.rgbrcTable.
<p>sprmTDefTable10 (opcode 188) is an obsolete version of sprmTDefTable&nbsp;
(opcode 154) that was used in WinWord 1.x.Its contents are identical to
those in sprmTDefTable, except that the TC structures contain the obsolete
structures BRC10s.
<p>sprmTDefTable (opcode 190) defines the boundaries of table cells (tap.rgdxaCenter)
and the properties of each cell in a table (tap.rgtc). The 0th byte of
the sprm contains its opcode. Bytes 1 and 2 store a two-byte length of
the following paramter. Byte 3 contains the number of cells that are to
be defined by the sprm, call it itcMac.When the sprm is interpreted, itcMac
is moved to tap.itcMac. itcMac cannot be larger than 32. In bytes 4 through
4+2*(itcMac + 1) -1 , is stored an array of integer dxa values sorted in
ascending order which will be moved to tap.rgdxaCenter. In bytes 4+ 2*(itcMac
+ 1) through byte 4+2*(itcMac + 1) + 10*itcMac - 1 is stored an array of
TC entries corresponding to the stored tap.rgdxaCenter. This array is moved
to tap.rgtc. sprmTDefTable is only stored in PAPXs.
<p>sprmTDefTableShd (opcode 191) is similar to sprmTDefTable, and compliments
it by defining the shading of each cell in a table (tap.rgshd).The 0th
byte of the sprm contains its opcode. Bytes 1 and 2 store a two-byte length
of the following paramter. Byte 3 contains the number of cells that are
to be defined by the sprm, call it itcMac.itcMac cannot be larger than
32. In bytes 4 through 4+2*(itcMac + 1) -1 , is stored an array of SHDs.This
array is moved to tap.rgshd.sprmTDefTable is only stored in PAPXs.
<p>sprmTSetBrc (opcode 193) allows the border definitions(BRCs) within
TCs to be set to new values. It has the following format:
<br>&nbsp;
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sprm</td>

<td>U8</td>

<td></td>

<td></td>

<td>opcode 193</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>itcFirst</td>

<td>U8</td>

<td></td>

<td></td>

<td>the index of the first cell that is to have its borders changed.</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>itcLim</td>

<td>U8</td>

<td></td>

<td></td>

<td>index of the cell that follows the last cell to have its borders changed</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td></td>

<td>U16</td>

<td>:4</td>

<td>F0</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeRight</td>

<td>U16</td>

<td>:1</td>

<td>08</td>

<td>=1 when tap.rgtc[].brcRight is to be changed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeBottom</td>

<td>U16</td>

<td>:1</td>

<td>04</td>

<td>=1 when tap.rgtc[].brcBottom is to be changed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeLeft</td>

<td>U16</td>

<td>:1</td>

<td>02</td>

<td>=1 when tap.rgtc[].brcLeft is to be changed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeTop</td>

<td>U16</td>

<td>:1</td>

<td>01</td>

<td>=1 when tap.rgtc[].brcTop is to be changed</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>brc</td>

<td>BRC</td>

<td></td>

<td></td>

<td>new BRC value to be stored in TCs.</td>
</tr>
</table>

<p>This sprm changes the brc fields selected by the fChange* flags in the
sprm to the brc value stored in the sprm, for every tap.rgtc entry whose
index is greater than or equal to itcFirst and less than itcLim.sprmTSetBrc
is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmTInsert (opcode 194) inserts new cell definitions in an existing
table?s cell structure. The 0th byte of the sprm contains the opcodeByte
1 is the index within tap.rgdxaCenter and tap.rgtc at which the new dxaCenter
and tc values will be inserted. Call this index itcInsert. Byte 2 contains
a count of the cell definitions to be added to the tap, call it ctc. Bytes
3 and 4 contain the width of the cells that will be added, call it dxaCol.
If there are already cells defined at the index where cells are to be inserted,
tap.rgdxaCenter entries at or above this index must be moved to the entry
ctc higher and must be adjusted by adding ctc*dxaCol to the value stored.
The contents of tap.rgtc at or above the index must be moved 10*ctc bytes
higher in tap.rgtc. If itcInsert is greater thanthe original tap.itcMac,
itcInsert - tap.ctc columns beginning with index tap.itcMac must be added
of width dxaCol (loop from itcMac to itcMac+itcInsert-tap.ctc adding dxaCol
to the rgdxaCenter value of the previous entry and storing sum as dxaCenter
of new entry), whose TC entries are cleared to zeros. Beginning with index
itcInsert, ctc columns of widthdxaCol must be added by constructing new
tap.rgdxaCenter and tap.rgtc entrieswith the newly defined rgtc entries
cleared to zeros. Finally, the number of cells that were added to the tap
is added to tap.itcMac. sprmTInsert is stored only in <b>grpprls</b> linked
to piece table entries.
<p>sprmTDelete (opcode 195) deletes cell definitions from an existing table?s
cell structure. The 0th byte of the sprm contains the opcode. Byte 1 contains
the index of the first cell to delete, call it itcFirst. Byte 2 contains
the index of the cell that follows the last cell to be deleted, call it
itcLim. sprmTDelete causes any rgdxaCenter and rgtc entries whose index
is greater than or equal to itcLim to be moved to the entry that is itcLim
- itcFirstlower, and causes tap.itcMac to be decreased by the number of
cells deleted. sprmTDelete is stored only in <b>grpprls</b> linked to piece
table entries.
<p>sprmTDxaCol (opcode 196) changes the width of cells whose index is within
a certain range to be a certain value. The 0th byte of the sprm contains
the opcode. Byte 1 contains the index of the first cell whose width is
to be changed, call it itcFirst. Byte 2 contains the index of the cell
that follows the last cell whose width is to be changed, call it itcLim.
Bytes 3 and 4 contain the new width of the cell, call it dxaCol. This sprm
causes the itcLim - itcFirst entries of tap.rgdxaCenter to be adjusted
so thattap.rgdxaCenter[i+1] = tap.rgdxaCenter[i] + dxaCol. Any tap.rgdxaCenter
entries that exist beyond itcLim are adjusted to take into account the
amount added to or removed from the previous columns.sprmTDxaCol is stored
only in <b>grpprls</b> linked to piece table entries.
<p>sprmTMerge (opcode 197) merges the display areas of cells within a specified
range. The 0th byte of the sprm contains the opcode. Byte 1 contains the
index of the first cell that is to be merged, call it itcFirst. Byte 2
contains the index of the cell that follows the last cell to be merged,
call it itcLim. This sprm causes tap.rgtc[itcFirst].fFirstMerged to be
set to 1. Cells in the range whose index is greater than itcFirst and less
than itcLim have tap.rgtc[].fMerged set to 1. sprmTMerge is stored only
in <b>grpprls</b> linked to piece table entries.
<p>sprmTSplit (opcode 198) splits the display areas of merged cells into
their originally assigned display areas. The 0th byte of the sprm contains
the opcode. Byte 1 contains the index of the first cell that is to be split,
call it itcFirst. Byte 2 contains the index of the cell that follows the
last cell to be split, call it itcLim. This sprm clears tap.rgtc[].fFirstMerged
and tap.rgtc[].fMerged for all rgtc entries >= itcFirst and &lt; itcLim.
sprmTSplit is stored only in <b>grpprls</b> linked to piece table entries.
<p><u>SprmTSetBrc10 (opcode 199) has the same format as SprmTSetBrc&nbsp;
but uses the old BRC10 structure.</u>
<p>sprmTSetShd (opcode 200) allows the shading definitions(SHDs) within
a tap to be set to new values. The 0th byte of the sprm contains the opcode.
Byte 1 contains the index of the first cell whose shading is to be changed,
call it itcFirst. Byte 2 contains the index of the cell that follows the
last cell whose shading is to be changed, call it itcLim. Bytes 3 and 4
contain the SHD structure, call it shd. This sprm causes the itcLim - itcFirst
entries of tap.rgshd to be set to shd. sprmTDxaCol is stored only in <b>grpprls</b>
linked to piece table entries.
<h1>
COMPLEX FILE FORMAT</h1>
The complex file format is used when a file is fast-saved. A complex file
has fib.fComplex set to 1. In a complex file, fcClx is the fc where the
complex part of the file begins, and cbClx is the size (in bytes) of the
complex part. The complex part of the file contains a group of <b>grpprl</b>s
that encode formatting changes made by the user and a piece table (<b>plcfpcd</b>
). The piece table is needed because the text of the document is not stored
contiguously in the file after a fast save.
<p>The complex part of a file (<b>CLX</b>) is composed of a number of variable-sized
blocks of data. Recorded first are any <b>grpprls</b> that may be referenced
by the <b>plcfpcd </b>(if the <b>plcfpcd </b>has no <b>grpprl</b> references,
no <b>grpprls</b> will be recorded) followed by the <b>plcfpcd</b>. Each
block in the complex part is prefaced by a <b>clxt</b> (<b>clx t</b>ype),
which is a 1-byte code, either 1 (meaning the block contains a <b>grpprl</b>)
or 2 (meaning this is the <b>plcfpcd</b>).In both cases, the <b>clxt</b>
is followed by a 2-byte cb which is the count of bytes of the <b>grpprl</b>
or the piece table.So the formats of the two types of blocks are:
<p>clxt = 1clxtGrpprl
<br>cbcount of bytes in grpprl
<br>grpprlsee "<b>Definitions</b>" for description of grpprl; a grpprl
can contain sprms modifying character, paragraph, table, section or picture
properties
<p>or
<p>clxt = 2clxtPlcfpcd
<br>cbcount of bytes in piece table
<br>plcfpcdpiece table
<p>The entire CLXwould look like this, depending on the number of grpprl's:
<p>clxtGrpprl
<br>cb
<br>grpprl (0th grpprl)
<br>clxtGrpprl
<br>cb
<br>grpprl (1st grpprl)
<br>...
<br>clxtPlcfpcd
<br>cb
<br>plcfpcd
<p>When the <b>prm</b> in <b>pcd</b>s stored in the <b>plcfpcd</b>, contains
an igrpprl (index to a grpprl), the index stored is the order in which
that grpprl was stored in the <b>CLX</b>.
<h2>
Algorithm to determine the&nbsp; bounds of a paragraph containing a certain
character in a complex file</h2>
When a document is recorded in non-complex format, the bounds of the paragraph
that contains a particular character can be found by calculating the <b>FC</b>
coordinate of the character, searching the bin table to find an FKP page
that describes that <b>FC</b>, fetching that FKP, and then searching the
FKP to find the interval in the <b>rgfc </b>that encloses the character.
The bounds of the interval are the fcFirst and fcLim of the containing
paragraph. Every character greater than or equal to fcFirst and less than
fcLim is part of the containing paragraph.
<p>When a document is recorded in complex format, a piece that was originally
part of one paragraph can be copied or movedwithin a different paragraph.
To find the beginning of the paragraph containing a character in a complex
document, it?s first necessary to search for the piece containing the character
in the piece table. Then calculate the <b>FC</b> in the file that stores
the character from the piece table information. Using the <b>FC</b>, search
the FCs FKP for the largest FC less than the character?s FC, call it fcTest.
If the character atfcTest-1 is contained in the current piece, then the
character corresponding to that FC in the piece is the first character
of the paragraph. If that FC is before or marks the beginning of the piece,
scan a piece at a time towards the beginning of the piece table until a
piece is found that contains a paragraph mark. This can be done by using
the end of the piece FC, finding the largest FC in its FKP that is less
than or equal to the end of piece FC, and checking to see if the character
in front of the FKP FC (which must mark a paragraph end) is within the
piece. When such an FKP FC is found, the FC marks the first byte of paragraph
text.
<p>To find the end of a paragraph for a character in a complex format file,
again it is necessary to know the piece that contains the character and
the FC assigned to the character. Using the FC of the character, first
search the FKP that describes the character to find the smallest FC in
the rgfc that is larger than the character FC. If the FC found in the FKP
is less than or equal to the limit FC of the piece, the end of the paragraph
that contains the character is at the FKP FC minus 1. If the FKP FC that
was found was greater than the FC of the end of the piece, scan piece by
piece toward the end of the document until a piece is found that contains
a paragraph end mark. It?s possible to check if a piece contains a paragraph
mark by using the FC of the beginning of the piece to search in the FKPs
for the smallest FC in the FKP rgfc that is greater than the FC of the
beginning of the piece. If the FC found is less than or equal to the limit
FC of the piece, then the character that ends the paragraph is the character
immediately before the FKP FC.
<p>A special procedure must be followed to locate the last paragraph of
the main document text when footnote or header/footer text is saved in
a Word file (ie. when fib.ccpFtn != 0 or fib.ccpHdr != 0).
<p>In this case the CP of that paragraph mark is fib.ccpText + fib.ccpFtn
+ fib.ccpHdr + fib.ccpMcr + fib.ccpAtn and the limit CP of the entire plcfpcd
is fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpMcr + fib.ccpAtn + 1.
<h2>
Algorithm to determine&nbsp; paragraph properties for a paragraph in a
complex file</h2>
Having found the index <b>i </b>of the FC in an FKP that marks the character
stored in the file immediately after the paragraph?s paragraph mark, it
is necessary to use the word offset stored in the first byte of the fkp.rgbx[<b>
i - 1</b>] to find the PAPX for the paragraph. Using papx.istd to index
into the properties stored for the style sheet , the paragraph properties
of the style are copied to a local PAP. Then the grpprl stored in the PAPX
is applied to the local PAP, and papx.istd along with fkp.rgbx.phe are
moved into the local PAP. The process thus far has created a PAP that describes
what the paragraph properties of the paragraph were at the lastfull save.
Now it?s necessary to apply any paragraph sprms that were linked to the
piece that contains the paragraph?s paragraph mark. If pcd.prm.fComplex
is 0, pcd.prm contains 1 sprm which should only be applied to the local
PAP if it is a paragraph sprm. If pcd.prm.fComplex is 1, pcd.prm.igrpprl
is the index of a grpprl in the CLX. If that grpprl contains any pargraph
sprms, they should be applied to the local PAP. After applying all of the
sprms for the piece, the local PAP contains the correct paragraph property
values.
<h2>
Algorithm to determine table properties for a table row in a complex file</h2>
To determine the table properties for a table row in a complex file,scan
paragraph-by-paragraph toward the end of the table row, until a paragraph
is found that has pap.fTtp set to 1. This paragraph consists of a single
row end character. This row end character is linked to the table properties
of the row. To create the TAP for the table row, clear a local TAP to zeros.
Then the PAPX for the row end character must be fetched from an FKP, and
the table sprms that are stored in this PAPX must be applied to the local
TAP. The process thus far has created a TAP that describes what the table
properties of the table row were atthe last full save. Now apply any table
sprms that were linked to the piece that contains the table row?s row end
character. If pcd.prm.fComplex is 0, pcd.prm contains 1 sprm which should
be applied to the local TAP if it is a table sprm. If pcd.prm.fComplex
is 1, pcd.prm.igrpprl is the index of a grpprl in the CLX. If that grpprl
contains any table sprms, apply them to the local TAP. After all of the
sprms for the piece are applied, the local TAP contains the correct table
property values for the table row.
<h2>
Algorithm to determine the character properties of a character in a complex
file</h2>
It is first necessary to fetch the paragraph properties of the paragraph
that contains the character. The pap.istd of the fetched properties specifies
which style sheetentry provides the defaultcharacter properties for the
character. The character properties recorded in the style sheet for that
style are copied into a local CHP. Then, the piece containing the character
is located in the piece table (plcfpcd) and the fc of the character is
calculated. Using the character?s FC, the page number of the CHPX FKP that
describes the character is found by searching the bin table (hplcfbteChpx).
The CHPX FKP stored in that page is fetched and then the rgfc in the FKP
is searched to locate the bounds of the run of exception text that encompasses
the character. The CHPX for that run is then located within the FKP, and
the CHPX is applied to the contents of the local CHP. The process thus
far has created a CHP that describes what the character properties of the
character were at the last full save.Now apply any character sprms that
were linked to the piece that contains the character. If pcd.prm.fComplex
is 0, pcd.prm contains 1 sprm which should be applied to the local CHP
if it is a character sprm. If pcd.prm.fComplex is 1, pcd.prm.igrpprl is
the index of a grpprl in the CLX. If that grpprl contains any character
sprms, apply them to the local CHP. After applying all of the sprms for
the piece,the local CHP contains the correct properties for the character.
<p>Characters that are within the same piece, same paragraph, and same
run of exception text are guaranteed to have the same properties. This
fact can be used to construct a scanner that can return the limit CPs and
properties of a sequence of characters that all have the same properties.
<h2>
Algorithm to determine the&nbsp; section properties of a section in a complex
file</h2>
To determine which section a character belongs to and what its section
properties are, it is necessary to use the CP of the character to search
the <b>plcfsed</b> for the index <b>i </b>of the largest CP that is less
than or equal to the character?s CP. plcfsed.rgcp[<b>i</b>] is the CP of
the first character of the section and plcfsed.rgcp[<b>i+1</b>] is the
CP of the character following the section mark that terminates the section
(call it cpLim). Then retrieve plcfsed.rgsed[<b>i</b>]. The FC in this
SED gives the location where the SEPX for the section is stored. Then create
a local SEP with default section properties. If the sed.fc != 0xFFFFFFFF,
then the sprms within the SEPX that is stored at offset sed.fc must be
applied to the local SEP. The process thus far has created a SEP that describes
what the section properties of the section at the last full save. Now apply
any section sprms that were linked to the piece that contains the section?s
section mark. If pcd.prm.fComplex is 0, pcd.prm contains 1 sprm which should
be applied to the local SEP if it is a section sprm. If pcd.prm.fComplex
is 1, pcd.prm.igrpprl is the index of a grpprl in the CLX. If that grpprl
contains any section sprms, they should be applied to the local SEP. After
applying all of the section sprms for the piece , the local SEP contains
the correct section properties.
<h2>
Algorithm to determine the&nbsp; pic of a picture in a complex file.</h2>
The picture sprms contained in the prm's grpprl apply to any picture characters
within the piece that have their chp.fSpec character == fTrue. The picture
properties for a picture (the PIC described in the Structure Definitions)
are derived by fetching the PIC stored with the picture and applying to
that PIC any picture sprms linked to the piece containing the picture special
character.
<h1>
FOOTNOTES</h1>
In Windows Word the text of a footnote is anchored to a particular position
within the document?s main text , the location of its footnote reference.
There is a structure referenced by the fib, the plcffndRef, which records
the locations of the footnote references within the main text address space
and another structure referenced by the fib, the plcffndTxt, which records
the beginning locations of corresponding footnote text within the footnote
text address space . The footnote text characters in a full saved file
begin atat offset fib.fcMin + fib.ccpText and extends till fib.fcMin +
fib.ccpText + fib.ccpFtn. In a complex fast-saved document , the footnote
text begins atCP fib.ccpText and extends till fib.ccpText + fib.ccpFtn.
To find the location of the <b>ith</b> footnote reference in the main text
address space, look up the <b>ith</b> entry in the plcffndRef and find
the location of the text coresponding to the reference within the footnote
text address space by looking up the <b>ith</b> entry in the plcffndTxt.
<p>When there are <b>n</b> footnotes, the plcffndTxt structure consists
of
<b>n+2 </b>CP entries. The CP entries mark the beginning character position
within the footnote text address space of the footnote text for the footnotes
defined for the file. The beginning CP of the text of the <b>ith </b>footnote
is the <b>ith </b>CP within the plcffndTxt. The limit CP of the text of
the
<b>ith </b>footnote is the <b>i+1st</b> CP within the plcffndTxt.
<p>The last character of footnote text for a footnote (ie. the character
at limit CP - 1) is always a paragraph end(ASCII 13). If there are <b>n</b>
footnotes, the <b>n+2nd </b>CP entry value is always 1 greater than the
<b>n+1st</b>
CP entry value. A paragraph end (ASCII 13) is always stored at the file
position marked by the <b>n+1st</b> CP value.
<p>When there are <b>n </b>footnotes, the plcffndRef structure consists
of
<b>n+1 </b>CP entries followed by <b>n </b>integer flags, named fAuto.
The
<b>ith</b> CP in the plcffndRef corresponds to the <b>ith </b>fAuto
flag. The CP entries give the locations of footnote references within the
main text address space. The <b>n+1th</b> CP entry contains the value fib.ccpText
+ fib.ccpFtn + fib.ccpHdr + 1. The fAuto flag contains 1 whenever the footnote
reference name is auto-generated by Word.
<p>When a footnote reference name is automatically generated by Word, Word
generates the name by adding 1 to the index number of the reference in
the plcffndRef and translating that number to ASCII text. When the footnote
reference is auto generated, the character at the main text CP position
for the footnote reference should be a footnote reference character (ASCII
5) which has a chp recorded with chp.fSpec = 1.
<p>The number of footnotes stored in a Word binary file can be found by
dividing fib.cbPlcffndTxt by 4 and subtracting 1.
<h1>
HEADERS AND FOOTERS</h1>
The header and footer text characters in a full saved file begin atat offset
fib.fcMin + fib.ccpText + fib.ccpFtn and extend till fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr. In a complex fast-saved document , the footnote
text begins atCP fib.ccpText + fib.ccpFtn and extends till fib.ccpText
+ fib.ccpFtn + fib.ccpHdr. The <b>plcfhdd</b>,a table whose location and
length within the file is stored in fib.fcPlcfhdd and fib.cbPlcfhdd, describes
where the text of each header/footer begins. If there are <b>n</b> headers/footers
stored in the Word file, the plcfhdd consists of <b>n + 2</b> CP entries.
The beginningCP of the <b>ith </b>header/footer is the <b>ith</b> CP in
the plcfhdd. The limit CP (the CP of character 1 position past the end
of a header/footer) of the <b>ith </b>header/footer is the <b>i + 1 st
</b>CP
in the plcfhdd. Note that at the limit CP - 1, Word always places a chEop
as a placeholder which is never displayed as part of the header/footer.
This allows Word to change an existing header/footer to be empty.
<p>If there are <b>n</b> header/footers, the <b>n+2nd </b>CP entry value
is always 1 greater than the <b>n+1st</b>CP entry value. A paragraph end
(ASCII 13) is always stored at the file position marked by the <b>n+1st</b>
CP value.
<p>The transformation in a full saved file from a header/footer CP to an
offset from the beginning of a file (fc) is fc = fib.fcMin + ccpText +
ccpFtn + cp.
<p>In Windows Word, headers/footers can be defined for a document that:
<p>1) will act as a separator between main text and footnote text
<p>2)
<br>will print below footnote text on a page when footnote text must be
continued on a succeeding page (continuation separator)
<p>3) will print above footnote text on a page when the text must be continued
from a previous page (continuation notice)
<p>Also for each section defined for the document, distinct headers can
be defined for printing on odd-numbered/rightfacing pages, even-numbered
/left facing pages and the first page of a section. Similarly for each
document section, distinct footers can be defined for printing on odd-numbered/right
facing pages, even-numbered/left facing pages and the first page of a section.
<p>Within the document and the section properties of a document (the DOP
and SEP) is a field, the <b>grpfIhdt</b>, which enumerates which of the
header/footer types are defined for the document or for a particular section.
The grpfIhdt in both the DOP and SEP is treated as a group of bit flags
stored within a character field with a flag assigned to every type of header/footer
that is possible to define for DOPs and SEPs. When a bit is on, it signifies
that the header/footer type corresponding to the bit is defined for the
document or for a particular section.
<font color="#FF0000">Attention: The bits are numbered the wrong way (i.e. bit 7
is the LSB!). Additionally they forgot about the endnote separators/cont.notices,...</font>
<p>Definition of the bits of dop.grpfIhdt:
<p><i><u>Bit position</u></i>
<p>7 footnote separator defined when == 1 (fTrue).
<p>6 footnote continuation separator defined when == 1 (fTrue).
<p>5 footnote continuation notice defined when == 1 (fTrue).
<p>Definition of the bits of sep.grpfIhdt:
<p><i><u>Bit position</u></i>
<p>7 header for even pages defined when == 1 (fTrue).
<p>6 header for odd pages defined when == 1 (fTrue).
<p>5 footer for even pages defined when == 1 (fTrue).
<p>4 footer for odd pages defined when == 1 (fTrue).
<p>3 header for first page of section defined when == 1 (fTrue).
<p>2 footer for first page of sectiondefined when == 1 (fTrue).
<p>Given that a particular footnote separator exists, one can locate the
text for that separator using the following algorithm:
<p>Initially set ihdd (index into plcfhdd) to 0.
<p>Scan bits 7, 6, and 5 of the dop.grpfIhdt in order looking for bit ==
1 while you have not yet reached the bit corresponding to the separator
whose text is to be located. For each such bit ==1 add 1 to ihdd.
<p>The value of ihdd that results is the index into plcfhdd that can be
used to access the text of the separator.
<p>Given that a particular header/footer exists for a particular section,
one can locate the text for that header/footer using the following algorithm:
<p>initially set ihdd (index into plcfhdd) to 0.
<p>scan bits 7, 6, and 5 of the dop.grpfIhdt looking for bit == 1 and add
1 to ihdd for each such bit== 1.
<p>Examine the sep.grpfIhdt of each section preceding the section of the
header/footer to be located in ascending section number order, scanning
bits 7, 6, 5, 4, 3, and 2 of the sep.grpfIhdtin order, adding 1 to ihdd
for each bit == 1.
<p>For the section of the header/footer to be located, scan bits 7, 6,
5, 4, 3, and 2 of the sep.grpfIhdt in order looking for bit == 1 while
you have not yetreached the bit corresponding to the header/footer to be
located. For each such bit ==1 add 1 to ihdd.
<p>The value of ihdd that results is the index into plcfhdd that can be
used to access the text of the header/footer.
<h1>
Page Table</h1>
The <b>plcfpgd</b>, referenced by the fib, gives the location of page breaks
within a Word document and may optionally be saved in a Word binary file.
If there are <b>n</b> page breaks calculated for a document, the plcfpgd
would consist of <b>n+1 </b>CP entries followed by <b>n</b> PGD entries.
<p>Third-party creators of Windows Word files should not attempt to create
a plcfpgd. It can only be created properly using Windows Word's page layout
routines. If a Windows Word document is edited in any way, the plcfpgd
should be deleted by setting fib.cbPlcfpgd to 0.
<p>If there are <b>n</b> pages breaks recorded for the document stored,
the
<b>n+1st</b> CP stored in the array of CPs for the plcfpgd will have
the value fib.ccpText + fib.ccpFtn + fib.ccpHdr + 1 if the document contains
footnotes or header/footers and will have the value fib.ccpText + fib.ccpFtn
+ fib.ccpHdr if the document contains no subdocuments.
<h1>
Glossary Files</h1>
A Word glossary file is a normal Word binary file with two supplemental
files, the <b>sttbfglsy</b> and the<b> plcfglsy</b>, also stored in the
file. The
<b>sttbfglsy</b> contains a list of the names of glossary entries,
and the
<b>plcfglsy</b> contains a table of beginning positions within
the text address space of the file of the text of glossary entries.
<p>The <b>sttbfglsy</b> begins with an integer count of bytes of the size
of the sttbfglsy (includes the size of the integer count
<br>of bytes). If there are <b>n</b> glossary entries defined, there will
follow <b>n</b> pascal-type strings (string preceded by length byte) concatenated
one after the other which store glossary entry names. The glossary entry
names must be sorted in case-insensitive ascending order. (ie. <b>a </b>and
<b>A</b>
are treated as equal). Also the names <b>date</b> and<b> time</b> must
be included in the list of names. The name of the <b>ith</b> glossary entry
is the <b>ith</b> name defined in the <b>sttbfglsy.</b>
<p>If there are <b>n</b> glossary entries, the <b>plcfglsy</b>, will consist
of <b>n+2</b> CP entries. The <b>ith</b> CP entry will contain the location
of the beginning of the text for the <b>ith </b>glossary entry. The <b>i+1st</b>
CP entry will contain the limit CP of the <b>ith</b> glossary entry. The
character ata CP position of limit CP - 1 is always a paragraph mark. The
<b>n+2nd</b>
CP entry always contains fib.ccpText + fib.ccpFtn + fib.ccpHdr + 1 if there
are headers, footers or footnotes stored in the glossary and contains fib.ccpText
+ fib.ccpFtn + fib.ccpHdr otherwise.The <b>n+1st </b>CP entry is always
1 less than the value of the <b>n+2nd</b> entry.
<p>The text for the <b>time </b>and <b>date</b> entries will always be
a single paragraph mark (ASCII 13).
<h1>
Table of Associated Strings (STTBFASSOC)</h1>
The following are indices into a table of associated strings:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>ibst</td>

<td>index</td>

<td>description</td>
</tr>

<tr>
<td>ibstAssocFileNext</td>

<td>0</td>

<td>unused</td>
</tr>

<tr>
<td>ibstAssocDot</td>

<td>1</td>

<td>filename of associated template</td>
</tr>

<tr>
<td>ibstAssocTitle</td>

<td>2</td>

<td>title of document</td>
</tr>

<tr>
<td>ibstAssocSubject</td>

<td>3</td>

<td>subject of document</td>
</tr>

<tr>
<td>ibstAssocKeyWords</td>

<td>4</td>

<td>keywords of document</td>
</tr>

<tr>
<td>ibstAssocComments</td>

<td>5</td>

<td>comments of document</td>
</tr>

<tr>
<td>ibstAssocAuthor</td>

<td>6</td>

<td>author of document</td>
</tr>

<tr>
<td>ibstAssocLastRevBy</td>

<td>7</td>

<td>name of person who last revised the document</td>
</tr>

<tr>
<td>ibstAssocDataDoc</td>

<td>8</td>

<td>filename of data document</td>
</tr>

<tr>
<td>ibstAssocHeaderDoc</td>

<td>9</td>

<td>filename of header document</td>
</tr>

<tr>
<td>ibstAssocCriteria1</td>

<td>10</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria2</td>

<td>11</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria3</td>

<td>12</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria4</td>

<td>13</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria5</td>

<td>14</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria6</td>

<td>15</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria7</td>

<td>16</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocMax</td>

<td>17</td>

<td>maximum number of strings in string table</td>
</tr>
</table>

<p>The format of the ibstAssocCriteriaX strings are as follows:
<p>intcbIbstAssoc:8;// BYTE 0
<br>size of ibstAssocCriteriaX string
<p>intfCompOr:1;
<br>// BYTE 1set if cond is an or cond
<p>intiCompOp:7;
<br>// BYTE 1index of Comparison Operator
<p>charstMergeField[];// Name of MergeField
<p>charstCompInfo[];// User Supplied Comparison Information
<p>Both stMergeField and stCompInfo are variable length character arrays
preceded by a length byte.
<h1>
Structure Definitions</h1>
<a NAME="ANLD"></a>
<h3>
Autonumbered List Data Descriptor (ANLD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>nfc</td>

<td>U8</td>

<td></td>

<td></td>

<td>number format code&nbsp;
<br>0 Arabic numbering&nbsp;
<br>1 Upper case Roman&nbsp;
<br>2 Lower case Roman&nbsp;
<br>3 Upper case Letter&nbsp;
<br>4 Lower case letter&nbsp;
<br>5 Ordinal&nbsp;</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>cxchTextBefore</td>

<td>U8</td>

<td></td>

<td></td>

<td>offset into anld.rgch that is the limit of the text that will be displayed
as the prefix of the autonumber text</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cxchTextAfter</td>

<td>U8</td>

<td></td>

<td></td>

<td>anld.cxchTextBefore will be the beginning offset of the text in the
anld.rgchthat will be displayed as the suffix of an autonumber. The sum
of anld.cxchTextBefore + anld.cxchTextAfter will be the limit of the autonumber
suffix in anld.rgch</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>jc</td>

<td>U8</td>

<td>:2</td>

<td>03</td>

<td>justification code
<br>0 left justify&nbsp;
<br>1 center&nbsp;
<br>2 right justify&nbsp;
<br>3 left and right justify</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrev</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, number generated will include previous levels (used for legal
numbering)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHang</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>when ==1, number will be displayed using a hanging indent</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetBold</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>when ==1, boldness of number will be determined by anld.fBold.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetItalic</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>when ==1, italicness of number will be determined by anld.fItalic</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>when ==1, anld.fSmallCaps will determine whether number will be displayed
in small caps or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetCaps</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>when ==1, anld.fCaps will determine whether number will be displayed
capitalized or not</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fSetStrike</td>

<td>U8</td>

<td>:1</td>

<td>01</td>

<td>when ==1, anld.fStrike will determine whether the number will be displayed
using strikethrough or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetKul</td>

<td>U8</td>

<td>:1</td>

<td>02</td>

<td>when ==1, anld.kul will determine the underlining state of the autonumber.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrevSpace</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, autonumber will be displayed with a single prefixing space
character</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBold</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>determines boldness of autonumber when anld.fSetBold == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fItalic</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>determines italicness of autonumber when anld.fSetItalic == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>determines whether autonumber will be displayed using small caps when
anld.fSetSmallCaps == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetCaps
== 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStrike</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetStrike
== 1.</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>kul</td>

<td>U8</td>

<td>:3</td>

<td>07</td>

<td>determines whether autonumber will be displayed with underlining when
anld.fSetKul == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ico</td>

<td>U8</td>

<td>:5</td>

<td>F1</td>

<td>color of autonumber</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>ftc</td>

<td>S16</td>

<td></td>

<td></td>

<td>font code of autonumber</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>hps</td>

<td>U16</td>

<td></td>

<td></td>

<td>font half point size (or 0=auto)</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>iStartAt</td>

<td>U16</td>

<td></td>

<td></td>

<td>starting value (0 to 65535)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>dxaIndent</td>

<td>U16</td>

<td></td>

<td></td>

<td>width of prefix text (same as indent)</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaSpace</td>

<td>U16</td>

<td></td>

<td></td>

<td>minimum space between number and paragraph</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>fNumber1</td>

<td>U8</td>

<td></td>

<td></td>

<td>number only 1 item per table cell</td>
</tr>

<tr>
<td>17</td>

<td>11</td>

<td>fNumberAcross</td>

<td>U8</td>

<td></td>

<td></td>

<td>number across cells in table rows(instead of down)</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>fRestartHdn</td>

<td>U8</td>

<td></td>

<td></td>

<td>restart heading number on section boundary</td>
</tr>

<tr>
<td>19</td>

<td>13</td>

<td>fSpareX</td>

<td>U8</td>

<td></td>

<td></td>

<td>unused( should be 0)</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>rgchAnld</td>
<!-- convert="string(rgxch)" -->

<td>U8[32]</td>

<td></td>

<td></td>

<td>characters displayed before/after autonumber</td>
</tr>
</table>


<p class="cb">*cbANLD (count of bytes of ANLD) is 52 (decimal), 34(hex).&nbsp;<a NAME="ANLV"></a>
<h3>
Autonumber Level Descriptor (ANLV)</h3>
<!-- sizeOf="16" -->

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>Bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>nfc</td>

<td>U8</td>

<td></td>

<td></td>

<td>number format code&nbsp;
<br>0 Arabic numbering&nbsp;
<br>1 Upper case Roman&nbsp;
<br>2 Lower case Roman&nbsp;
<br>3 Upper case Letter&nbsp;
<br>4 Lower case letter&nbsp;
<br>5 Ordinal</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>cxchTextBefore</td>

<td>U8</td>

<td></td>

<td></td>

<td>offset into anld.rgch that is the limit of the text that will be displayed
as the prefix of the autonumber text</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cxchTextAfter</td>

<td>U8</td>

<td></td>

<td></td>

<td>anld.cxchTextBefore will be the beginning offset of the text in the
anld.rgch that will be displayed as the suffix of an autonumber. The sum
of anld.cxchTextBefore + anld.cxchTextAfter will be the limit of the autonumber
suffix in anld.rgch</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>jc</td>

<td>U8</td>

<td>:2</td>

<td>03</td>

<td>justification code
<br>0 left justify&nbsp;
<br>1 center&nbsp;
<br>2 right justify&nbsp;
<br>3 left and right justify</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrev</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, number generated will include previous levels (used for legal
numbering)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHang</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>when ==1, number will be displayed using a hanging indent</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetBold</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>when ==1, boldness of number will be determined by anld.fBold.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetItalic</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>when ==1, italicness of number will be determined by anld.fItalic</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>when ==1, anld.fSmallCaps will determine whether number will be displayed
in small caps or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetCaps</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>when ==1, anld.fCaps will determine whether number will be displayed
capitalized or not</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fSetStrike</td>

<td>U8</td>

<td>:1</td>

<td>01</td>

<td>when ==1, anld.fStrike will determine whether the number will be displayed
using strikethrough or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetKul</td>

<td>U8</td>

<td>:1</td>

<td>02</td>

<td>when ==1, anld.kul will determine the underlining state of the autonumber.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrevSpace</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, autonumber will be displayed with a single prefixing space
character</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBold</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>determines boldness of autonumber when anld.fSetBold == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fItalic</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>determines italicness of autonumber when anld.fSetItalic == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>determines whether autonumber will be displayed using small caps when
anld.fSetSmallCaps == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetCaps
== 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStrike</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetStrike
== 1.</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>kul</td>

<td>U8</td>

<td>:3</td>

<td>07</td>

<td>determines whetherautonumber will be displayed with underlining when
anld.fSetKul == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ico</td>

<td>U8</td>

<td>:5</td>

<td>F1</td>

<td>color of autonumber</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>ftc</td>

<td>S16</td>

<td></td>

<td></td>

<td>font code of autonumber</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>hps</td>

<td>U16</td>

<td></td>

<td></td>

<td>font half point size (or 0=auto)</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>iStartAt</td>

<td>U16</td>

<td></td>

<td></td>

<td>starting value (0 to 65535)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>dxaIndent</td>

<td>U16</td>

<td></td>

<td></td>

<td>width of prefix text (same as indent)</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaSpace</td>

<td>U16</td>

<td></td>

<td></td>

<td>minimum space between number and paragraph</td>
</tr>
</table>


<p class="field">cbANLV is 16 bytes (decimal), 10 bytes (hex).&nbsp;<a NAME="BKF"></a>
<h3>
BooKmark First descriptor (BKF)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ibkl</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to BKL entry in plcfbkl that describes the ending position of
this bookmark in the CP stream.</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>itcFirst</td>

<td>U16</td>

<td>:7</td>

<td>007F</td>

<td>when bkf.fCol is 1, this is the index to the first column of a table
column bookmark.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPub</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>when 1, this indicates that this bookmark is marking the range of a
Macintosh Publisher section.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>itcLim</td>

<td>U16</td>

<td>:7</td>

<td>7F00</td>

<td>when bkf.fCol is 1, this is the index to limit column of a table column
bookmark.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCol</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>when 1, this bookmark marks a range of columns in a table specified
by [bkf.itcFirst, bkf.itcLim).</td>
</tr>
</table>


<p class="field">cbBKF is 4.&nbsp;<a NAME="BKL"></a>
<h3>
BooKmark Lim descriptor (BKL)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ibkf</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to BKF entry in plcfbkf that&nbsp;</td>
</tr>
</table>


<p class="field">cbBKL is 2.

<p class="field">describes the beginning position of this bookmark in the
<b>CP</b>
stream. If the bkl.ibkf is negative, add on the number of boomarks recorded
in the hplcbkf to the bkl.ibkf to calculate the index to the BKF that corresponds
to this entry.&nbsp;<a NAME="BRC"></a>
<h3>
Border Code (BRC)</h3>
The <b>BRC</b> is a substructure of the <b>PAP, PIC</b> and <b>TC.</b>See
also the obsolete BRC10 structure.
<br>&nbsp;
<!-- sizeOf="2" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dxpLineWidth</td>

<td>U16</td>

<td>:3</td>

<td>0007</td>

<td>When dxpLineWidth is 0, 1, 2, 3, 4, or 5, this field is the width of
a single line of border in units of 0.75 points.Each line in the border
is this wide (e.g. a double border is three lines).Must be nonzero when
brcType is nonzero.When dxpLineWidth is 6, it means that the border line
is dotted.When dxpLineWidth is 7, it means the border line is dashed.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>brcType</td>

<td>U16</td>

<td>:2</td>

<td>0018</td>

<td>border type code&nbsp;
<br>0 none&nbsp;
<br>1 single&nbsp;
<br>2 thick&nbsp;
<br>3 double&nbsp;</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadow</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>when 1, border is drawn with shadow. Must be 0 when BRC is a substructure
of the TC</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ico</td>

<td>U16</td>

<td>:5</td>

<td>07C0</td>

<td>color code (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpSpace</td>

<td>U16</td>

<td>:5</td>

<td>F800</td>

<td>width of space to maintain between border and text within border. Must
be 0 when BRC is a substructure of the TC.Stored in points for Windows.</td>
</tr>
</table>
<a NAME="BRC10"></a>
<h3>
Border Code for Windows Word 1.0 (BRC10)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dxpLine2Width</td>

<td>U16</td>

<td>:3</td>

<td>0007</td>

<td>width of second line of border in pixels</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpSpaceBetween</td>

<td>U16</td>

<td>:3</td>

<td>0038</td>

<td>distance to maintain between both lines of borderin pixels</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpLine1Width</td>

<td>U16</td>

<td>:3</td>

<td>01C0</td>

<td>width of first border line in pixels</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpSpace</td>

<td>U16</td>

<td>:5</td>

<td>3E00</td>

<td>width of space to maintain between border and text within border. Must
be 0 when BRC is a substructure of the TC.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadow</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td>when 1, border is drawn with shadow. Must be 0 when BRC10 is a substructure
of the TC.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSpare</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>reserved</td>
</tr>
</table>

<p>The seventypes of border lines that Windows Word 1.0 supports are coded
with different sets of values for dxpLine1Width, dxpSpaceBetween, and dxpLine2
Width. The border lines and their brc10 settings follow:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>line type</td>

<td>dxpLine1Width</td>

<td>dxpSpaceBetween</td>

<td>dxpLine2Width</td>
</tr>

<tr>
<td>no border</td>

<td>0</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>single line border</td>

<td>1</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>two single line border</td>

<td>1</td>

<td>1</td>

<td>1</td>
</tr>

<tr>
<td>fat solid border</td>

<td>4</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>thick solid border</td>

<td>2</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>dotted border</td>

<td>6 (special value meaning dotted line)</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>hairline border</td>

<td>7(special value meaning hairline)</td>

<td>0</td>

<td>0</td>
</tr>
</table>

<p>When the <b>no border </b>settings are stored in the BRC, brc.fShadow
and brc.dxpSpace should be set to 0.&nbsp;<a NAME="BTE"></a>
<h3>
Bin Table Entry (BTE)</h3>
<!-- sizeOf="2" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>pn</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>Page Number for FKP</td>
</tr>
</table>
cbBTE (count of bytes in a BTE) is 2.&nbsp;<a NAME="CHP"></a>
<h3>
Character Properties (CHP)</h3>
The <b>CHP</b> is never stored in Word files. It is the result of decompression
operations applied to <b>CHPX</b>s The <b>CHPX</b> is stored in <b>CHPXFKPS</b>
and within the <b>STSH</b>
<p>(<b>Note</b>: when a <b>CHPX</b> is stored in an <b>FKP</b> it is prefixed
by a one-byte count of bytes that records the size of the non-zero prefix
of the <b>CHPX</b>. Since the count of bytes must begin on an even boundary
within the <b>FKP </b>followed by the non-zero prefix, it's guaranteed
that the int and FC fields of the CHPX are aligned on an odd-byte boundary.
Using normal integer or long load instructions will cause address errors
on a 68000. The best technique for reconstituting the CHPX is to move the
non-zero prefix to the beginning of a local instance of a CHPX that has
been cleared to zeros.)
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fBold</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td>text is bold when 1 , and not bold when 0.&nbsp;</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fItalic</td>

<td>U8</td>

<td>:1</td>

<td>0002</td>

<td>italic when 1, not italic when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRMarkDel</td>

<td>U8</td>

<td>:1</td>

<td>0004</td>

<td>when 1, text has been deleted and will be displayed with strikethrus
when revision marked text is to displayed&nbsp;</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOutline</td>

<td>U8</td>

<td>:1</td>

<td>0008</td>

<td>outlined when 1, not outlined when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFldVanish</td>

<td>U8</td>

<td>:1</td>

<td>0010</td>

<td>&lt;needs work></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>0020</td>

<td>displayed with small caps when 1, no small caps when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCaps</td>

<td>U8</td>

<td>:1</td>

<td>0040</td>

<td>displayed with caps when 1, no caps when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fVanish</td>

<td>U8</td>

<td>:1</td>

<td>0080</td>

<td></td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>fRMark</td>

<td>U8</td>

<td>:1</td>

<td>0100</td>

<td>when 1, text is newly typed since the last time revision marks have
been accepted and will be displayed with an underline when revision marked
text is to be displayed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSpec</td>

<td>U8</td>

<td>:1</td>

<td>0200</td>

<td>character is a Word special character when 1, not a special character
when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStrike</td>

<td>U8</td>

<td>:1</td>

<td>0400</td>

<td>displayed with strikethrough when 1, no strikethroughwhen 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fObj</td>

<td>U8</td>

<td>:1</td>

<td>0800</td>

<td>embedded object when 1, not an embedded object when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadow</td>

<td>U8</td>

<td>:1</td>

<td>1000</td>

<td>character is drawn with a shdow when 1; drawn without shadow when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLowerCase</td>

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td>character is displayed in lower case when 1. No case transformation
is performed when 0. This field may be set to 1 only when chp.fSmallCaps
is 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fData</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>when 1, chp.fcPic points to an FFDATA the data structure binary data
used by Word to describe a form field. chp.fData may only be 1 when chp.fSpec
is also 1 and the special character in the document stream that has this
property is a chPicture (0x01).</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOle2</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>when 1, chp.lTagObj specifies a particular object in the object stream
that specifies the particular OLE object in the stream that should be displayed
when the chPicture fSpec character that is tagged with the fOle2 is encountered.
chp.fOle2 may only be 1 when chp.fSpec is also 1 and the special character
in the document stream that has this property is a chPicture (0x01).</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>unused2</td>
<!-- convert="unused" -->

<td>U16</td>

<td></td>

<td></td>

<td>Reserved</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>ftc</td>
<!-- convert="(ftcAscii)" -->

<td>U16</td>

<td></td>

<td></td>

<td>font code. The ftc is an index into the rgffn structure. The rgffn
entry indexed by ftc describes the font that will be used to display the
run of text described by the CHP.&nbsp;</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>hps</td>

<td>U16</td>

<td></td>

<td></td>

<td>font size in half points</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>dxaSpace</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>space following each character in the run expressed in twip units.</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>iss</td>

<td>U8</td>

<td>:3</td>

<td>0007</td>

<td>superscript/subscript indices&nbsp;
<br>0 means no super/subscripting
<br>1 means text in run is superscrpted
<br>2 means text in run is subscripted</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused10_3</td>
<!-- convert="unused" -->

<td>U8</td>

<td>:3</td>

<td>0038</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSysVanish</td>

<td>U8</td>

<td>:1</td>

<td>0040</td>

<td>used by Word internally, not stored in file</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused10_7</td>
<!-- convert="unused" -->

<td>U8</td>

<td>:1</td>

<td>0080</td>

<td>reserved</td>
</tr>

<tr>
<td>11</td>

<td>B</td>

<td>ico</td>

<td>U8</td>

<td>:5</td>

<td>1F00</td>

<td>color of text:
<br>0 Auto
<br>1 Black
<br>2 Blue
<br>3 Cyan
<br>4 Green
<br>5 Magenta
<br>6 Red
<br>7 Yellow
<br>8 White
<br>9 DkBlue
<br>10 DkCyan
<br>11 DkGreen
<br>12 DkMagenta
<br>13 DkRed
<br>14 DkYellow
<br>15 DkGray
<br>16 LtGray</td>
</tr>

<tr>
<td></td>

<td></td>

<td>kul</td>

<td>U8</td>

<td>:3</td>

<td>E000</td>

<td>underline code:&nbsp;
<br>0 none&nbsp;
<br>1 single&nbsp;
<br>2 by word&nbsp;
<br>3 double&nbsp;
<br>4 dotted&nbsp;
<br>5 hidden</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>hpsPos</td>

<td>S16</td>

<td></td>

<td></td>

<td>super/subscript position in half points; positive means text is raised;
negative means text is lowered.</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>lid</td>

<td>U16</td>

<td></td>

<td></td>

<td>Language Name Language ID
<br>0x0401 Arabic
<br>0x0402 Bulgarian
<br>0x0403 Catalan
<br>0x0404 Traditional Chinese
<br>0x0804 Simplified Chinese
<br>0x0405 Czech
<br>0x0406 Danish
<br>0x0407 German
<br>0x0807 Swiss German
<br>0x0408 Greek
<br>0x0409 U.S. English
<br>0x0809 U.K. English
<br>0x0c09 Australian English
<br>0x040a Castilian Spanish
<br>0x080a Mexican Spanish
<br>0x040b Finnish
<br>0x040c French
<br>0x080c Belgian French
<br>0x0c0c Canadian French
<br>0x100c Swiss French
<br>0x040d Hebrew
<br>0x040e Hungarian
<br>0x040f Icelandic
<br>0x0410 Italian
<br>0x0810 Swiss Italian
<br>0x0411 Japanese
<br>0x0412 Korean
<br>0x0413 Dutch
<br>0x0813 Belgian Dutch
<br>0x0414 Norwegian - Bokmal
<br>0x0814 Norwegian - Nynorsk
<br>0x0415 Polish
<br>0x0416 Brazilian Portuguese
<br>0x0816 Portuguese
<br>0x0417 Rhaeto-Romanic
<br>0x0418 Romanian
<br>0x0419 Russian
<br>0x041a Croato-Serbian (Latin)
<br>0x081a Serbo-Croatian (Cyrillic)
<br>0x041b Slovak
<br>0x041c Albanian
<br>0x041d Swedish
<br>0x041e Thai
<br>0x041f Turkish
<br>0x0420 Urdu
<br>0x0421 Bahasa</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>fcPic_fcObj_lTagObj</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>offset in document stream pointing to beginning of a picture when character
is a picture character (character is 0x01 and chp.fSpec is 1)&nbsp;
<br>offset in document stream pointing to beginning of a picture when character
is an OLE1 object character (character is 0x20 and chp.fSpec is 1, chp.fOle2
is 0)&nbsp;
<br>long word tag that identifies an OLE2 object in the object stream when
the character is an OLE2 object character. (character is 0x01 and chp.fSpec
is 1, chp.fOle2 is 1)</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>ibstRMark</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>index to author IDs stored in hsttbfRMark. used when text in run was
newly typed or deleted when revision marking was enabled</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>dttmRMark</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>Date/time at which this run of text was entered/modified by the author.
(Only recorded whenrevision marking is on.)</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>unused26</td>
<!-- convert="unused" -->

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>istd</td>

<td>U16</td>

<td></td>

<td></td>

<td>index to character style descriptor in the stylesheet that tags this
run of text When istd is istdNormalChar (10 decimal), characters in run
are not affected by a character style. If chp.istd contains any other value,
chpx of the specified character style are applied to CHP for this run before
any other exceptional properties are applied.</td>
</tr>

<tr>
<td>30</td>

<td>1E</td>

<td>ftcSym</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>when chp.fSpec is 1 and the character recorded for the run in the document
stream is chSymbol (0x28), chp.ftcSym identifies the font code of the symbol
font that will be used to display the symbol character recorded in chp.chSym.
Just like chp.ftc, chp.ftcSym is an index into the rgffn structure.</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>chSym</td>
<!-- convert="(xchSym)" -->

<td>U8</td>

<td></td>

<td></td>

<td>when chp.fSpec is 1 and the character recorded for the run in the document
stream is chSymbol (0x28), the character stored chp.chSym will be displayed
using the font specified in chp.ftcSym.&nbsp;</td>
</tr>

<tr>
<td>33</td>

<td>21</td>

<td>fChsDiff</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>when 1, the character set used to interpret the characters recorded
in the run identified by chp.chse is different from the native character
set for this document which is stored in fib.chse.</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>idslRMReason</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>an index to strings displayed as reasons for actions taken by Word?s
AutoFormat code</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>ysr</td>

<td>U8</td>

<td></td>

<td></td>

<td>hyphenation rule&nbsp;
<br>0 No hyphenation&nbsp;
<br>1Normal hyphenation&nbsp;
<br>2Add letter before hyphen&nbsp;
<br>3Change letter before hyphen&nbsp;
<br>4Delete letter before hyphen&nbsp;
<br>5Change letter after hyphen&nbsp;
<br>6Delete letter before the hyphen and change the letter preceding the
deleted character</td>
</tr>

<tr>
<td>37</td>

<td>25</td>

<td>chYsr</td>

<td>U8</td>

<td></td>

<td></td>

<td>the character that will be used to add or changea letter when chp.ysr
is 2,3, 5 or 6</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>chse</td>

<td>U16</td>

<td></td>

<td></td>

<td>extended character set id
<br>0 characters in run should be interpreted using the ANSI set used by
Windows&nbsp;
<br>256 characters in run should be interpreted using the Macintosh character
set.</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>hpsKern</td>

<td>U16</td>

<td></td>

<td></td>

<td>kerning distance for characters in run recorded in half points</td>
</tr>
</table>


<p class="cb">*cbCHP (count of bytes of CHP) is 42 (decimal), 2A(hex).&nbsp;<a NAME="CHPX"></a>
<h3>
Character Property Exceptions (CHPX)</h3>
The <b>CHPX</b> is stored within <b>Character FKPs</b> and withinthe <b>STSH</b>in
<b>STD</b>sfor
<b>paragraph
style</b> and <b>character style</b> entries.
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of bytes of following data in CHPX.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>grpprl</td>

<td>U8[cb]</td>

<!-- compareSizeLHS="lhs.cb" compareSizeRHS="rhs.cb" -->

<td></td>

<td></td>

<td>a list of the sprms that encode the differences between CHP for a run
of text and the CHP generated by the paragraph and character styles that
tag the run.</td>
</tr>
</table>


<p class="field">The following sprms may be recorded in a <b>CHPX</b>:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>sprm</td>

<td>fields in CHP altered by sprm</td>
</tr>

<tr>
<td>sprmCFSpec</td>

<td>chp.fSpec</td>
</tr>

<tr>
<td>sprmCSymbol</td>

<td>chp.chSym, chp.ftcSym</td>
</tr>

<tr>
<td>sprmCPicLocation</td>

<td>chp.fcPic</td>
</tr>

<tr>
<td>sprmCFStrikeRM</td>

<td>chp.fRMarkDel</td>
</tr>

<tr>
<td>sprmCFRMark</td>

<td>chp.fRMark</td>
</tr>

<tr>
<td>sprmCFFldVanish</td>

<td>chp.fFldVanish</td>
</tr>

<tr>
<td>sprmCIbstRMark</td>

<td>chp.ibstRMark</td>
</tr>

<tr>
<td>sprmCDttmRMark</td>

<td>chp.dttmRMark</td>
</tr>

<tr>
<td>sprmCRMReason</td>

<td>chp.idslRMReason</td>
</tr>

<tr>
<td>sprmCIstd</td>

<td>chp.istd</td>
</tr>

<tr>
<td>sprmCFBold</td>

<td>chp.fBold</td>
</tr>

<tr>
<td>sprmCFItalic</td>

<td>chp.fItalic</td>
</tr>

<tr>
<td>sprmCFStrike</td>

<td>chp.fStrike</td>
</tr>

<tr>
<td>sprmCFOutline</td>

<td>chp.fOutline</td>
</tr>

<tr>
<td>sprmCFShadow</td>

<td>chp.fShadow</td>
</tr>

<tr>
<td>sprmCFSmallCaps</td>

<td>chp.fSmallCaps</td>
</tr>

<tr>
<td>sprmCFCaps</td>

<td>chp.fCaps</td>
</tr>

<tr>
<td>sprmCFVanish</td>

<td>chp.fVanish</td>
</tr>

<tr>
<td>sprmCFtc</td>

<td>chp.ftc</td>
</tr>

<tr>
<td>sprmCKul</td>

<td>chp.kul</td>
</tr>

<tr>
<td>sprmCDxaSpace</td>

<td>chp.dxaSpace</td>
</tr>

<tr>
<td>sprmCLid</td>

<td>chp.lid</td>
</tr>

<tr>
<td>sprmCIco</td>

<td>chp.ico</td>
</tr>

<tr>
<td>sprmCHps</td>

<td>chp.hps</td>
</tr>

<tr>
<td>sprmCHpsPos</td>

<td>chp.hpsPos</td>
</tr>

<tr>
<td>sprmCIss</td>

<td>chp.iss</td>
</tr>

<tr>
<td>sprmCFData</td>

<td>chp.fData</td>
</tr>

<tr>
<td>sprmCFObj</td>

<td>chp.fObj</td>
</tr>

<tr>
<td>sprmCFOle2</td>

<td>chp.fOle2</td>
</tr>

<tr>
<td>sprmCYsri</td>

<td>chp.ysri</td>
</tr>

<tr>
<td>sprmCHpsKern</td>

<td>chp.hpsKern</td>
</tr>

<tr>
<td>sprmCChse</td>

<td>chp.chse, chp.fChsDiff</td>
</tr>
</table>

<p>chpx.cb is equal to (1 + sizeof(chpx.grpprl)).&nbsp;<a NAME="CHPXFKP"></a>
<h3>
Formatted Disk Page for CHPXs (CHPXFKP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td></td>

<td>rgfc</td>

<td>U32[]</td>

<td></td>

<td></td>

<td>Array of FCs. Each FC is the limit FC of a run of exception text.</td>
</tr>

<tr>
<td>4*(fkp.crun+1)</td>

<td></td>

<td>rgb</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>an array of bytes where each byte is the word offset of aCHPX. If the
byte stored is 0,there is no difference between run's character properties
and the style's character properties</td>
</tr>

<tr>
<td>5*fkp.crun+4</td>

<td></td>

<td>unusedSpace</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>As new runs/paragraphs are recorded in the FKP,unused space is reduced&nbsp;
by 5 if CHPX is already recorded and is reduced by5+sizeof(CHPX) if property&nbsp;
is not already recorded.</td>
</tr>

<tr>
<td>511-sizeof(grpchpx)</td>

<td></td>

<td>grpchpx</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>grpchpx consists of all of the CHPXs stored in FKP concatenated end&nbsp;
to end. Each CHPXis prefixed with a count of bytes which records its length.</td>
</tr>

<tr>
<td>511</td>

<td></td>

<td>crun</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of runs for CHPX FKP,</td>
</tr>
</table>

<p>The <b>CHP</b> is never stored in a Word file. It is derived by expanding
stored <b>CHPX</b>s.&nbsp;<a NAME="DCS"></a>
<h3>
Drop Cap Specifier (DCS)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fdct</td>

<td>U8</td>

<td>:3</td>

<td>0007</td>

<td>default value 0&nbsp;
<br>drop cap type&nbsp;
<br>0&nbsp; no drop cap&nbsp;
<br>1 normal drop cap&nbsp;
<br>2 drop cap in margin</td>
</tr>

<tr>
<td></td>

<td></td>

<td>lines</td>

<td>U8</td>

<td>:5</td>

<td>00F8</td>

<td>count of lines to drop</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>unused1</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>
</table>
<a NAME="DO"></a>
<h3>
Drawing Object (Word) (DO)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fc</td>

<td>U32</td>

<td></td>

<td></td>

<td>FC pointing to drawing object data</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dok</td>

<td>U16</td>

<td></td>

<td></td>

<td>Drawn Object Kind, currently this is always 0</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cb</td>

<td>U16</td>

<td></td>

<td></td>

<td>size (count of bytes) of the entire DO</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>bx</td>

<td>U8</td>

<td></td>

<td></td>

<td>x position relative to anchor CP</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>by</td>

<td>U8</td>

<td></td>

<td></td>

<td>y position relative to anchor CP</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>dhgt</td>

<td>U16</td>

<td></td>

<td></td>

<td>height of DO</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>fAnchorLock</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 if the DO anchor is locked</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused8</td>

<td>U16</td>

<td>:15</td>

<td>FFFE</td>

<td></td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>rgdp</td>

<td>U8</td>

<td></td>

<td></td>

<td>variable length array of drawing primitives</td>
</tr>
</table>

<p>(Shaheed TBD) The above DO does not make sense&nbsp;<a NAME="DOP"></a>
<h3>
Document Properties (DOP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fFacingPages</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 when facing pages should be printed (default 0)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWidowControl</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>1 when widow control is in effect. 0 when widow control disabled. (default
1)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPMHMainDoc</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>1 when doc is a main doc for Print Merge Helper, 0 when not; default=0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>grfSuppression</td>

<td>U16</td>

<td>:2</td>

<td>0018</td>

<td>Default line suppression storage
<br>0= form letter line suppression
<br>1= no line suppression
<br>default=0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fpc</td>

<td>U16</td>

<td>:2</td>

<td>0060</td>

<td>footnote position code
<br>0 print as endnotes&nbsp;
<br>1 print at bottom of page&nbsp;
<br>2 print immediately beneath text&nbsp;
<br>(default 1)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_7</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>unused (default 0)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>grpfIhdt</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>specification of document headers and footers. See explanation under
Headers and Footers topic. (default 0)</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>rncFtn</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>restart index for footnote
<br>0 don't restart note numbering&nbsp;
<br>1 restart for each section&nbsp;
<br>2 restart for each page&nbsp;
<br>(default 0)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nFtn</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>initial footnote number for document (default 1)</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fOutlineDirtySave</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td>when 1, indicates that information in the hplcpad should be refreshed
since outline has been dirtied</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused4_1</td>

<td>U8</td>

<td>:7</td>

<td>00FE</td>

<td>reserved</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>fOnlyMacPics</td>

<td>U8</td>

<td>:1</td>

<td>0100</td>

<td>when 1, Word believes all pictures recorded in the document were created
on a Macintosh</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOnlyWinPics</td>

<td>U8</td>

<td>:1</td>

<td>0200</td>

<td>when 1, Word believes all pictures recorded in the document were created
in Windows</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLabelDoc</td>

<td>U8</td>

<td>:1</td>

<td>0400</td>

<td>when 1, document was created as a print merge labels document</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHyphCapitals</td>

<td>U8</td>

<td>:1</td>

<td>0800</td>

<td>when 1, Word is allowed to hyphenate words that are capitalized. When
0, capitalized may not be hyphenated</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAutoHyphen</td>

<td>U8</td>

<td>:1</td>

<td>1000</td>

<td>when 1, Word will hyphenate newly typed text as a background task</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFormNoFields</td>

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLinkStyles</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>when 1, Word will merge styles from its template</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRevMarking</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>when 1, Word will mark revisions as the document is edited</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fBackup</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td>always make backup when document saved when 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fExactCWords</td>

<td>U8</td>

<td>:1</td>

<td>0002</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPagHidden</td>

<td>U8</td>

<td>:1</td>

<td>0004</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPagResults</td>

<td>U8</td>

<td>:1</td>

<td>0008</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLockAtn</td>

<td>U8</td>

<td>:1</td>

<td>0010</td>

<td>when 1, annotations are locked for editing</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMirrorMargins</td>

<td>U8</td>

<td>:1</td>

<td>0020</td>

<td>swap margins on left/right pages when 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fReadOnlyRecommended</td>
<!-- convert="unused" -->

<td>U8</td>

<td>:1</td>

<td>0040</td>

<td>user has recommended that this doc be opened read-only when 1</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDfltTrueType</td>

<td>U8</td>

<td>:1</td>

<td>0080</td>

<td>when 1, use TrueType fonts by default (flag obeyed only when doc was
created by WinWord 2.x)</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>fPagSuppressTopSpacing</td>

<td>U8</td>

<td>:1</td>

<td>0100</td>

<td>when 1, file created with SUPPRESSTOPSPACING=YES in win.ini. (flag
obeyed only when doc was created by WinWord 2.x).</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fProtEnabled</td>

<td>U8</td>

<td>:1</td>

<td>0200</td>

<td>when 1, document is protected from edit operations</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDispFormFldSel</td>

<td>U8</td>

<td>:1</td>

<td>0400</td>

<td>when 1, restrict selections to occur only within form fields</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRMView</td>

<td>U8</td>

<td>:1</td>

<td>0800</td>

<td>when 1, show revision markings on screen</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRMPrint</td>

<td>U8</td>

<td>:1</td>

<td>1000</td>

<td>when 1, print revision marks when document is printed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWriteReservation</td>
<!-- convert="unused" -->

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLockRev</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>when 1, the current revision marking state is locked</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEmbedFonts</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>when 1, document contains embedded True Type fonts</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>copts_fNoTabForInd</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>compatability option: when 1, don?t add automatic tab stops for hanging
indent</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fNoSpaceRaiseLower</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>compatability option: when 1, don?t add extra space for raised or lowered
characters</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fSuppressSpbfAfterPageBreak</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>compatability option: when 1, supress the paragraph Space Before and
Space After options after a page break</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fWrapTrailSpaces</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>compatability option: when 1, wrap trailing spaces at the end of a
line to the next line</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fMapPrintTextColor</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>compatability option: when 1, print colors as black on non-color printers</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fNoColumnBalance</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>compatability option: when 1, don?t balance columns for Continuous
Section starts</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fConvMailMergeEsc</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fSupressTopSpacing</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>compatability option: when 1, supress extra line spacing at top of
page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fOrigWordTableRules</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>compatability option: when 1, combine table borders like Word 5.x for
the Macintosh</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fTransparentMetafiles</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>compatability option: when 1, don?t blank area between metafile pictures</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fShowBreaksInFrames</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>compatability option: when 1, show hard page or column breaks in frames</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fSwapBordersFacingPgs</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>compatability option: when 1, swap left and right pages on odd facing
pages</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused8_12</td>

<td>U16</td>

<td>:4</td>

<td>F000</td>

<td>reserved</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>dxaTab</td>

<td>U16</td>

<td></td>

<td></td>

<td>(default 720 twips) default tab width</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>wSpare</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaHotZ</td>

<td>U16</td>

<td></td>

<td></td>

<td>width of hyphenation hot zone measured in twips</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>cConsecHypLim</td>

<td>U16</td>

<td></td>

<td></td>

<td>number of lines allowed to have consecutive hyphens</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>wSpare2</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dttmCreated</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>date and time document was created</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dttmRevised</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>date and time document was last revised</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>dttmLastPrint</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>date and time document was last printed</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>nRevision</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>number of times document has been revised since its creation</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>tmEdited</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>time document was last edited</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>cWords</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of words tallied by last Word Count execution</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>cCh</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of characters tallied by last Word Count execution</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>cPg</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>count of pages tallied by last Word Count execution</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>cParas</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of paragraphs tallied by last Word Count execution</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>rncEdn</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>restart endnote number code
<br>0 don't restart endnote&nbsp; numbering&nbsp;
<br>1 restart for each section&nbsp;
<br>2 restart for each page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nEdn</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>beginning endnote number</td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>epc</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>endnote position code
<br>0 display endnotes at end of&nbsp; section&nbsp;
<br>3 display endnotes at end of document</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nfcFtnRef</td>
<!-- convert="(nfcFtnRef2)" -->

<td>U16</td>

<td>:4</td>

<td>003C</td>

<td>number format code for auto footnotes
<br>0 Arabic numbering&nbsp;
<br>1 Upper case Roman&nbsp;
<br>2 Lower case Roman&nbsp;
<br>3 Upper case Letter&nbsp;
<br>4 Lower case letter&nbsp;
<br>5 Ordinal</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nfcEdnRef</td>
<!-- convert="(nfcEdnRef2)" -->

<td>U16</td>

<td>:4</td>

<td>03C0</td>

<td>number format code for auto endnotes
<br>0 Arabic numbering&nbsp;
<br>1 Upper case Roman&nbsp;
<br>2 Lower case Roman&nbsp;
<br>3 Upper case Letter&nbsp;
<br>4 Lower case letter&nbsp;
<br>5 Ordinal&nbsp;</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrintFormData</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>only print data inside of form fields</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSaveFormData</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>only save document data that is inside of a form field.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadeFormData</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td>shade form fields</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused54_13</td>

<td>U16</td>

<td>:2</td>

<td>6000</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWCFtnEdn</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>when 1, include footnotes and endnotes in word count</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>cLines</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of lines tallied by last Word Count operation</td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>cWordsFtnEnd</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of words in footnotes and endnotes tallied by last Word Count
operation</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>cChFtnEdn</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of characters in footnotes and endnotes tallied by last Word
Count operation</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>cPgFtnEdn</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>count of pages in footnotes and endnotes tallied by last Word Count
operation</td>
</tr>

<tr>
<td>70</td>

<td>46</td>

<td>cParasFtnEdn</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of paragraphs in footnotes and endnotes tallied by last Word
Count operation</td>
</tr>

<tr>
<td>74</td>

<td>4A</td>

<td>cLinesFtnEdn</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of paragraphs in footnotes and endnotes tallied by last Word
Count operation</td>
</tr>

<tr>
<td>78</td>

<td>4E</td>

<td>lKeyProtDoc</td>
<!-- convert="type" -->

<td>U32</td>

<td></td>

<td></td>

<td>document protection password key, only valid if dop.fProtEnabled, dop.fLockAtn
or dop.fLockRev are 1.</td>
</tr>

<tr>
<td>82</td>

<td>52</td>

<td>wvkSaved</td>

<td>U16</td>

<td>:3</td>

<td>0007</td>

<td>document view kind&nbsp;
<br>0 Normal view&nbsp;
<br>1 Outline view&nbsp;
<br>2 Page View</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wScaleSaved</td>

<td>U16</td>

<td>:9</td>

<td>0FF8</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>zkSaved</td>

<td>U16</td>

<td>:2</td>

<td>3000</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused82_14</td>
<!-- convert="unused" -->

<td>U16</td>

<td>:2</td>

<td>c000</td>

<td></td>
</tr>
</table>


<p class="field">cbDOP is 84.cwDOP is 42.&nbsp;<a NAME="DPARC"></a>
<h3>
DP data for an arc (DPARC)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style. See description in DPLINE.</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dlpcFg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color ForeGround -- RGB color value</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dlpcBg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color BackGround -- RGB color value</td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>flpp</td>

<td>U16</td>

<td></td>

<td></td>

<td>FiLl Property Pattern. REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>fLeft</td>

<td>U16</td>

<td>:8</td>

<td>00ff</td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUp</td>

<td>U16</td>

<td>:8</td>

<td>ff00</td>

<td>REVIEW davebu</td>
</tr>
</table>
<a NAME="DPCALLOUT"></a>
<h3>
DP data for a callout textbox (DPCALLOUT)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>unused12</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu flags</td>
</tr>

<tr>
<td>14</td>

<td>e</td>

<td>dzaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>dzaDescent</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>dzaLength</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dptxbx</td>

<td>DPTXBX</td>

<td></td>

<td></td>

<td>DP for a textbox</td>
</tr>

<tr>
<td>60</td>

<td>4c</td>

<td>dpPolyLine</td>

<td>DPPOLYLINE</td>

<td></td>

<td></td>

<td>DP for a polyline</td>
</tr>
</table>
<a NAME="DPELLIPSE"></a>
<h3>
DP data for an ellipse (DPELLIPSE)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style. See description in DPLINE.</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dlpcFg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color ForeGround -- RGB color value</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dlpcBg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color BackGround -- RGB color value</td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>flpp</td>

<td>U16</td>

<td></td>

<td></td>

<td>FiLl Property Pattern. REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>
</table>
<a NAME="DPHEAD"></a>
<h3>
Drawing Primitive Header (Word) (DPHEAD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dpk</td>

<td>U16</td>

<td></td>

<td></td>

<td>Drawn Primitive KindREVIEW davebu
<br>0x0000 = start of grouping of primitives (DO)
<br>0x0001 = line (DPLINE)
<br>0x0002 = textbox (DPTXBX)
<br>0x0003 = rectangle (DPRECT)
<br>0x0004 = arc (DPARC)
<br>0x0005 = ellipse (DPELLIPSE)
<br>0x0006 = polyline (DPPOLYLINE)
<br>0x0007 = callout textbox (DPCALLOUT)
<br>0x0008 = end of grouping of primitives
<br>0x0009 = sample primitve holding default values (DPSAMPLE)</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cb</td>

<td>U16</td>

<td></td>

<td></td>

<td>size (count of bytes) of this DP</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>xa</td>

<td>U16</td>

<td></td>

<td></td>

<td>These 2 points describe the rectangle enclosing this DP relative to
the origin of the DO</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>ya</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>dxa</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>10</td>

<td>a</td>

<td>dya</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>
<a NAME="DPLINE"></a>
<h3>
DP data for a line (DPLINE)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>xaStart</td>

<td>U16</td>

<td></td>

<td></td>

<td>starting point for line</td>
</tr>

<tr>
<td>14</td>

<td>e</td>

<td>yaStart</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>xaEnd</td>

<td>U16</td>

<td></td>

<td></td>

<td>ending point for line</td>
</tr>

<tr>
<td>14</td>

<td>e</td>

<td>yaEnd</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style
<br>0 Solid&nbsp;
<br>1 Dashed&nbsp;
<br>2 Dotted&nbsp;
<br>3 Dash Dot&nbsp;
<br>4 Dash Dot Dot&nbsp;
<br>5 Hollow</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>eppsStart</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>Start EndPoint Property Style 0 None&nbsp;
<br>1 Hollow&nbsp;
<br>2 Filled</td>
</tr>

<tr>
<td></td>

<td></td>

<td>eppwStart</td>

<td>U16</td>

<td>:2</td>

<td>000c</td>

<td>Start EndPoint Property Weight</td>
</tr>

<tr>
<td></td>

<td></td>

<td>epplStart</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>Start EndPoint Property length</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused24_6</td>

<td>U16</td>

<td>:10</td>

<td></td>

<td></td>
</tr>

<tr>
<td>26</td>

<td>1a</td>

<td>eppsEnd</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>End EndPoint Property Style</td>
</tr>

<tr>
<td></td>

<td></td>

<td>eppwEnd</td>

<td>U16</td>

<td>:2</td>

<td>000c</td>

<td>End EndPoint Property Weight</td>
</tr>

<tr>
<td></td>

<td></td>

<td>epplEnd</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>End EndPoint Property length</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused26_6</td>

<td>U16</td>

<td>:10</td>

<td></td>

<td></td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>
</table>
<a NAME="DPPOLYLINE"></a>
<h3>
DP data for a polyline (DPPOLYLINE)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style. See description in DPLINE.</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dlpcFg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color ForeGround -- RGB color value</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dlpcBg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color BackGround -- RGB color value</td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>flpp</td>

<td>U16</td>

<td></td>

<td></td>

<td>FiLl Property Pattern. REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>eppsStart</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>Start EndPoint Property Style
<br>0 None
<br>1 Hollow
<br>2 Filled</td>
</tr>

<tr>
<td></td>

<td></td>

<td>eppwStart</td>

<td>U16</td>

<td>:2</td>

<td>000c</td>

<td>Start EndPoint Property Weight</td>
</tr>

<tr>
<td></td>

<td></td>

<td>epplStart</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>Start EndPoint Property length</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused30_6</td>

<td>U16</td>

<td>:10</td>

<td></td>

<td></td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>eppsEnd</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>End EndPoint Property Style</td>
</tr>

<tr>
<td></td>

<td></td>

<td>eppwEnd</td>

<td>U16</td>

<td>:2</td>

<td>000c</td>

<td>End EndPoint Property Weight</td>
</tr>

<tr>
<td></td>

<td></td>

<td>epplEnd</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>End EndPoint Property length</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused32_6</td>

<td>U16</td>

<td>:10</td>

<td></td>

<td></td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>fPolygon</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 if this is a polygon</td>
</tr>

<tr>
<td></td>

<td></td>

<td>cpt</td>

<td>U16</td>

<td>:15</td>

<td>00fe</td>

<td>count of points</td>
</tr>

<tr>
<td>42</td>

<td>2a</td>

<td>xaFirst</td>

<td>U16</td>

<td></td>

<td></td>

<td>These are the endpoints of the first line.</td>
</tr>

<tr>
<td>44</td>

<td>2c</td>

<td>yaFirst</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>46</td>

<td>2e</td>

<td>xaEnd</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>yaEnd</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>50</td>

<td>32</td>

<td>rgpta</td>

<td>U16[]</td>

<td></td>

<td></td>

<td>An array of xa,ya pairs for the remaining points</td>
</tr>
</table>
<a NAME="DPRECT"></a>
<h3>
DP data for a rectangle (DPRECT)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style. See description in DPLINE.</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dlpcFg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color ForeGround -- RGB color value</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dlpcBg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color BackGround -- RGB color value</td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>flpp</td>

<td>U16</td>

<td></td>

<td></td>

<td>FiLl Property Pattern. REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>fRoundCorners</td>

<td>U16</td>

<td>:1&nbsp;</td>

<td>0001</td>

<td>1 if the textbox has rounded corners</td>
</tr>

<tr>
<td></td>

<td></td>

<td>zaShape</td>

<td>U16</td>

<td>:15</td>

<td>000e</td>

<td>REVIEW davebu</td>
</tr>
</table>
<a NAME="DPSAMPLE"></a>
<h3>
DP data for a sample primitive holding default values (DPSAMPLE)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style. See description in DPLINE.</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dlpcFg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color ForeGround -- RGB color value</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dlpcBg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color BackGround -- RGB color value</td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>flpp</td>

<td>U16</td>

<td></td>

<td></td>

<td>FiLl Property Pattern. REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>eppsStart</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>Start EndPoint Property Style
<br>0 None
<br>1 Hollow
<br>2 Filled</td>
</tr>

<tr>
<td></td>

<td></td>

<td>eppwStart</td>

<td>U16</td>

<td>:2</td>

<td>000c</td>

<td>Start EndPoint Property Weight</td>
</tr>

<tr>
<td></td>

<td></td>

<td>epplStart</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>Start EndPoint Property length</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused30_6</td>

<td>U16</td>

<td>:10</td>

<td></td>

<td></td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>eppsEnd</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>End EndPoint Property Style</td>
</tr>

<tr>
<td></td>

<td></td>

<td>eppwEnd</td>

<td>U16</td>

<td>:2</td>

<td>000c</td>

<td>End EndPoint Property Weight</td>
</tr>

<tr>
<td></td>

<td></td>

<td>epplEnd</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>End EndPoint Property length</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused32_6</td>

<td>U16</td>

<td>:10</td>

<td></td>

<td></td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>unused40</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>42</td>

<td>2a</td>

<td>dzaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>44</td>

<td>2c</td>

<td>dzaDescent</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>46</td>

<td>2e</td>

<td>dzaLength</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>fRoundCorners</td>

<td>U16</td>

<td>:1&nbsp;</td>

<td>0001</td>

<td>1 if the textbox has rounded corners</td>
</tr>

<tr>
<td></td>

<td></td>

<td>zaShape&nbsp;</td>

<td>U16</td>

<td>:15</td>

<td>000fe</td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>50</td>

<td>32</td>

<td>dzaInternalMargin</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>
</table>
<a NAME="DPTXBX"></a>
<h3>
DP data for a textbox (DPTXBX)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dphead</td>

<td>DPHEAD</td>

<td>12</td>

<td></td>

<td>Common header for a drawing primitive</td>
</tr>

<tr>
<td>12</td>

<td>c</td>

<td>lnpc</td>

<td>U32</td>

<td></td>

<td></td>

<td>LiNe Property Color -- RGB color value</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lnpw</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property weight in twips</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>lnps</td>

<td>U16</td>

<td></td>

<td></td>

<td>line property style. See description in DPLINE.</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dlpcFg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color ForeGround -- RGB color value</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dlpcBg</td>

<td>U32</td>

<td></td>

<td></td>

<td>FiLl Property Color BackGround -- RGB color value</td>
</tr>

<tr>
<td>28</td>

<td>1c</td>

<td>flpp</td>

<td>U16</td>

<td></td>

<td></td>

<td>FiLl Property Pattern. REVIEW davebu</td>
</tr>

<tr>
<td>30</td>

<td>1e</td>

<td>shdwpi</td>

<td>U16</td>

<td></td>

<td></td>

<td>Shadow Property Intensity</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>xaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>x offset of shadow</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>yaOffset</td>

<td>U16</td>

<td></td>

<td></td>

<td>y offset of shadow</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>fRoundCorners</td>

<td>U16</td>

<td>:1&nbsp;</td>

<td>0001</td>

<td>1 if the textbox has rounded corners</td>
</tr>

<tr>
<td></td>

<td></td>

<td>zaShape</td>

<td>U16</td>

<td>:15</td>

<td>000e</td>

<td>REVIEW davebu</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>dzaInternalMargin</td>

<td>U16</td>

<td></td>

<td></td>

<td>REVIEW davebu</td>
</tr>
</table>
<a NAME="DTTM"></a>
<h3>
Date and Time (internal date format) (DTTM)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>mint</td>

<td>U16</td>

<td>:6</td>

<td>003F</td>

<td>minutes (0-59)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>hr</td>

<td>U16</td>

<td>:5</td>

<td>07C0</td>

<td>hours (0-23)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dom</td>

<td>U16</td>

<td>:5</td>

<td>F800</td>

<td>days of month (1-31)</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>mon</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td>months (1-12)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>yr</td>

<td>U16</td>

<td>:9</td>

<td>1FF0</td>

<td>years (1900-2411)-1900</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wdy</td>

<td>U16</td>

<td>:3</td>

<td>E000</td>

<td>weekday
<br>Sunday=0
<br>Monday=1
<br>Tuesday=2
<br>Wednesday=3
<br>Thursday=4
<br>Friday=5
<br>Saturday=6</td>
</tr>
</table>
<a NAME="FDOA"></a>
<h3>
File Drawn Object Address (Word) (FDOA)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fc</td>

<td>U32</td>

<td></td>

<td></td>

<td>FC pointing to drawing object data</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>ctxbx</td>

<td>U16</td>

<td></td>

<td></td>

<td>count of textboxes in the drawing object&nbsp;</td>
</tr>
</table>
<a NAME="FFN"></a>
<h3>
Font Family Name (FFN)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cbFfnM1</td>

<td>U8</td>

<td></td>

<td></td>

<td>total length of FFN - 1.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>prq</td>

<td>U8</td>

<td>:2</td>

<td>03</td>

<td>pitch request</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTrueType</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when 1, font is a TrueType font</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused1_3</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ff</td>

<td>U8</td>

<td>:3</td>

<td>70</td>

<td>font family id</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused1_7</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>reserved</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>wWeight</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>base weight of font</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>chs</td>

<td>U8</td>

<td></td>

<td></td>

<td>character set identifier</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>ibszAlt</td>
<!-- convert="(ixchSzAlt)" -->

<td>U8</td>

<td></td>

<td></td>

<td>index into ffn.szFfn to the name of the alternate font</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>szFfn</td>
<!-- convert="(xszFfn)" -->

<td>U8[]</td>

<td></td>

<td></td>

<td>zero terminated string that records name of font. Possibly followed
by a second sz which records the name of an alternate font to use if the
first named font does not exist on this system. Maximal size of szFfn is
65 characters.</td>
</tr>
</table>
<a NAME="FIB"></a>
<h3>
File Information Block (Windows Word) (FIB)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>wIdent</td>

<td>U16</td>

<td></td>

<td></td>

<td>magic number&nbsp;</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>nFib</td>

<td>U16</td>

<td></td>

<td></td>

<td>FIB version written&nbsp;</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>nProduct</td>

<td>U16</td>

<td></td>

<td></td>

<td>product version written by</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>lid</td>

<td>U16</td>

<td></td>

<td></td>

<td>language stamp---localized version;&nbsp;
<p>In pre-WinWord2.0 files this value was the nLocale.If value is &lt;
999, then it is the nLocale, otherwise it is the lid.</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>pnNext</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>fDot</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fGlsy</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fComplex</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>when 1, file is in complex, fast-saved format.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHasPic</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>file contains 1 or more pictures</td>
</tr>

<tr>
<td></td>

<td></td>

<td>cQuickSaves</td>

<td>U16</td>

<td>:4</td>

<td>00F0</td>

<td>count of times file was quicksaved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEncrypted</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>1 if file is encrypted, 0 if not</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused10_9</td>
<!-- convert="unused" -->

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fReadOnlyRecommended</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>=1 when user has recommended that file be read read-only</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWriteReservation</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>=1, when file owner has made the file write reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fExtChar</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td>=1, when using extended character set in file</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused10_13</td>
<!-- convert="unused" -->

<td>U16</td>

<td>:3</td>

<td>E000</td>

<td>unused</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>nFibBack</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>lKey</td>

<td>U32</td>

<td></td>

<td></td>

<td>file encrypted key, only valid if fEncrypted.</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>envr</td>

<td>U8</td>

<td></td>

<td></td>

<td>environment in which file was created
<br>0 created by Win Word&nbsp;
<br>1 created by Mac Word</td>
</tr>

<tr>
<td>19</td>

<td>13</td>

<td>unused19</td>
<!-- convert="unused" -->

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>chse</td>
<!-- convert="(chs)" -->

<td>U16</td>

<td></td>

<td></td>

<td>default extended character set id for text in document stream. (overidden&nbsp;
by chp.chse)
<br>0 by default characters in doc stream should be interpreted using the
ANSI character set used by Windows
<br>256 characters in doc stream should be interpreted using the Macintosh
character set.</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>chseTables</td>
<!-- convert="(chsTables)" -->

<td>U16</td>

<td></td>

<td></td>

<td>default extended character set id for text in internal data structures
<br>0 by default characters in doc stream should be interpreted using the
ANSI character set used by Windows
<br>256 characters in doc stream should be interpreted using the Macintosh
character set.</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>fcMin</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of first character of text. In non-complexfiles a CP can
be transformed into an FC by the following transformation: fc = cp + fib.fcMin.</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>fcMac</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of last character of text in document text stream+ 1</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>cbMac</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of last byte written to file + 1.</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>fcSpare0</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>fcSpare1</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>fcSpare2</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>fcSpare3</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>ccpText</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of main document text stream</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>ccpFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of footnote subdocument text stream</td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>ccpHdd</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of header subdocument text stream</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>ccpMcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of macro subdocument text stream</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>ccpAtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of annotation subdocument text stream</td>
</tr>

<tr>
<td>72</td>

<td>48</td>

<td>ccpEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of endnote subdocument text stream</td>
</tr>

<tr>
<td>76</td>

<td>4C</td>

<td>ccpTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of textbox subdocument text stream&nbsp;</td>
</tr>

<tr>
<td>80</td>

<td>50</td>

<td>ccpHdrTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of header textbox subdocument text stream&nbsp;
<p>Note: when ccpFtn == 0 and ccpHdr == 0 and ccpMcr== 0 and ccpAtn ==
0 and ccpEdn ==0 and ccpTxbx == 0 and ccpHdrTxbx == 0, then fib.fcMac =
fib.fcMin+ fib.ccpText. If either ccpFtn != 0 or ccpHdd != 0or ccpMcr !=
0or ccpAtn != 0 or ccpEdn !=0 or ccpTxbx != 0 or ccpHdrTxbx == 0, then
fib.fcMac = fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdd+ fib.ccpMcr+
fib.ccpAtn + fib.ccpEdn + fib.ccpTxbx + fib.ccpHdrTxbx + 1. The single
characterstored beginning at file position fib.fcMac - 1 must always be
a CRcharacter (ASCII 13).</td>
</tr>

<tr>
<td>84</td>

<td>54</td>

<td>ccpSpare2</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>88</td>

<td>58</td>

<td>fcStshfOrig</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of original allocation for STSH in file. During fast save
Word will attempt to reuse this allocation if STSH is small enough to fit.&nbsp;</td>
</tr>

<tr>
<td>92</td>

<td>5C</td>

<td>lcbStshfOrig</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of original STSH allocation</td>
</tr>

<tr>
<td>96</td>

<td>60</td>

<td>fcStshf</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of STSH in file.</td>
</tr>

<tr>
<td>100</td>

<td>64</td>

<td>lcbStshf</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of current STSH allocation</td>
</tr>

<tr>
<td>104</td>

<td>68</td>

<td>fcPlcffndRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of footnote reference PLC. CPs in PLC are relative to main
document text stream and give location of footnote references. The structure
stored in this plc, called the FRD (footnote reference descriptor) is two
byte long.</td>
</tr>

<tr>
<td>108</td>

<td>6C</td>

<td>lcbPlcffndRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of footnote reference PLC. == 0 if no footnotes defined
in document.</td>
</tr>

<tr>
<td>112</td>

<td>70</td>

<td>fcPlcffndTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of footnote text PLC. CPs in PLC are relative to footnote
subdocument text stream and give location of beginnings of footnote text
for correspondings references recorded in plcffndRef. No structure is stored
in this plc. There will just be n+1 FC entries in this PLC when there are
n footnotes</td>
</tr>

<tr>
<td>116</td>

<td>74</td>

<td>lcbPlcffndTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of footnote text PLC. == 0 if no footnotes defined in
document</td>
</tr>

<tr>
<td>120</td>

<td>78</td>

<td>fcPlcfandRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of annotation reference PLC. The CPs recorded in this PLC
give the offset of annotation references in the main document.</td>
</tr>

<tr>
<td>124</td>

<td>7C</td>

<td>lcbPlcfandRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of annotation reference PLC.</td>
</tr>

<tr>
<td>128</td>

<td>80</td>

<td>fcPlcfandTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of annotation text PLC. The Cps recorded in this PLC give
the offset of the annotation text in the annotation sub document corresponding
to the references stored in the plcfandRef. There is a 1 to 1 correspondence
between entries recorded in the plcfandTxt and the plcfandRef.</td>
</tr>

<tr>
<td>132</td>

<td>84</td>

<td>lcbPlcfandTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the annotation text PLC</td>
</tr>

<tr>
<td>136</td>

<td>88</td>

<td>fcPlcfsed</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of section descriptor PLC. CPs in PLC are relative to main
document. The length of the SED is 12 bytes.</td>
</tr>

<tr>
<td>140</td>

<td>8C</td>

<td>lcbPlcfsed</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of section descriptor PLC.</td>
</tr>

<tr>
<td>144</td>

<td>90</td>

<td>fcPlcfpad</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of paragraph descriptor PLCfor main document which is used
by Word's Outline view. CPs in PLC are relative to main document. The length
of the PGD is 8 bytes.</td>
</tr>

<tr>
<td>148</td>

<td>94</td>

<td>lcbPlcfpad</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of paragraph descriptor PLC. ==0 if file was never viewed
in Outline view. Should not be written by third party creators of Word
files.</td>
</tr>

<tr>
<td>152</td>

<td>98</td>

<td>fcPlcfphe</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of PLC of paragraph heights. CPs in PLC are relative to
main document text stream. Only written for fies in complex format. Should
not be written by third party creators of Word files. The PHE is 6 bytes
long.</td>
</tr>

<tr>
<td>156</td>

<td>9C</td>

<td>lcbPlcfphe</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of paragraph height PLC. ==0 when file is non-complex.</td>
</tr>

<tr>
<td>160</td>

<td>A0</td>

<td>fcSttbfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of glossary string table. This table consists of pascal
style strings (strings stored prefixed with a length byte) concatenated
one after another.</td>
</tr>

<tr>
<td>164</td>

<td>A4</td>

<td>lcbSttbfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of glossary string table.
<br>== 0 for non-glossary documents.&nbsp;
<br>!=0 for glossary documents.</td>
</tr>

<tr>
<td>168</td>

<td>A8</td>

<td>fcPlcfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of glossary PLC. CPs in PLC are relative to main document
and mark the beginnings of glossary entries and are in 1-1 correspondence
with entries of sttbfglsy. No structure is stored in this PLC. There will
be n+1 FC entries in this PLC when there are n glossary entries.</td>
</tr>

<tr>
<td>172</td>

<td>AC</td>

<td>lcbPlcfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of glossary PLC.
<br>== 0 for non-glossary documents.&nbsp;
<br>!=0 for glossary documents.</td>
</tr>

<tr>
<td>176</td>

<td>B0</td>

<td>fcPlcfhdd</td>

<td>U32</td>

<td></td>

<td></td>

<td>byte offset of header PLC. CPs are relative to header subdocument and
mark the beginnings of individual headers in the header subdoc. No structure
is stored in this PLC. There will be n+1 FC entries in this PLC when there
are n headers stored for the document.</td>
</tr>

<tr>
<td>180</td>

<td>B4</td>

<td>lcbPlcfhdd</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of header PLC. == 0 if document contains no headers</td>
</tr>

<tr>
<td>184</td>

<td>B8</td>

<td>fcPlcfbteChpx</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of character property bin table.PLC. FCs in PLC are file
offsets. Describes text of main document and all subdocuments. The BTE
is 2 bytes long.</td>
</tr>

<tr>
<td>188</td>

<td>BC</td>

<td>lcbPlcfbteChpx</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of character property bin table PLC.</td>
</tr>

<tr>
<td>192</td>

<td>C0</td>

<td>fcPlcfbtePapx</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of paragraph property bin table.PLC. FCs in PLC are file
offsets. Describes text of main document and all subdocuments. The BTE
is 2 bytes long.</td>
</tr>

<tr>
<td>196</td>

<td>C4</td>

<td>lcbPlcfbtePapx</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of paragraph property bin table PLC.</td>
</tr>

<tr>
<td>200</td>

<td>C8</td>

<td>fcPlcfsea</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of PLC reserved for private use. The SEA is 6 bytes long.</td>
</tr>

<tr>
<td>204</td>

<td>CC</td>

<td>lcbPlcfsea</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of private use PLC.</td>
</tr>

<tr>
<td>208</td>

<td>DO</td>

<td>fcSttbfffn</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of font information STTBF. The nth entry in the STTBF describes
the font that will be displayed when the chp.ftc for text is equal to n.
See the FFN file structure definition.</td>
</tr>

<tr>
<td>212</td>

<td>D4</td>

<td>lcbSttbfffn</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes in sttbfffn.</td>
</tr>

<tr>
<td>216</td>

<td>D8</td>

<td>fcPlcffldMom</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream to the PLC of field positions in the main document.
The Cps point to the beginning CP of a field, the CP offield separator
character inside a field and the ending CP of the field. A field may be
nested within another field. 20 levels of field nesting are allowed.</td>
</tr>

<tr>
<td>220</td>

<td>DC</td>

<td>lcbPlcffldMom</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>224</td>

<td>E0</td>

<td>fcPlcffldHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream to the PLC of field positions in the header subdocument.</td>
</tr>

<tr>
<td>228</td>

<td>E4</td>

<td>lcbPlcffldHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>232</td>

<td>E8</td>

<td>fcPlcffldFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream to the PLC of field positions in the footnote
subdocument.</td>
</tr>

<tr>
<td>236</td>

<td>EC</td>

<td>lcbPlcffldFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>240</td>

<td>F0</td>

<td>fcPlcffldAtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream to the PLC of field positions in the annotation
subdocument.</td>
</tr>

<tr>
<td>244</td>

<td>F4</td>

<td>lcbPlcffldAtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>248</td>

<td>F8</td>

<td>fcPlcffldMcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream to the PLC of field positions in the macro subdocument.</td>
</tr>

<tr>
<td>252</td>

<td>U32</td>

<td>lcbPlcffldMcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>256</td>

<td>100</td>

<td>fcSttbfbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in document stream of the STTBF that records bookmark names
in the main document</td>
</tr>

<tr>
<td>260</td>

<td>104</td>

<td>lcbSttbfbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>264</td>

<td>108</td>

<td>fcPlcfbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in document stream of the PLCF that records the beginning CP
offsets of bookmarks in the main document. See BKF structure definition</td>
</tr>

<tr>
<td>268</td>

<td>10C</td>

<td>lcbPlcfbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>272</td>

<td>110</td>

<td>fcPlcfbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in document stream of the PLCF that records the ending CP offsets
of bookmarks recorded in the main document. See the BKL structure definition.</td>
</tr>

<tr>
<td>276</td>

<td>114</td>

<td>lcbPlcfbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>280</td>

<td>118</td>

<td>fcCmds</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>284</td>

<td>11C</td>

<td>lcbCmds</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>288</td>

<td>120</td>

<td>fcPlcmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>292</td>

<td>124</td>

<td>lcbPlcmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>296</td>

<td>128</td>

<td>fcSttbfmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>300</td>

<td>12C</td>

<td>lcbSttbfmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>304</td>

<td>130</td>

<td>fcPrDrvr</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of the printer driver information (names of drivers, port
etc...)</td>
</tr>

<tr>
<td>308</td>

<td>134</td>

<td>lcbPrDrvr</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the printer driver information (names of drivers,
port etc...)</td>
</tr>

<tr>
<td>312</td>

<td>138</td>

<td>fcPrEnvPort</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of the print environment in portrait mode.</td>
</tr>

<tr>
<td>316</td>

<td>13C</td>

<td>lcbPrEnvPort</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the print environment in portrait mode.</td>
</tr>

<tr>
<td>320</td>

<td>140</td>

<td>fcPrEnvLand</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of the print environment in landscape mode.</td>
</tr>

<tr>
<td>324</td>

<td>144</td>

<td>lcbPrEnvLand</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the print environment in landscape mode.</td>
</tr>

<tr>
<td>328</td>

<td>148</td>

<td>fcWss</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of Window Save State data structure. WSS contains dimensions
of document's main text window and the last selection made by Word user.&nbsp;</td>
</tr>

<tr>
<td>332</td>

<td>14C</td>

<td>lcbWss</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of WSS. ==0 if unable to store the window state. Should
not be written by third party creators of Word files.</td>
</tr>

<tr>
<td>336</td>

<td>150</td>

<td>fcDop</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of document property data structure.</td>
</tr>

<tr>
<td>340</td>

<td>154</td>

<td>lcbDop</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of document properties.</td>
</tr>

<tr>
<td>344</td>

<td>158</td>

<td>fcSttbfAssoc</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset to STTBF of associated strings. The strings in this table specify
document summary info and the paths to special documents related to this
document. See documentation of the STTBFASSOC.</td>
</tr>

<tr>
<td>348</td>

<td>15C</td>

<td>lcbSttbfAssoc</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>352</td>

<td>160</td>

<td>fcClx</td>

<td>U32</td>

<td></td>

<td></td>

<td>file of offset of beginning of information for complex files. Consists
of an encoding of all of the prms quoted by the document followed by the
plcpcd (piece table) for the document.&nbsp;</td>
</tr>

<tr>
<td>356</td>

<td>164</td>

<td>lcbClx</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of complex file information. == 0 if file is non-complex.</td>
</tr>

<tr>
<td>360</td>

<td>168</td>

<td>fcPlcfpgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of page descriptor PLC for footnote subdocument. CPs in
PLC are relative to footnote subdocument. Should not be written by third
party creators of Word files.&nbsp;</td>
</tr>

<tr>
<td>364</td>

<td>16C</td>

<td>lcbPlcfpgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of page descriptor PLC for footnote subdocument. ==0
if document has not been paginated. The length of the PGD is 8 bytes.</td>
</tr>

<tr>
<td>368</td>

<td>170</td>

<td>fcAutosaveSource</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of the name of the original file.fcAutosaveSource and cbAutosaveSource
should both be 0 if autosave is off.</td>
</tr>

<tr>
<td>372</td>

<td>174</td>

<td>lcbAutosaveSource</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the name of the original file.</td>
</tr>

<tr>
<td>376</td>

<td>178</td>

<td>fcGrpStAtnOwners</td>
<!-- convert="(fcGrpXstAtnOwners)" -->

<td>U32</td>

<td></td>

<td></td>

<td>group of strings recording the names of the owners of annotations stored
in the document</td>
</tr>

<tr>
<td>380</td>

<td>17C</td>

<td>lcbGrpStAtnOwners</td>
<!-- convert="(lcbGrpXstAtnOwners)" -->

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the group of strings</td>
</tr>

<tr>
<td>384</td>

<td>180</td>

<td>fcSttbfAtnbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of the sttbf that records names of bookmarks in the annotation
subdocument</td>
</tr>

<tr>
<td>388</td>

<td>184</td>

<td>lcbSttbfAtnbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the sttbf that records names of bookmarks in the
annotation subdocument</td>
</tr>

<tr>
<td>392</td>

<td>188</td>

<td>wSpare4Fib</td>
<!-- convert="unused" -->

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>394</td>

<td>18A</td>

<td>pnChpFirst</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>the page number of the lowest numbered page in the document that records
CHPX FKP information</td>
</tr>

<tr>
<td>396</td>

<td>18C</td>

<td>pnPapFirst</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>the page number of the lowest numbered page in the document that records
PAPX FKP information</td>
</tr>

<tr>
<td>398</td>

<td>18E</td>

<td>cpnBteChp</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>count of CHPX FKPs recorded in file. In non-complexfiles if the number
of entries in the plcfbteChpxis less than this, the plcfbteChpxis incomplete.</td>
</tr>

<tr>
<td>400</td>

<td>190</td>

<td>cpnBtePap</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>count of PAPX FKPs recorded in file. In non-complexfiles if the number
of entries in the plcfbtePapxis less than this, the plcfbtePapxis incomplete.</td>
</tr>

<tr>
<td>402</td>

<td>192</td>

<td>fcPlcfdoaMom</td>
<!-- convert="(fcPlcdoaMom)" -->

<td>U32</td>

<td></td>

<td></td>

<td>file offset of theFDOA (drawn object) PLC for main document. ==0 if
document has no drawn objects. The length of the FDOA is 6 bytes.</td>
</tr>

<tr>
<td>406</td>

<td>196</td>

<td>lcbPlcfdoaMom</td>
<!-- convert="(lcbPlcdoaMom)" -->

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the FDOA PLC of the main document</td>
</tr>

<tr>
<td>410</td>

<td>19A</td>

<td>fcPlcfdoaHdr</td>
<!-- convert="(fcPlcdoaHdr)" -->

<td>U32</td>

<td></td>

<td></td>

<td>file offset of theFDOA (drawn object) PLC for the header document.
==0 if document has no drawn objects. The length of the FDOA is 6 bytes.</td>
</tr>

<tr>
<td>414</td>

<td>19E</td>

<td>lcbPlcfdoaHdr</td>
<!-- convert="(lcbPlcdoaHdr)" -->

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the FDOA PLC of the header document</td>
</tr>

<tr>
<td>418</td>

<td>1A2</td>

<td>fcUnused1</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>422</td>

<td>1A6</td>

<td>lcbUnused1</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>426</td>

<td>1AA</td>

<td>fcUnused2</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>430</td>

<td>1AE</td>

<td>lcbUnused2</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>434</td>

<td>1B2</td>

<td>fcPlcfAtnbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of BKF (bookmark first) PLC of the annotation subdocument</td>
</tr>

<tr>
<td>438</td>

<td>1B6</td>

<td>lcbPlcfAtnbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of BKF (bookmark first) PLC of the annotation subdocument</td>
</tr>

<tr>
<td>442</td>

<td>1BA</td>

<td>fcPlcfAtnbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of BKL (bookmark last) PLC of the annotation subdocument</td>
</tr>

<tr>
<td>446</td>

<td>1BE</td>

<td>lcbPlcfAtnbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of BKL (bookmark first) PLC of the annotation subdocument</td>
</tr>

<tr>
<td>450</td>

<td>1C2</td>

<td>fcPms</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of PMS (Print Merge State) information block</td>
</tr>

<tr>
<td>454</td>

<td>1C6</td>

<td>lcbPms</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of PMS</td>
</tr>

<tr>
<td>458</td>

<td>1CA</td>

<td>fcFormFldSttbf</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of form field Sttbf which contains strings used in form
field dropdown controls</td>
</tr>

<tr>
<td>462</td>

<td>1CE</td>

<td>lcbFormFldSttbf</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of form field Sttbf</td>
</tr>

<tr>
<td>466</td>

<td>1D2</td>

<td>fcPlcfendRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of PlcfendRef which points to endnote references in the
main document stream</td>
</tr>

<tr>
<td>470</td>

<td>1D6</td>

<td>lcbPlcfendRef</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>474</td>

<td>1DA</td>

<td>fcPlcfendTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of PlcfendRef which points to endnote textin the endnote
document stream which corresponds with the plcfendRef</td>
</tr>

<tr>
<td>478&nbsp;</td>

<td>1DE</td>

<td>lcbPlcfendTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>482</td>

<td>1E2</td>

<td>fcPlcffldEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset to PLCF of field positions in the endnote subdoc</td>
</tr>

<tr>
<td>486</td>

<td>1E6</td>

<td>lcbPlcffldEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>490</td>

<td>1EA</td>

<td>fcPlcfpgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset to PLCF of page boundaries in the endnote subdoc.</td>
</tr>

<tr>
<td>494</td>

<td>1EE</td>

<td>lcbPlcfpgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>498</td>

<td>1F2</td>

<td>fcUnused3</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>502</td>

<td>1F6</td>

<td>lcbUnused3</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>506</td>

<td>1FA</td>

<td>fcSttbfRMark</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset to STTBF that records the author abbreviations for authors who
have made revisions in the document.</td>
</tr>

<tr>
<td>510</td>

<td>1FE</td>

<td>lcbSttbfRMark</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>514</td>

<td>202</td>

<td>fcSttbfCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset to STTBF that records caption titles used in the document.</td>
</tr>

<tr>
<td>518</td>

<td>206</td>

<td>lcbSttbfCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>522</td>

<td>20A</td>

<td>fcSttbfAutoCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>526</td>

<td>20E</td>

<td>lcbSttbfAutoCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>530</td>

<td>212</td>

<td>fcPlcfwkb</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset to PLCF that describes the boundaries of contributing documents
in a master document</td>
</tr>

<tr>
<td>534</td>

<td>216</td>

<td>lcbPlcfwkb</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>538</td>

<td>21A</td>

<td>fcUnused4</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>542</td>

<td>21E</td>

<td>lcbUnused4</td>
<!-- convert="unused" -->

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>546</td>

<td>222</td>

<td>fcPlcftxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream of PLCF that records the beginning CP in the text
box subdoc of the text of individual text box entries</td>
</tr>

<tr>
<td>550</td>

<td>226</td>

<td>lcbPlcftxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>554</td>

<td>22A</td>

<td>fcPlcffldTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream of the PLCF that records field boundaries recorded
in the textbox subdoc.</td>
</tr>

<tr>
<td>558</td>

<td>22E</td>

<td>lcbPlcffldTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>562</td>

<td>232</td>

<td>fcPlcfHdrtxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream of PLCF that records the beginning CP in the header
text box subdoc of the text of individual header text box entries</td>
</tr>

<tr>
<td>566</td>

<td>236</td>

<td>lcbPlcfHdrtxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>570</td>

<td>23A</td>

<td>fcPlcffldHdrTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in doc stream of the PLCF that records field boundaries recorded
in the header textbox subdoc.</td>
</tr>

<tr>
<td>574</td>

<td>23E</td>

<td>lcbPlcffldHdrTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>578</td>

<td>242</td>

<td>fcStwUser</td>

<td>U32</td>

<td></td>

<td></td>

<td>Macro User storage</td>
</tr>

<tr>
<td>582</td>

<td>246</td>

<td>lcbStwUser</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>586</td>

<td>24A</td>

<td>fcSttbttmbd</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>590</td>

<td>24E</td>

<td>lcbSttbttmbd</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>594</td>

<td>252</td>

<td>fcUnused</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>598</td>

<td>256</td>

<td>lcbUnused</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>602</td>

<td>25A</td>

<td>fcPgdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>606</td>

<td>25E</td>

<td>lcbPgdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>610</td>

<td>262</td>

<td>fcBkdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>614</td>

<td>266</td>

<td>lcbBkdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>616</td>

<td>26A</td>

<td>fcPgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>620</td>

<td>26E</td>

<td>lcbPgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>624</td>

<td>272</td>

<td>fcBkdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>628</td>

<td>276</td>

<td>lcbBkdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>632</td>

<td>27A</td>

<td>fcPgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>636</td>

<td>27E</td>

<td>lcbPgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>640</td>

<td>282</td>

<td>fcBkdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>644</td>

<td>286</td>

<td>lcbBkdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>648</td>

<td>28A</td>

<td>fcSttbfIntlFld</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>652</td>

<td>28E</td>

<td>lcbSttbfIntlFld</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>656</td>

<td>292</td>

<td>fcRouteSlip</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>660</td>

<td>296</td>

<td>lcbRouteSlip</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>664</td>

<td>29A</td>

<td>fcSttbSavedBy</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>668</td>

<td>29E</td>

<td>lcbSttbSavedBy</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>672</td>

<td>2A2</td>

<td>fcSttbFnm</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>676</td>

<td>2A6</td>

<td>lcbSttbFnm</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>

<p>cbFIB is 682. cwFIB is 341.
<p>Note: If a table does not exist in the file, its cb in the FIB is zero
and its fc is equal to that of the following table (the latter equality
is irrelevant, as the cb should be used to determine existence of the table).&nbsp;<a NAME="FLD"></a>
<h3>
Field Descriptor (FLD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ch</td>

<td>U8</td>

<td></td>

<td></td>

<td>type of field boundary the FLD describes.&nbsp;
<br>19 field begin mark
<br>20 field separator
<br>21 field end mark</td>
</tr>
</table>


<p class="field">variant used when fld.ch == 19(field begin mark)
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>1</td>

<td>1</td>

<td>flt</td>

<td>U8</td>

<td></td>

<td></td>

<td>field type&nbsp;
<p>see flt table below</td>
</tr>
</table>


<p class="field">variant used when fld.ch == 21(field end mark)
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>1</td>

<td>1</td>

<td>fDiffer</td>

<td>U16</td>

<td>:1</td>

<td>01</td>

<td>ignored for saved file</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fZombieEmbed</td>

<td>U16</td>

<td>:1</td>

<td>02</td>

<td>==1, when result still believes this field is an EMBED or LINK field</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fResultDirty</td>

<td>U16</td>

<td>:1</td>

<td>04</td>

<td>== 1, when user has edited or formatted the result. ==0 otherwise</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fResultEdited</td>

<td>U16</td>

<td>:1</td>

<td>08</td>

<td>==1, when user has inserted text into or deleted text from the result.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLocked</td>

<td>U16</td>

<td>:1</td>

<td>10</td>

<td>==1, when field is locked from recalc</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrivateResult</td>

<td>U16</td>

<td>:1</td>

<td>20</td>

<td>==1, whenever the result of the field is never to be shown.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNested</td>

<td>U16</td>

<td>:1</td>

<td>40</td>

<td>==1,when field is nested within another field</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHasSep</td>

<td>U16</td>

<td>:1</td>

<td>80</td>

<td>==1, when field has a field separator</td>
</tr>
</table>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>flt value</td>

<td>field type</td>
</tr>

<tr>
<td>1</td>

<td>unknown keyword</td>
</tr>

<tr>
<td>2</td>

<td>possible bookmark (syntax matches bookmark name)</td>
</tr>

<tr>
<td>3</td>

<td>bookmark reference</td>
</tr>

<tr>
<td>4</td>

<td>index entry</td>
</tr>

<tr>
<td>5</td>

<td>footnote reference</td>
</tr>

<tr>
<td>6</td>

<td>Set command (for Print Merge)</td>
</tr>

<tr>
<td>7</td>

<td>If command (for Print Merge)</td>
</tr>

<tr>
<td>8</td>

<td>create index</td>
</tr>

<tr>
<td>9</td>

<td>table of contents entry</td>
</tr>

<tr>
<td>10</td>

<td>Style reference</td>
</tr>

<tr>
<td>11</td>

<td>document reference</td>
</tr>

<tr>
<td>12</td>

<td>sequence mark</td>
</tr>

<tr>
<td>13</td>

<td>create table-of-contents</td>
</tr>

<tr>
<td>14</td>

<td>quote Info variable</td>
</tr>

<tr>
<td>15</td>

<td>quote Titlevariable</td>
</tr>

<tr>
<td>16</td>

<td>quote Subjectvariable</td>
</tr>

<tr>
<td>17</td>

<td>quote Author variable</td>
</tr>

<tr>
<td>18</td>

<td>quote Keywords variable</td>
</tr>

<tr>
<td>19</td>

<td>quote Comments variable</td>
</tr>

<tr>
<td>20</td>

<td>quote Last Revised By variable</td>
</tr>

<tr>
<td>21</td>

<td>quote Creation Date variable</td>
</tr>

<tr>
<td>22</td>

<td>quote Revision Date variable</td>
</tr>

<tr>
<td>23</td>

<td>quote Print Date variable</td>
</tr>

<tr>
<td>24</td>

<td>quote Revision Number variable</td>
</tr>

<tr>
<td>25</td>

<td>quote Edit Time variable</td>
</tr>

<tr>
<td>26</td>

<td>quote Number of Pages variable</td>
</tr>

<tr>
<td>27</td>

<td>quote Number of Words variable</td>
</tr>

<tr>
<td>28</td>

<td>quote Number of Characters variable</td>
</tr>

<tr>
<td>29</td>

<td>quote File Name variable</td>
</tr>

<tr>
<td>30</td>

<td>quote Document Template Name variable</td>
</tr>

<tr>
<td>31</td>

<td>quote Current Date variable</td>
</tr>

<tr>
<td>32</td>

<td>quote Current Time variable</td>
</tr>

<tr>
<td>33</td>

<td>quote Current Page variable</td>
</tr>

<tr>
<td>34</td>

<td>evaluate expression</td>
</tr>

<tr>
<td>35</td>

<td>insert literal text</td>
</tr>

<tr>
<td>36</td>

<td>Include command (Print Merge)</td>
</tr>

<tr>
<td>37</td>

<td>page reference</td>
</tr>

<tr>
<td>38</td>

<td>Ask command (Print Merge)</td>
</tr>

<tr>
<td>39</td>

<td>Fillin command to display prompt (Print Merge)</td>
</tr>

<tr>
<td>40</td>

<td>Data command (Print Merge)</td>
</tr>

<tr>
<td>41</td>

<td>Next command (Print Merge)</td>
</tr>

<tr>
<td>42</td>

<td>NextIf command (Print Merge)</td>
</tr>

<tr>
<td>43</td>

<td>SkipIf (Print Merge)</td>
</tr>

<tr>
<td>44</td>

<td>inserts number of current Print Merge record</td>
</tr>

<tr>
<td>45</td>

<td>DDE reference</td>
</tr>

<tr>
<td>46</td>

<td>DDE automatic reference</td>
</tr>

<tr>
<td>47</td>

<td>Inserts Glossary Entry</td>
</tr>

<tr>
<td>48</td>

<td>sends characters to printer without translation</td>
</tr>

<tr>
<td>49</td>

<td>Formula definition</td>
</tr>

<tr>
<td>50</td>

<td>Goto Button</td>
</tr>

<tr>
<td>51</td>

<td>Macro Button</td>
</tr>

<tr>
<td>52</td>

<td>insert auto numbering field in outline format</td>
</tr>

<tr>
<td>53</td>

<td>insert auto numbering field in legal format</td>
</tr>

<tr>
<td>54</td>

<td>insert auto numbering field in arabic number format</td>
</tr>

<tr>
<td>55</td>

<td>reads a TIFF file</td>
</tr>

<tr>
<td>56</td>

<td>Link</td>
</tr>

<tr>
<td>57</td>

<td>Symbol</td>
</tr>

<tr>
<td>58</td>

<td>Embedded Object</td>
</tr>

<tr>
<td>59</td>

<td>Merge fields</td>
</tr>

<tr>
<td>60</td>

<td>User Name</td>
</tr>

<tr>
<td>61</td>

<td>User Initial</td>
</tr>

<tr>
<td>62</td>

<td>User Address</td>
</tr>

<tr>
<td>63</td>

<td>Bar code</td>
</tr>

<tr>
<td>65</td>

<td>Section</td>
</tr>

<tr>
<td>66</td>

<td>Section pages</td>
</tr>

<tr>
<td>67</td>

<td>Include Picture&nbsp;</td>
</tr>

<tr>
<td>68</td>

<td>Include Text</td>
</tr>

<tr>
<td>69</td>

<td>File Size</td>
</tr>

<tr>
<td>70</td>

<td>Form Text Box</td>
</tr>

<tr>
<td>71</td>

<td>Form Check Box</td>
</tr>

<tr>
<td>72</td>

<td>Note Reference</td>
</tr>

<tr>
<td>73</td>

<td>Create Table of Authorities</td>
</tr>

<tr>
<td>74</td>

<td>Mark Table of Authorities Entry</td>
</tr>

<tr>
<td>75</td>

<td>Merge record sequence number</td>
</tr>

<tr>
<td>76</td>

<td>Macro</td>
</tr>

<tr>
<td>77</td>

<td>Private</td>
</tr>

<tr>
<td>78</td>

<td>Insert Database</td>
</tr>

<tr>
<td>79</td>

<td>Autotext</td>
</tr>

<tr>
<td>80</td>

<td>Compare two values</td>
</tr>

<tr>
<td>81</td>

<td>Plug-in module private</td>
</tr>

<tr>
<td>82</td>

<td>Subscriber</td>
</tr>

<tr>
<td>83</td>

<td>Form List Box</td>
</tr>

<tr>
<td>84</td>

<td>Advance</td>
</tr>
</table>
<a NAME="LSPD"></a>
<h3>
Line Spacing Descriptor (LSPD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dyaLine</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>see description of sprmPDyaLine in the Sprm Definitions sectionfor
description of the meaning of dyaLine and fMultLinespace fields</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fMultLinespace</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>

<p>cbLSPD is 4.&nbsp;<a NAME="METAFILEPICT"></a>
<h3>
Window's (METAFILEPICT)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>mm</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>Specifies the mapping mode in which the picture is drawn.&nbsp;</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>xExt</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>Specifies the size of the metafile picture for all modes except the
MM_ISOTROPIC and MM_ANISOTROPIC modes. (For more information about these
modes, see the yExt member.) The x-extent specifies the width of the rectangle
within which the picture is drawn. The coordinates are in units that correspond
to the mapping mode.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>yExt</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>Specifies the size of the metafile picture for all modes except the
MM_ISOTROPIC and MM_ANISOTROPIC modes. The y-extent specifies the height
of the rectangle within which the picture is drawn. The coordinates are
in units that correspond to the mapping mode.&nbsp;
<p>For MM_ISOTROPIC and MM_ANISOTROPIC modes, which can be scaled, the
xExt and yExt members contain an optional suggested size in MM_HIMETRIC
units.
<p>For MM_ANISOTROPIC pictures, xExt and yExt can be zero when no suggested
size is supplied. For MM_ISOTROPIC pictures, an aspect ratio must be supplied
even when no suggested size is given. (If a suggested size is given, the
aspect ratio is implied by the size.) To give an aspect ratio without implying
a suggested size, set xExt and yExt to negative values whose ratio is the
appropriate aspect ratio. The magnitude of the negative xExt and yExt values
is ignored; only the ratio is used.</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>hMF</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>Identifies a memory metafile.</td>
</tr>
</table>
<a NAME="OBJHEADER"></a>
<h3>
Embedded Object Properties (OBJHEADER)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>lcb</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of object (including this header)</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cbHeader</td>

<td>U16</td>

<td></td>

<td></td>

<td>length of this header (for future use)</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>icf</td>

<td>U16</td>

<td></td>

<td></td>

<td>index to clipboard format of object</td>
</tr>
</table>
<a NAME="OLST"></a>
<h3>
Outline LiST Data (OLST)</h3>
<!-- sizeOf="212" -->

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>rganlv</td>

<td>ANLV[9]</td>

<td></td>

<td></td>

<td>an array of 9 ANLV structures describing how heading numbers should
be displayed for each of Word?s 9 outline heading levels</td>
</tr>

<tr>
<td>144</td>

<td>90</td>

<td>fRestartHdr</td>

<td>U8</td>

<td></td>

<td></td>

<td>when ==1, restart heading on section break</td>
</tr>

<tr>
<td>145</td>

<td>91</td>

<td>fSpareOlst2</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>146</td>

<td>92</td>

<td>fSpareOlst3</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>147</td>

<td>93</td>

<td>fSpareOlst4</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>148</td>

<td>94</td>

<td>rgch</td>
<!-- convert="string(rgxch:32)" -->

<td>U8[64]</td>

<td></td>

<td></td>

<td>text before/after number</td>
</tr>
</table>

<p>cbOLST is 212(decimal), D4(hex).&nbsp;<a NAME="PAP"></a>
<h3>
Paragraph Properties (PAP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>istd</td>

<td>U16</td>

<td></td>

<td></td>

<td>index to style descriptor . This is an index to an STD in the STSH
structure</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>jc</td>

<td>U8</td>

<td></td>

<td></td>

<td>justification code 0left justify&nbsp;
<br>1center&nbsp;
<br>2right justify&nbsp;
<br>3left and right justify</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>fKeep</td>

<td>U8</td>

<td></td>

<td></td>

<td>keep entire paragraph on one page if possible</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fKeepFollow</td>

<td>U8</td>

<td></td>

<td></td>

<td>keep paragraph on same page with next paragraph if possible</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>fPageBreakBefore</td>

<td>U8</td>

<td></td>

<td></td>

<td>start this paragraph on new page</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fBrLnAbove</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBrLnBelow</td>

<td>U8</td>

<td>:1</td>

<td>0002</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnused</td>

<td>U8</td>

<td>:2</td>

<td>0006</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcVert</td>

<td>U8</td>

<td>:2</td>

<td>0030</td>

<td>vertical position code. Specifies coordinate frame to use when paragraphs
are absolutely positioned.&nbsp;
<br>0 vertical position coordinates are relative to margin&nbsp;
<br>1 coordinates are relative to page&nbsp;
<br>2 coordinates are relative to text.This means: relative to where the
next non-APO text would have been placed if this APO did not exist.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcHorz</td>

<td>U8</td>

<td>:2</td>

<td>00C0</td>

<td>horizontal position code. Specifies coordinate frame to use when paragraphs&nbsp;
are absolutely positioned.
<br>0 horiz. position coordinates are relative to column.&nbsp;
<br>1 coordinates are relative to margin&nbsp;
<br>2 coordinates are relative to page</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>brcp</td>

<td>U8</td>

<td></td>

<td></td>

<td>rectangle border codes (the brcp and brcl fields have been superceded&nbsp;
by the newly defined brcLeft, brcTop, etc. fields. They remain in the PAP&nbsp;
for compatibility with MacWord 3.0)
<br>0 none&nbsp;
<br>1 border above&nbsp;
<br>2 border below&nbsp;
<br>15 box around
<br>16 bar to left of paragraph</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>brcl</td>

<td>U8</td>

<td></td>

<td></td>

<td>border line style&nbsp;
<br>0 single&nbsp;
<br>1 thick
<br>2 double
<br>3 shadow</td>
</tr>

<tr>
<td>9</td>

<td>9</td>

<td>unused9</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>nLvlAnm</td>

<td>U8</td>

<td></td>

<td></td>

<td>auto list numbering level (0 = nothing)</td>
</tr>

<tr>
<td>11</td>

<td>B</td>

<td>fNoLnn</td>

<td>U8</td>

<td></td>

<td></td>

<td>no line numbering for this para. (makes this an exception to the section
property of line numbering)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>fSideBySide</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, paragraph is a side by side paragraph</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaRight</td>
<!-- convert="type" -->

<td>S16</td>

<td></td>

<td></td>

<td>indent from right margin (signed).</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>dxaLeft</td>
<!-- convert="type" -->

<td>S16</td>

<td></td>

<td></td>

<td>indent from left margin (signed)</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>dxaLeft1</td>
<!-- convert="type" -->

<td>S16</td>

<td></td>

<td></td>

<td>first line indent; signed number relative to dxaLeft</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>lspd</td>

<td>LSPD</td>

<td></td>

<td></td>

<td>line spacing descriptor</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dyaBefore</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>vertical spacing before paragraph (unsigned)</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>dyaAfter</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>vertical spacing after paragraph (unsigned)</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>phe</td>

<td>PHE</td>

<td></td>

<td></td>

<td>height of current paragraph.</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>fAutoHyph</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, text in paragraph may be auto hyphenated</td>
</tr>

<tr>
<td>35</td>

<td>23</td>

<td>fWidowControl</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, Word will prevent widowed lines in this paragraph from being
placed at the beginning of a page</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>fInTable</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>when 1, paragraph is contained in a table row</td>
</tr>

<tr>
<td>37</td>

<td>25</td>

<td>fTtp</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>when 1, paragraph consists only of the row mark special character and
marks the end of a table row.&nbsp;</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>ptap</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>dxaAbs</td>
<!-- convert="type" -->

<td>S16</td>

<td></td>

<td></td>

<td>when positive, is the horizontal distance from the reference frame
specified by pap.pcHorz. 0 means paragraph is positioned at the left with
respect to the refence frame specified by pcHorz. Certain negative values
have special meaning:
<br>-4 paragraph centered horizontally within reference frame&nbsp;
<br>-8 paragraph adjusted right within reference frame
<br>-12 paragraph placed immediately inside of reference frame&nbsp;
<br>-16 paragraph placed immediately outside of reference frame</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>dyaAbs</td>
<!-- convert="type" -->

<td>S16</td>

<td></td>

<td></td>

<td>when positive, is the vertical distance from the reference frame specified
by pap.pcVert. 0 means paragraph's y-position is unconstrained. . Certain
negative values have special meaning:&nbsp;
<br>-4 paragraph is placed at top of reference frame&nbsp;
<br>-8 paragraph is centered vertically within reference frame
<br>-12 paragraph is placed at bottom of reference frame.</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>dxaWidth</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>when not == 0, paragraph is constrained to be dxaWidth wide, independent
of current margin or column setings.</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border above paragraph</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the left of paragraph</td>
</tr>

<tr>
<td>50</td>

<td>32</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border below paragraph</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the right of paragraph</td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>brcBetween</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of border to place between conforming paragraphs. Two
paragraphs conform when both have borders, their brcLeft and brcRight matches,
their widths are the same, theyboth belong to tables or both do not, and
have the same absolute positioning props.</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>brcBar</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of border to place on outside of text when facing pages
are to be displayed.</td>
</tr>

<tr>
<td>58</td>

<td>3A</td>

<td>dxaFromText</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>horizontal distance to be maintained between an absolutely positioned
paragraph and any non-absolute positioned text</td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>dyaFromText</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>vertical distance to be maintained between an absolutely positioned
paragraph and any non-absolute positioned text</td>
</tr>

<tr>
<td>62</td>

<td>3E</td>

<td>wr</td>

<td>U8</td>

<td></td>

<td></td>

<td>Wrap Code for absolute objects</td>
</tr>

<tr>
<td>63</td>

<td>3F</td>

<td>fLocked</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, paragraph may not be editted</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>dyaHeight</td>

<td>U16</td>

<td>:15</td>

<td>7FFF</td>

<td>height of abs obj; 0 == Auto</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMinHeight</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>0 = Exact, 1 = At Least</td>
</tr>

<tr>
<td>66</td>

<td>42</td>

<td>shd</td>

<td>SHD</td>

<td></td>

<td></td>

<td>shading</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>dcs</td>

<td>DCS</td>

<td></td>

<td></td>

<td>drop cap specifier (see DCS definition)</td>
</tr>

<tr>
<td>70</td>

<td>46</td>

<td>anld</td>

<td>ANLD</td>

<td></td>

<td></td>

<td>autonumber list descriptor (see ANLD definition)</td>
</tr>

<tr>
<td>122</td>

<td>7A</td>

<td>itbdMac</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>number of tabs stops defined for paragraph. Must be >= 0 and &lt;=
50.</td>
</tr>

<tr>
<td>124</td>

<td>7C</td>

<td>rgdxaTab</td>

<td>U16[itbdMac]</td>

<!-- compareSizeLHS="lhs.itbdMac" compareSizeRHS="rhs.itbdMac" -->

<td></td>

<td></td>

<td>array of positions of itbdMac tab stops. itbdMax == 50</td>
</tr>

<tr>
<td>224</td>

<td>E0</td>

<td>rgtbd</td>

<td>U8[itbdMac]</td>

<!-- compareSizeLHS="lhs.itbdMac" compareSizeRHS="rhs.itbdMac" -->

<td></td>

<td></td>

<td>array of itbdMac tab descriptors</td>
</tr>
</table>


<p class="cb">cbPAP (count of bytes of PAP) is 274 (decimal), 112(hex)
<p>The <b>PAPX</b> is stored within<b>FKPs</b> and withinthe <b>STSH</b>.&nbsp;<a NAME="PAPX"></a>
<h3>
Paragraph Property Exceptions (PAPX)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cw</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of words of following data in PAPX. The first byte of a PAPX
is a count of words when PAPX is stored in an FKP. Count of words is used
because PAPX in an FKP can contain paragraph and table sprms.</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of bytes of following data in PAPX. The first byte of a PAPX
is a count of bytes when a PAPX is stored in a STSH. Count of bytes is
used because only paragraph sprms are stored in a STSH PAPX.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>istd</td>

<td>U8</td>

<td></td>

<td></td>

<td>index to style descriiptor of the style from which the paragraph inherits
its paragraph and character properties</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>grpprl</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>a list of the sprms that encode the differences between PAP for a paragraph
and the PAP for the style used. When a paragraph bound is also the end
of a table row, the PAPX also contains a list of table sprms which express
the difference of table row's TAP from an empty TAP that has been cleared
to zeros. The table sprms are recorded in the list after all of the paragraph
sprms.See Sprms definitions for list of sprms that are used in PAPXs.</td>
</tr>
</table>

<p>papx.cw is equal to (3 + sizeof(grpprl) + 1) / 2. If the size of the
grpprl is odd, a byte of zero is stored immediately after the grpprl to
pad the PAPX so its length in bytes is papx.cw * 2.&nbsp;<a NAME="PAPXFKP"></a>
<h3>
Formatted Disk Page for PAPXs (PAPXFKP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>rgfc</td>

<td>FC[fkp.crun+1]</td>

<td></td>

<td></td>

<td>Each FC is the limit FC of a paragraph (ie. points to the next character
past an end of paragraph mark). There will be fkp.crun+1 recorded in the
FKP.</td>
</tr>

<tr>
<td>4*(fkp.crun+1)</td>

<td></td>

<td>rgbx</td>

<td>BX[fkp.crun]</td>

<td></td>

<td></td>

<td>an array of the BX data structure. The ith BX entry in the array describes
the paragraph beginning at fkp.rgfc[i]. The BX is a seven byte data structure.
The first byte of each BX is the word offset of thePAPX recorded for the
paragraph corresponding to this BX. ..If the byte stored is 0, this represents
a 1 line paragraph 15 pixels high with Normal style (stc == 0) whose column
width is 7980 dxas.&nbsp;
<p>The last six bytes of the BX is a PHE structure which stores the current
paragraph height for the paragraph corresponding to the BX. If a plcfphe
has an entry that maps to the FC for this paragraph, that entry?s PHE overides
the PHE stored in the FKP.</td>
</tr>

<tr>
<td>11*fkp.crun+4</td>

<td></td>

<td>unusedSpace</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>As new runs/paragraphs are recorded in the FKP,unused space is reduced
by 11 if CHPX/PAPX is already recorded and is reduced by11+sizeof(PAPX)
if property is not already recorded.</td>
</tr>

<tr>
<td>511-sizeof(grppapx)</td>

<td></td>

<td>grppapx</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>grppapx consists of all of the PAPXs stored in FKP concatenated end
to end. Each PAPX begins with a count of words which records its length
padded to a word boundary.</td>
</tr>

<tr>
<td>511</td>

<td></td>

<td>crun</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of paragraphs for PAPX FKP.</td>
</tr>
</table>

<p>The <b>PAP</b> is never stored in a Word file. It is derived by expanding
stored <b>PAPX</b>s.&nbsp;<a NAME="PCD"></a>
<h3>
Piece Descriptor (PCD)</h3>
<!-- sizeOf="8" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fNoParaLast</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>when 1, means that piece contains no end of paragraph marks.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPaphNil</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCopied</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_3</td>

<td>U16</td>

<td>:5</td>

<td></td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fn</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>used internally by Word</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fc</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of beginning of piece. The size of the ithpiece can be
determined by subtracting rgcp[i] of the containing plcfpcd from its rgcp[i+1].</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>prm</td>

<td>PRM</td>

<td></td>

<td></td>

<td>contains either a single sprm or else an index number of the grpprl
which contains the sprms that modify the properties of the piece.</td>
</tr>
</table>

<p>cbPCD is 8.&nbsp;<a NAME="PGD"></a>
<h3>
Page Descriptor (PGD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>unused0_0</td>

<td>U16</td>

<td>:5</td>

<td>001F</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fGhost</td>

<td>U16</td>

<td>:2</td>

<td>0060</td>

<td>redefine fEmptyPage and fAllFtn. true when blank page or footnote only
page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_7</td>

<td>U16</td>

<td>:9</td>

<td>FF10</td>

<td></td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fContinue</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 only when footnote is continued from previous page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>1 when page is dirty (ie. pagination cannot be trusted)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRight</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>1 when right hand side page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPgnRestart</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>1 when page number must be reset to 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEmptyPage</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>1 when section break forced page to be empty.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAllFtn</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>1 when page contains nothing but footnotes</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fColOnly</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTableBreaks</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMarked</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fColumnBreaks</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTableHeader</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNewPage</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>bkc</td>

<td>U16</td>

<td>:4</td>

<td>F000</td>

<td>section break code</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>lnn</td>

<td>U16</td>

<td></td>

<td></td>

<td>line number of first line, -1 if no line numbering</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>pgn</td>

<td>U16</td>

<td></td>

<td></td>

<td>page number as printed</td>
</tr>
</table>

<p>cbPGD (count of bytes of PGD) is 6(decimal),6(hex).
<p>The <b>PHE</b> is a substructure of the <b>PAP</b> and the<u> <b>PAPX</b></u><b>
FKP</b> and is also stored in the <b>PLCFPHE</b>.&nbsp;<a NAME="PHE"></a>
<h3>
Paragraph Height (PHE)</h3>
<!-- sizeOf="6" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fSpare</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>phe entry is invalid when == 1</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDiffLines</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>when 1, total height of paragraph is known but lines in paragraph have
different heights.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_3</td>

<td>U16</td>

<td>:5</td>

<td>00F8</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>clMac</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>when fDiffLines is 0 is number of lines in paragraph</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>dxaCol</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>width of lines in paragraph</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dylLine_dylHeight</td>
<!-- convert="(dym)" -->

<td>U16</td>

<td></td>

<td></td>

<td>When fDiffLines is 0, this is the height of every line in paragraph.in pixels (dylLine).
When fDiffLines is 1, this is the total height in pixels of the paragraph (dylHeight).
dylHeight and dylLine overlap (shaheed).</td>
</tr>
</table>

<p>cbPHE (the count of bytes in a PHE) is 6 (decimal), 6(hex).
<p>If there is no paragraph height information stored for a paragraph,
all of the fields in the <b>PHE</b> are set to 0. If a paragraph contains
more than 127 lines, the clMac, dylLine variant cannot be used, so fDiffLines
must be set to 1 and the total size of the paragraph stored in dylHeight.
If a paragraph height is greater than 32767 twips, the height cannot be
represented by a <b>PHE</b> so all fields of the <b>PHE </b>must be set
to 0.
<p>If a new Windows Word file is created, the <b>PHE</b> of every <b>papx
fkp</b> entrycreated to describe the paragraphs of the file should be set
to 0. If a Windows Word file is altered in place (a character of the file
changed to a new character or a property changed), the paragraph containing
the change must have its <b>papx.phe</b> field set to 0.&nbsp;<a NAME="PICF"></a>
<h3>
Picture Descriptor (PICF)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>lcb</td>

<td>U32</td>

<td></td>

<td></td>

<td>number of bytes in the PIC structure plus size of following picture
data which may be a Window's metafile, a bitmap, or the filename of a TIFF
file.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cbHeader</td>

<td>U16</td>

<td></td>

<td></td>

<td>number of bytes in the PIC (to allow for future expansion).</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>mfp</td>

<td>METAFILEPICT</td>

<td></td>

<td></td>

<td>If a Windows metafiles is stored immediatelly followingthe PIC structure,
the mfp is a Window's METAFILEPICT structure. When the data immediately
following the PIC is aTIFF filename, mfp.mm == 98. If a bitmap is stored
after the pic,mfp.mm == 99
<br>When the PIC describes a bitmap, mfp.xExt is the width of the bitmap
in pixels and mfp.yExt is the height of the bitmap in pixels..</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>bm_rcWinMF</td>

<td>U8[14]</td>

<td></td>

<td></td>

<td>Window's bitmap structure when PIC describes a BITMAP. rect for window
origin and extents whenmetafile is stored -- ignored if 0</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>dxaGoal</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>horizontalmeasurement in twips of therectangle the picture should be
imaged within.</td>
</tr>

<tr>
<td>30</td>

<td>1E</td>

<td>dyaGoal</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>verticalmeasurement in twips of therectangle the picture should be
imaged within. when scaling bitmaps, dxaGoal and dyaGoal may be ignored
if the operation would cause the bitmap to shrink or grow by anon -power-of-two
factor</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>mx</td>

<td>U16</td>

<td></td>

<td></td>

<td>horizontal scaling factor supplied by user expressedin .001% units.</td>
</tr>

<tr>
<td>34</td>

<td>22&nbsp;</td>

<td>my</td>

<td>U16</td>

<td></td>

<td></td>

<td>vertical scaling factor supplied by user expressed in .001% units.
for all of the Crop values, a positive measurement means the specified
border has been moved inward from its original setting and a negative measurement
means the borderhas been moved outward from its original setting.</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>dxaCropLeft</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the left in twips.&nbsp;</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>dyaCropTop</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the top in twips.&nbsp;</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>dxaCropRight</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the right in twips.&nbsp;</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>dyaCropBottom</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the bottom in twips.&nbsp;</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>brcl</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td>Obsolete, superseded by brcTop, etc.In WinWord 1.x, it was the type
of border to place around picture&nbsp;
<br>0 single&nbsp;
<br>1 thick
<br>2 double&nbsp;
<br>3 shadow</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFrameEmpty</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>picture consists of a single frame</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBitmap</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>==1, when picture is just a bitmap</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDrawHatch</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>==1, when picture is an active OLE object</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fError</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>==1, when picture is just an error message</td>
</tr>

<tr>
<td></td>

<td></td>

<td>bpp</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>bits per pixel
<br>0 unknown
<br>1 monochrome&nbsp;
<br>4</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border above picture</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the left of picture</td>
</tr>

<tr>
<td>50</td>

<td>32</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border below picture</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the right of picture</td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>dxaOrigin</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>horizontal offset of hand annotation origin</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>dyaOrigin</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>vertical offset of hand annotation origin</td>
</tr>
</table>

<p>The PICF is followed by rgb, a variable array of bytes containing Window's
metafile, bitmap or TIFF file filename&nbsp;<a NAME="PLCF"></a>
<h3>
Plex of CPs stored in File (PLCF)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td></td>

<td>rgfc</td>

<td>FC[]</td>

<td></td>

<td></td>

<td>given that the size of PLCF is cb and the size of the structure stored
in plc is cbStruct, then the number of structure instances stored in PLCF,
iMac is given by (cb -4)/(4 + cbStruct) The number of FCs stored in the
PLCF will be iMac + 1.</td>
</tr>

<tr>
<td>4*(iMac+1)</td>

<td></td>

<td>rgstruct</td>

<td>struct[] array of some arbitrary structure.</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>
cbPLC (count of bytes of a PLC) is iMac(4 + cbStruct) + 4.&nbsp;<a NAME="PRM"></a>
<h3>
Property Modifier(variant 1) (PRM)</h3>
<!-- sizeOf="2" -->
The <b>PRM</b> has two variants. In the first variant, the <b>PRM</b> records
a single one or two byte <b>sprm</b> whose opcode is less than 128.
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fComplex</td>
<!-- convert="type" -->

<td>U8</td>

<td>:1</td>

<td>01</td>

<td>set to 0 for variant 1</td>
</tr>

<tr>
<td></td>

<td></td>

<td>sprm</td>
<!-- convert="(isprm)" -->

<td>U8</td>

<td>:7</td>

<td>FE</td>

<td>sprm opcode</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>val</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>sprm's second byte if necessary</td>
</tr>
</table>

<p>In the second variant, prm.fComplex is 1, and the rest of the structure
records an index to a grpprl stored in the <b>CLX</b> (described in <b>Complex
File Format</b> topic).&nbsp;<a NAME="PRM2"></a>
<h3>
Property Modifier(variant 2) (PRM2)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fComplex</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>set to 1 for variant 2</td>
</tr>

<tr>
<td></td>

<td></td>

<td>igrpprl</td>

<td>U16</td>

<td>:15</td>

<td>FFFE</td>

<td>index to a grpprl stored in CLX portion of file.</td>
</tr>
</table>
<a NAME="SED"></a>
<h3>
Section Descriptor (SED)</h3>
<!-- sizeOf="12" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fSwap</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>runtime flag, indicates whether orientation should be changed before
printing. 0 indicates no change, 1 indicates orientation change.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>used internally by Windows Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fn</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>used internally by Windows Word</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fcSepx</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset to beginning of SEPX stored for section. If sed.fcSepx==
0xFFFFFFFF, the section properties for the section are equal to the standard
SEP (see SEP definition).</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fnMpr</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>used internally by Windows Word</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>fcMpr</td>

<td>U32</td>

<td></td>

<td></td>

<td>points to offset in FC space where the Macintosh Print Record for a
document created on a Mac will be stored</td>
</tr>
</table>


<p class="cb">cbSED is 12 (decimal)), C (hex).&nbsp;<a NAME="SEP"></a>
<h3>
Section Properties (SEP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>bkc</td>

<!-- initial="2" -->

<td>U8</td>

<td></td>

<td></td>

<td>break code:
<br>0 No break
<br>1 New column
<br>2 New page
<br>3 Even page
<br>4 Odd page</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>fTitlePage</td>

<td>U8</td>

<td></td>

<td></td>

<td>set to 1 when a title page is to be displayed</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>ccolM1</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>number of columns in section - 1.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dxaColumns</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>distance that will be maintained between columns</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fAutoPgn</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>only for Mac compatability, used only during open, when 1, sep.dxaPgn
and sep.dyaPgn are valid page number locations</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>nfcPgn</td>

<td>U8</td>

<td></td>

<td></td>

<td>page number format code:
<br>0Arabic numbering&nbsp;
<br>1 Upper case Roman&nbsp;
<br>2 Lower case Roman&nbsp;
<br>3 Upper case Letter&nbsp;
<br>4 Lower case letter&nbsp;
<br>5 Ordinal&nbsp;</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>pgnStart</td>

<td>U16</td>

<td></td>

<td></td>

<td>user specified starting page number.</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>fUnlocked</td>

<td>U8</td>

<td></td>

<td></td>

<td>set to 1, when a section in a locked document is unlocked</td>
</tr>

<tr>
<td>11</td>

<td>B</td>

<td>cnsPgn</td>

<td>U8</td>

<td></td>

<td></td>

<td>chapter number separator for page numbers</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>fPgnRestart</td>

<td>U8</td>

<td></td>

<td></td>

<td>set to 1 when page numbering should be restarted at the beginning of
this section</td>
</tr>

<tr>
<td>13</td>

<td>D</td>

<td>fEndNote</td>
<!-- initial="true" -->

<td>U8</td>

<td></td>

<td></td>

<td>when 1, footnotes placed at end of section. When 0, footnotes are placed
at bottom of page.</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>lnc</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>line numbering code:&nbsp;
<br>0 Per page&nbsp;
<br>1 Restart&nbsp;
<br>2 Continue</td>
</tr>

<tr>
<td>15</td>

<td>F</td>

<td>grpfIhdt</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>specification of which headers and footers are included in this section.
See explanation inHeaders and Footers topic.</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>nLnnMod</td>

<td>U16</td>

<td></td>

<td></td>

<td>if 0, no line numbering, otherwise this is the line number modulus
(e.g. if nLnnMod is 5, line numbers appear on line 5, 10, etc.)</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>dxaLnn</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>distance of&nbsp;</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dyaHdrTop</td>
<!-- convert="type" -->
<!-- initial="720" -->

<td>U16</td>

<td></td>

<td></td>

<td>y position of top header measured from top edge of page.</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>dyaHdrBottom</td>
<!-- convert="type" -->
<!-- initial="720" -->

<td>U16</td>

<td></td>

<td></td>

<td>y position of top header measured from top edge of page.</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dxaPgn</td>
<!-- convert="type" -->
<!-- initial="720" -->

<td>U16</td>

<td></td>

<td></td>

<td>when fAutoPgn ==1, gives the x position of auto page number on page
in twips (for Mac compatabilty only)</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>dyaPgn</td>
<!-- convert="type" -->
<!-- initial="720" -->

<td>U16</td>

<td></td>

<td></td>

<td>when fAutoPgn ==1, gives the y position of auto page number on page
in twips (for Mac compatabilty only)</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>fLBetween</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>when ==1, draw vertical lines between columns</td>
</tr>

<tr>
<td>29</td>

<td>1D</td>

<td>vjc</td>
<!-- convert="type" -->

<td>U8</td>

<td></td>

<td></td>

<td>vertical justification code&nbsp;
<br>0 top justified&nbsp;
<br>1 centered&nbsp;
<br>2 fully justified vertically&nbsp;
<br>3 bottom justified</td>
</tr>

<tr>
<td>30</td>

<td>1E</td>

<td>lnnMin</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>beginning line number for section</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>dmOrientPage</td>

<!-- initial="1" -->

<td>U8</td>

<td></td>

<td></td>

<td>orientation of pages in that section.set to 0 when portrait, 1 when
landscape</td>
</tr>

<tr>
<td>33</td>

<td>21</td>

<td>iHeadingPgn</td>

<td>U8</td>

<td></td>

<td></td>

<td>heading number level for page number</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>xaPage</td>
<!-- convert="type" -->
<!-- initial="12240" -->

<td>U16</td>

<td></td>

<td></td>

<td>width of page default value is 12240 twips</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>yaPage</td>
<!-- convert="type" -->
<!-- initial="15840" -->

<td>U16</td>

<td></td>

<td></td>

<td>height of page default value is 15840 twips</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>dxaLeft</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>left margin default value is 1800 twips</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>dxaRight</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>right margin default value is 1800 twips</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>dyaTop</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>top margin default value is 1440 twips</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>dyaBottom</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>bottom margin default value is 1440 twips</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>dzaGutter</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>gutter width default value is 0 twips&nbsp;</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>dmBinFirst</td>

<td>U16</td>

<td></td>

<td></td>

<td>bin number supplied from windows printer driver indicating which bin
the first page of section will be printed.</td>
</tr>

<tr>
<td>50</td>

<td>32</td>

<td>dmBinOther</td>

<td>U16</td>

<td></td>

<td></td>

<td>bin number supplied from windows printer driver indicating which bin
the pages other than the first page of section will be printed.</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>dmPaperReq</td>

<td>U16</td>

<td></td>

<td></td>

<td>dmPaper code for form selected by user</td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>fEvenlySpaced</td>
<!-- convert="type" -->
<!-- initial="true" -->

<td>U8</td>

<td></td>

<td></td>

<td>when == 1, columns are evenly spaced. Default value is 1.</td>
</tr>

<tr>
<td>55</td>

<td>37</td>

<td>unused55</td>
<!-- convert="unused" -->

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>dxaColumnWidth</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>58</td>

<td>3A</td>

<td>rgdxaColumnWidthSpacing</td>
<!-- convert="type" -->

<td>U16[89]</td>

<td></td>

<td></td>

<td>array of 89 Xas that determine bounds of irregular width columns</td>
</tr>

<tr>
<td>236</td>

<td>EC</td>

<td>olstAnm</td>

<td>OLST</td>

<td></td>

<td></td>

<td>multilevel autonumbering list data (see OLST definition)</td>
</tr>
</table>


<p class="cb">cbSEP (count of bytes of SEP) is 448(decimal), 1C0(hex).
<p>The standard SEP is all zeros except as follows:
<p>bkc 2
<br>dyaPgn 720 twips (equivalent to .5 in)
<br>dxaPgn 720 twips
<br>fEndnote1 (True)
<br>fEvenlySpaced 1 (True)
<br>xaPage1 2240 twips
<br>yaPage1 5840 twips
<br>dyaHdrTop 720 twips
<br>dyaHdrBottom 720twips
<br>dmOrientPage 1 (portrait orientation)&nbsp;<a NAME="SEPX"></a>
<h3>
Section Property Exceptions (SEPX)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of bytes in remainder of SEPX.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>grpprl</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>list of sprms that encodes the differences between the properties of
a section and Word's default section properties.</td>
</tr>
</table>
<a NAME="SHD"></a>
<h3>
Shading Descriptor (SHD)</h3>
The SHD is a substructure of the <b>CHP</b> and <b>PAP</b>.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>icoFore</td>

<td>U16</td>

<td>:5</td>

<td>001F</td>

<td>foreground color (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>icoBack</td>

<td>U16</td>

<td>:5</td>

<td>03E0</td>

<td>background color (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ipat</td>

<td>U16</td>

<td>:6</td>

<td>FC00</td>

<td>shading pattern (see ipat table below)
<br>0 Automatic
<br>1 Solid
<br>2 5 Percent
<br>3 10 Percent
<br>4 20 Percent
<br>5 25 Percent
<br>6 30 Percent
<br>7 40 Percent
<br>8 50 Percent
<br>9 60 Percent
<br>10 70 Percent
<br>11 75 Percent
<br>12 80 Percent
<br>13 90 Percent
<br>14 Dark Horizontal
<br>15 Dark Vertical
<br>16 Dark Forward Diagonal
<br>17 Dark Backward Diagonal
<br>18 Dark Cross
<br>19 Dark Diagonal Cross
<br>20 Horizontal
<br>21 Vertical
<br>22 Forward Diagonal
<br>23 Backward Diagonal
<br>24 Cross
<br>25 Diagonal Cross
<br>35 2.5 Percent
<br>36 7.5 Percent
<br>37 12.5 Percent
<br>38 15 Percent
<br>39 17.5 Percent
<br>40 22.5 Percent
<br>41 27.5 Percent
<br>42 32.5 Percent
<br>43 35 Percent
<br>44 37.5 Percent
<br>45 42.5 Percent
<br>46 45 Percent
<br>47 47.5 Percent
<br>48 52.5 Percent
<br>49 55 Percent
<br>50 57.5 Percent
<br>51 62.5 Percent
<br>52 65 Percent
<br>53 67.5 Percent
<br>54 72.5 Percent
<br>55 77.5 Percent
<br>56 82.5 Percent
<br>57 85 Percent
<br>58 87.5 Percent
<br>59 92.5 Percent
<br>60 95 Percent
<br>61 97.5 Percent
<br>62 97 Percent</td>
</tr>
</table>

<p>cbSHD (count of bytes of SHD) is 2.&nbsp;<a NAME="TAP"></a>

<h3>
STyleSHeet Information (STSHI)</h3>
<!-- sizeOf="14" -->
The STSHI structure has the following format:

<pre>// STSHI: STyleSHeet Information, as stored in a file
//&nbsp; Note that new fields can be added to the STSHI without invalidating
//&nbsp; the file format, because it is stored preceded by it's length.
//&nbsp; When reading a STSHI from an older version, new fields will be zero.</pre>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cstd</td>

<td>U16</td>

<td></td>

<td></td>

<td>Count of styles in stylesheet</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cbSTDBaseInFile</td>

<td>U16</td>

<td></td>

<td></td>

<td>Length of STD Base as stored in a file</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fStdStylenamesWritten</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>Are built-in stylenames stored?</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused4_2</td>

<td>U16</td>

<td>:15</td>

<td>FFFE</td>

<td>Spare flags</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>stiMaxWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>Max sti known when this file was written</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>istdMaxFixedWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>How many fixed-index istds are there?</td>
</tr>

<tr>
<td>10</td>

<td>0xA</td>

<td>nVerBuiltInNamesWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>Current version of built-in stylenames</td>
</tr>

<tr>
<td>12</td>

<td>0xC</td>

<td>ftcStandardChpStsh</td>

<td>U16</td>

<td></td>

<td></td>

<td>ftc used by StandardChpStsh for this document</td>
</tr>
</table>

<h3>
Table Properties (TAP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>jc</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>justification code. specifies how table row should be justified within&nbsp;
its column.&nbsp;
<br>0 left justify&nbsp;
<br>1center&nbsp;
<br>2right justify&nbsp;
<br>3left and right justify</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>dxaGapHalf</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>measures half of the white space that will be maintained between textin
adjacent columns of a table row. A dxaGapHalf width of white space will
be maintained on both sides of a column boundary.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dyaRowHeight</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>when greater than 0. guarantees that the height of the table will be
at least dyaRowHeight high. When less than 0, guarantees that the height
of the table will be exactly absolute value of dyaRowHeight high.When 0,table
will be given a height large enough to representall of the text in all
of the cells of the table.&nbsp;</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fCantSplit</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, table row may not be split across page bounds</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>fTableHeader</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, table row is to be used as the header of the table</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>tlp</td>

<td>TLP</td>

<td></td>

<td></td>

<td>table look specifier (see TLP definition)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>fCaFull</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFirstRow</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLastRow</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOutline</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused12_4</td>
<!-- convert="unused" -->

<td>U16</td>

<td>:12</td>

<td>FFE0</td>

<td>reserved</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>itcMac</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>count of cells defined for this row. ItcMac must be >= 0 and less than
or equal to 32.&nbsp;</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>dxaAdjust</td>
<!-- convert="type" -->

<td>U16</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>rgdxaCenter</td>

<td>U16[itcMac + 1]</td>
<!-- compareSizeLHS="lhs.itcMac" compareSizeRHS="rhs.itcMac" -->

<td></td>

<td></td>

<td>rgdxaCenter[0] is the left boundary of cell 0 measured relative to
margin.. rgdxaCenter[tap.itcMac - 1] is left boundary of last cell. rgdxaCenter[tap.itcMac]
is right boundary of last cell.</td>
</tr>

<tr>
<td>84</td>

<td>54</td>

<td>rgtc</td>

<td>TC[itcMac]</td>
<!-- compareSizeLHS="lhs.itcMac" compareSizeRHS="rhs.itcMac" -->

<td></td>

<td></td>

<td>array of table cell descriptors</td>
</tr>

<tr>
<td>404</td>

<td>194</td>

<td>rgshd</td>

<td>SHD[itcMac]</td>
<!-- compareSizeLHS="lhs.itcMac" compareSizeRHS="rhs.itcMac" -->

<td></td>

<td></td>

<td>array of cell shades</td>
</tr>

<tr>
<td>468</td>

<td>1D4</td>

<td>rgbrcTable</td>

<td>BRC[6]</td>

<td></td>

<td></td>

<td>array of border defaults for cells</td>
</tr>
</table>


<p class="cb">cbTAP (count of bytes of a TAP) is 480 (decimal),1E0(hex).&nbsp;<a NAME="TBD"></a>
<h3>
Tab Descriptor (TBD)</h3>
The <b>TBD</b> is a substructure of the <b>PAP</b>.
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>jc</td>

<td>U8</td>

<td>:3</td>

<td>07</td>

<td>justification code
<br>0 left tab&nbsp;
<br>1 centered tab&nbsp;
<br>2 right tab&nbsp;
<br>3 decimal tab&nbsp;
<br>4 bar</td>
</tr>

<tr>
<td></td>

<td></td>

<td>tlc</td>

<td>U8</td>

<td>:3</td>

<td>38</td>

<td>tab leader code&nbsp;
<br>0 no leader&nbsp;
<br>1 dotted leader&nbsp;
<br>2 hyphenated leader&nbsp;
<br>3 single line leader
<br>4 heavy line leader</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_6</td>

<td>U8</td>

<td>:2</td>

<td>C0</td>

<td>reserved</td>
</tr>
</table>


<p class="cb">cbTBD (count of bytes of a tab descriptor) is 1.
<p>The <b>TC</b> is a substructure of the <b>TAP.</b><a NAME="TC"></a>
<h3>
Table Cell Descriptors (TC)</h3>
<!-- sizeOf="10" -->

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fFirstMerged</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>set to 1 when cell is first cell of a range of cells that have been
merged. When a cell is merged, the display areas of the merged cells are
consolidated and the text within the cells is interpreted as belonging
to one text stream for purposes of calculating line breaks.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMerged</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>set to 1 when cell has been merged with preceding cell.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnused</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>reserved</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of the top border of a table cell</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of left border of table row</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of bottom border of table row</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification f right border of table row.</td>
</tr>
</table>

<p>cbTC (count of bytes of a TC) is 10(decimal), A(hex).&nbsp;<a NAME="TLP"></a>
<h3>
Table Autoformat Look sPecifier (TLP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>itl</td>

<td>U16</td>
<!-- convert="type" -->

<td></td>

<td></td>

<td>index to Word's table of table looks</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fBorders</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>when ==1, use the border properties from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShading</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>when ==1, use the shading properties from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFont</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>when ==1, use the font from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fColor</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>when ==1, use the color from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBestFit</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>when ==1, do best fit from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHdrRows</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>when ==1, apply properties from the selected table look to the header
rows in the table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLastRow</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>when ==1, apply properties from the selected table look to the last
row in the table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHdrCols</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>when ==1, apply properties from the selected table look to the header
columns ofthe table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLastCol</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>when ==1, apply properties from the selected table look to the last
column ofthe table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused2_9</td>

<td>U16</td>

<td>:7</td>

<td>FE00</td>

<td>unused</td>
</tr>
</table>

<h1>
Appendix A - Changes from version 1.x to 2.0</h1>

<h2>
Changes to Structures</h2>

<h3>
BRC</h3>
The previously defined BRC was renamed BRC10, and a new BRC was defined
with new fields and field names.
<h3>
CHP</h3>
The size of the CHP changed from 16 to 32 bits, with some spare bits added.
<p>The fStrike, hpsPos, &amp; fSysVanish fields were moved within the CHP.A
new field, fRMarkDel, is located where fStrike used to be.
<p>The fsLid and lid fields were added for the language identification
code.
<p>The types of several fields were changed.The ftc field was changed from
an unsigned integer to a WORD.The hps field was changed from an U8 to a
WORD.The fnPic field was changed from an unsigned integer to a BYTE.
<p>The fObj and fcObj fields were added for managing embedded objects.
<h3>
DOP</h3>
fWide removed
<p>irmBar is a BYTE rather than an int
<p>rgwSpare uns[2] became wSpare2 uns and wSpare3 uns
<p>fPMHMainDoc, grfSuppression,fKeepFileFormat, fDfltTrueType, and fPagSuppressTopSpacing
added
<h3>
DTTM</h3>

<h3>
FIB</h3>
Password Protection added
<p>fEncrypted and lKey added for file encryption
<p>Print Environment &amp; orientation changes
<p>fcPrEnv &amp; cbPrEnv were removed.
<p>fcPrDrv &amp; cbPrDrv------------------\
<p>fcPrEnvPort &amp; cbPrEnvPort------- were added to FIB
<p>fcPrEnvLand &amp; cbPrEnvLand----/
<p>Autosave added
<p>fcAutosaveSource
<p>cbAutosaveSource
<p>nLocale changed to lid
<h3>
_OBJHEADER</h3>

<h3>
PAP</h3>
Frames
<p>added dyaFromText, wr, dyaHeight, fMinHeight
<p>When converting 1.x documents with Absolutely Positioned Objects set
the old dxaFromText (Distance from text) to both dxaFromText and dyaFromText.
<p>Shading
<p>added shd
<p>Auto numbering
<p>added nfcSeqNumb and nnSeqNumb
<h3>
PIC</h3>
(at the end of the structure before the variable length array )
<p>brcTop
<br>BRC
<p>brcLeftBRC
<p>brcBottomBRC
<p>brcRightBRC
<p>dxaOrigin, dyaOrigin
<h3>
SEP</h3>
removed fAutoPgn changed to bUnused1
<p>Added Page Orientation stuff
<p>morPage
<p>bUnused2
<p>Added Printer Environment
<p>dmBinFirst
<p>dmBinOther
<h3>
DOP to SEP</h3>
Page Dimensions &amp; Margin stuff
<p>xaPage
<p>yaPage
<p>dxaLeft
<p>dxaRight
<p>dyaTop
<p>dyaBottom
<p>dxaGutter in DOP renamed dzaGutter in SEP
<h3>
SED</h3>
fSpare (reserved) changed to fSwap (runtime flag for landscape/portrait
orientation)
<h3>
TAP</h3>
wSpare1
<p>wSpare2
<p>wSpare3
<p>wSpare4
<p>wSpare5
<h3>
TAP</h3>
Shading
<p>rgshd[itchMax] SHD
<h3>
TC</h3>
Border
<p>rgbrc, brcTop, brcLeft, brcBottom, brcRight were int, now they are BRC.
<h2>
Other changes</h2>

<h3>
sttbfAssoc</h3>
Indices to the associated string table and descriptions of strings were
added.
<h3>
sttbfFn</h3>
The fonts written in the font string table and the indexing were changed.
<h2>
REVIEW DavidLu</h2>
<a NAME="FTCL"></a>
<h3>
FonT Code Link field (FTCL)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>12</td>

<td>b</td>

<td>fEmbedLoad</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 if embedded fonts were stored in the file.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wLicense</td>

<td>U16</td>

<td>:3</td>

<td>000e</td>

<td>Licensing permissions&nbsp;
<br>0 font is installable&nbsp;
<br>4 font is print preview&nbsp;
<br>8 font is editable</td>
</tr>
</table>

<h2>
Index of Changes from version 1.x to 2.0</h2>
_OBJHEADER, 44Autosave source, 11, 13
<p>BRC, 36
<p>CHP/CHPX, 37
<p>DOP, 42
<p>DTTM, 42
<p>Embedded Object, 8, 10, 12, 44
<p>FIB, 46
<p>FLD, 44
<p>Hand Annotation, 14, 42
<p>PAP, 55
<p>PIC, 58
<p>SED, 61
<p>SEP, 61
<p>sprmCFFldVanish, 22
<p>sprmCFRMark, 22
<p>sprmCFStrikeRM, 22
<p>sprmCLid, 22
<p>sprmMax, 24
<p>sprmPBrc, 22
<p>sprmPDxaFromText, 22
<p>sprmPDyaFromText, 22
<p>sprmPicBrc, 23
<p>sprmPNfcSeqNumb, 21
<p>sprmPNoSeqNumb, 21
<p>sprmPRuler, 22
<p>sprmPShd, 22
<p>sprmPWHeightAbs, 22
<p>sprmSBCustomize, 23
<p>sprmSBOrientation, 23
<p>sprmSDmBinFirst, 23
<p>sprmSDmBinOther, 23
<p>sprmSDxaLeft, 23
<p>sprmSDxaPgn, 23
<p>sprmSDxaRight, 23
<p>sprmSDyaBottom, 23
<p>sprmSDyaPgn, 23
<p>sprmSDyaTop, 23
<p>sprmSDzaGutter, 23
<p>sprmSFAutoPgn, 23
<p>sprmSXaPage, 23
<p>sprmSYaPage, 23
<p>sprmTDefTable, 24, 28
<p>sprmTDefTableShd, 24, 28
<p>sprmTSetBrc, 24, 30
<p>sprmTSetShd, 24, 30
<p>sttbfAssoc, 11, 13, 35
<p>sttbfFn, 11, 13
<p>TAP, 63
<p>TC, 63</div>

<p><br>
<hr align="Left" size="1" width="31%">
<div id="ftn1"><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a NAME="_ftn1" href="#_ftnref1" title=""></a><a href="#_ftnref1" name="_ftn1" title="">[1]</a>In
the Winword 1.x format, the names of the first three fonts were omitted
from the table and assumed to be "Tms Rmn" (for ftc = 0), "Symbol", and
"Helv".In WinWord 2.0, the names for all fonts are included explitly in
the table.It is still true that ftc = 0 represents the "best" Roman PS
font on the system, ftc = 1 represents the Symbol font, and ftc = 2 represents
the "best" Swiss (Sans Serif) PS font available.</div>

<div id="ftn2"><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a NAME="_ftn2" href="#_ftnref2" title=""></a><a href="#_ftnref2" name="_ftn2" title="">1</a>
In the Winword 1.x format, the names of the first three fonts were omitted
from the table and assumed to be "Tms Rmn" (for ftc = 0), "Symbol", and
"Helv".In WinWord 2.0, the names for all fonts are included explitly in
the table.It is still true that ftc = 0 represents the "best" Roman PS
font on the system, ftc = 1 represents the Symbol font, and ftc = 2 represents
the "best" Swiss (Sans Serif) PS font available.</div>

<div id="ftn3"><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a NAME="_ftn3" href="#_ftnref3" title=""></a><a href="#_ftnref3" name="_ftn3" title="">[2]</a>
The DOD.hplhqstd is a handle to a plex (array) of hq's (handles) to std's
(style descriptions).</div>

<div id="ftn4"><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a NAME="_ftn4" href="#_ftnref4" title=""></a><a href="#_ftnref4" name="_ftn4" title="">[3]</a>
Istd (slot) 0 is Normal.Istd 1-9 are Heading 1-9.Istd 10 is Default Paragraph
Font.Istd 11-14 are reserved.So the first non-fixed index is 15 (see stshi.istdMaxFixedWhenSaved.)</div>

<div id="ftn5"><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a NAME="_ftn5" href="#_ftnref5" title=""></a><a href="#_ftnref5" name="_ftn5" title="">[4]</a>
Those styles in fixed locations in the stylesheet will have the same istd's
in all documents.</div>

<div id="ftn6"><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a NAME="_ftn6" href="#_ftnref6" title=""></a><a href="#_ftnref6" name="_ftn6" title="">[5]</a>
For early versions of Word 6 files (versions prior to nFib 67), this field
was not written.The cbStshi to use for those file versions is 4 bytes.</div>

<div id="ftn7"><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a NAME="_ftn7" href="#_ftnref7" title=""></a><a href="#_ftnref7" name="_ftn7" title="">[6]</a>
More accurately a ?group?, because each of the elements (UPXs) in the array
is variable-length.</div>

<div id="ftn8"><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a NAME="_ftn8" href="#_ftnref8" title=""></a><a href="#_ftnref8" name="_ftn8" title="">[7]</a>
Note that the UPX.papx contains both a grpprl and an istd.Even if the grpprl
is empty, the istd is still needed.</div>

</body>
</html>
