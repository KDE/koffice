/* Swinder - Portable library for spreadsheet
   Copyright (C) 2009-2010 Sebastian Sauer <sebsauer@kdab.com>

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public License
   along with this library; see the file COPYING.LIB.  If not, write to
   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA
 */

#ifndef SWINDER_CHARTSUBSTREAMHANDLER_H
#define SWINDER_CHARTSUBSTREAMHANDLER_H

#include "substreamhandler.h"
#include "globalssubstreamhandler.h"
#include "excel.h"
//#include "ustring.h"
//#include <vector>
//#include "cell.h"
//#include "sheet.h"
//#include <map>

namespace Swinder
{

// class FormulaToken;
// typedef std::vector<FormulaToken> FormulaTokens;

class GlobalsSubStreamHandler;

struct DataPoint
{
    DataPoint() {}
    virtual ~DataPoint() {}
};

struct PieFormat : public DataPoint
{
    int pcExplode; // from PieFormat
    PieFormat(int pcExplode) : DataPoint(), pcExplode(pcExplode) {}
};

struct ChartImpl
{
    ChartImpl() {}
    virtual ~ChartImpl() {}
};

struct PieImpl : public ChartImpl
{
    int anStart, pcDonut;
    PieImpl(int anStart, int pcDonut) : ChartImpl(), anStart(anStart), pcDonut(pcDonut) {}
};

struct Chart
{
    int x, y, width, height;
    //int marginLeft, marginTop, marginRight, MarginBottom;
    uint dataTypeX, dataTypeY, countXValues, countYValues, bubbleSizeDataType, countBubbleSizeValues;
    QList<DataPoint*> datasetFormat;
    ChartImpl *impl;
    explicit Chart() : x(-1), y(-1), width(-1), height(-1), impl(0) {}
};

class BRAIRecord : public Record
{
public:
    enum DataId {
        SeriesLegendOrTrendlineName = 0x00, // Referenced data specifies the series, legend entry, or trendline name. Error bars name MUST be empty.
        HorizontalValues = 0x01, // Referenced data specifies the values or horizontal values on bubble and scatter chart groups of the series and error bars.
        VerticalValues = 0x02, // Referenced data specifies the categories or vertical values on bubble and scatter chart groups of the series and error bars.
        BubbleSizeValues = 0x03 // Referenced data specifies the bubble size values of the series.
    };
    DataId m_dataId;
    enum DataType {
        AutoGeneratedName = 0x00, // The data source is a category (3) name, series name or bubble size that was automatically generated.
        TextOrValue = 0x01, // The data source is the text or value as specified by the formula field.
        CellRange = 0x02 // The data source is the value from a range of cells in a sheet specified by the formula field.
    };
    DataType m_type;
    bool m_isUnlinkedFormat; // false=data uses the number formatting of the referenced data, true=data uses the custom formatting specified via m_numberFormat.
    unsigned m_numberFormat; // specifies the numnber format to use for the data.
    UString m_formula;
    static const unsigned int id;
    unsigned int rtti() const { return this->id; }
    virtual const char* name() const { return "BRAI"; }
    static Record *createRecord(Workbook *book) { return new BRAIRecord(book); }
    BRAIRecord(Swinder::Workbook *book) : Record(book) {}
    virtual ~BRAIRecord() {}
    virtual void dump(std::ostream&) const { /*TODO*/ }
    virtual void setData(unsigned size, const unsigned char* data, const unsigned int* continuePositions) {
        if (size < 8) {
            setIsValid(false);
            return;
        }
        m_dataId = (DataId) readU8(data);
        m_type = (DataType) readU8(data + 1);
        m_isUnlinkedFormat = readU16(data + 2) & 0x01;
        m_numberFormat = readU16(data + 4);

        FormulaDecoder decoder;
        FormulaTokens tokens = decoder.decodeFormula(size, 6, data, version());
        m_formula = decoder.decodeFormula(0, 0, true, tokens);
    }
};

const unsigned BRAIRecord::id = 0x1051;

// The chart substream can be either embedded into a worksheet or define an own sheet.
class ChartSubStreamHandler : public SubStreamHandler
{
public:
    ChartSubStreamHandler(const GlobalsSubStreamHandler* globals, SubStreamHandler* parentHandler) : SubStreamHandler(), m_globals(globals), m_parentHandler(parentHandler), m_chart(new Chart()), m_sheet(0) {
        RecordRegistry::registerRecordClass(BRAIRecord::id, BRAIRecord::createRecord);

        if(WorksheetSubStreamHandler* worksheetHandler = dynamic_cast<WorksheetSubStreamHandler*>(parentHandler)) {
            m_sheet = worksheetHandler->sheet();
        } else {
            std::cerr << "ChartSubStreamHandler: Chart is not embedded into a worksheet. This is not handled yet." << std::endl;
            //TODO
        }
    }
    virtual ~ChartSubStreamHandler() {
        if(m_sheet) {
            //m_sheet->cell
            //m_sheet->addChart(m_chart);
        }
    }
    //Chart *chart() const { return m_chart; }

    virtual void handleRecord(Record* record) {
        if (!record) return;
        const unsigned type = record->rtti();

        if (type == BOFRecord::id)
            handleBOF(static_cast<BOFRecord*>(record));
        else if (type == EOFRecord::id)
            handleEOF(static_cast<EOFRecord*>(record));
        else if (type == FooterRecord::id)
            handleFooter(static_cast<FooterRecord*>(record));
        else if (type == HeaderRecord::id)
            handleHeader(static_cast<HeaderRecord*>(record));
        else if (type == SetupRecord::id)
            handleSetup(static_cast<SetupRecord*>(record));
        else if (type == HCenterRecord::id)
            handleHCenter(static_cast<HCenterRecord*>(record));
        else if (type == VCenterRecord::id)
            handleVCenter(static_cast<VCenterRecord*>(record));
        else if (type == ZoomLevelRecord::id)
            handleZoomLevel(static_cast<ZoomLevelRecord*>(record));
        else if (type == DimensionRecord::id)
            handleDimension(static_cast<DimensionRecord*>(record));
        else if (type == ChartRecord::id)
            handleChart(static_cast<ChartRecord*>(record));
        else if (type == BeginRecord::id)
            handleBegin(static_cast<BeginRecord*>(record));
        else if (type == EndRecord::id)
            handleEnd(static_cast<EndRecord*>(record));
        else if (type == FrameRecord::id)
            handleFrame(static_cast<FrameRecord*>(record));
        else if (type == SeriesRecord::id)
            handleSeries(static_cast<SeriesRecord*>(record));
        else if (type == DataFormatRecord::id)
            handleDataFormat(static_cast<DataFormatRecord*>(record));
        else if (type == Chart3DBarShapeRecord::id)
            handleChart3DBarShape(static_cast<Chart3DBarShapeRecord*>(record));
        else if (type == Chart3dRecord::id)
            handleChart3d(static_cast<Chart3dRecord*>(record));
        else if (type == LineFormatRecord::id)
            handleLineFormat(static_cast<LineFormatRecord*>(record));
        else if (type == AreaFormatRecord::id)
            handleAreaFormat(static_cast<AreaFormatRecord*>(record));
        else if (type == PieFormatRecord::id)
            handlePieFormat(static_cast<PieFormatRecord*>(record));
        else if (type == MarkerFormatRecord::id)
            handleMarkerFormat(static_cast<MarkerFormatRecord*>(record));
        else if (type == ChartFormatRecord::id)
            handleChartFormat(static_cast<ChartFormatRecord*>(record));
        else if (type == GelFrameRecord::id)
            handleGelFrame(static_cast<GelFrameRecord*>(record));
        else if (type == SerToCrtRecord::id)
            handleSerToCrt(static_cast<SerToCrtRecord*>(record));
        else if (type == ShtPropsRecord::id)
            handleShtProps(static_cast<ShtPropsRecord*>(record));
        else if (type == DefaultTextRecord::id)
            handleDefaultText(static_cast<DefaultTextRecord*>(record));
        else if (type == TextRecord::id)
            handleText(static_cast<TextRecord*>(record));
        else if (type == PosRecord::id)
            handlePos(static_cast<PosRecord*>(record));
        else if (type == FontXRecord::id)
            handleFontX(static_cast<FontXRecord*>(record));
        else if (type == PlotGrowthRecord::id)
            handlePlotGrowth(static_cast<PlotGrowthRecord*>(record));
        else if (type == LegendRecord::id)
            handleLegend(static_cast<LegendRecord*>(record));
        else if (type == AxesUsedRecord::id)
            handleAxesUsed(static_cast<AxesUsedRecord*>(record));
        else if (type == AxisParentRecord::id)
            handleAxisParent(static_cast<AxisParentRecord*>(record));
        else if (type == BRAIRecord::id)
            handleBRAI(static_cast<BRAIRecord*>(record));
        else if (type == PieRecord::id)
            handlePie(static_cast<PieRecord*>(record));
        else if (type == SIIndexRecord::id)
            handleSIIndex(static_cast<SIIndexRecord*>(record));
        else if (type == MsoDrawingRecord::id)
            handleMsoDrawing(static_cast<MsoDrawingRecord*>(record));
        else if (type == ShapePropsStreamRecord::id)
            handleShapePropsStream(static_cast<ShapePropsStreamRecord*>(record));
        else if (type == TextPropsStreamRecord::id)
            handleTextPropsStream(static_cast<TextPropsStreamRecord*>(record));
        else if (type == CrtLinkRecord::id)
            {} // written but unused record
        else if (type == UnitsRecord::id)
            {} // written but must be ignored
        else {
            std::cout << "Unhandled chart record with type=" << type << " name=" << record->name() << std::endl;
            //record->dump(std::cout);
        }
    }

private:
    const GlobalsSubStreamHandler* m_globals;
    SubStreamHandler* m_parentHandler;
    Chart* m_chart;
    Sheet* m_sheet;
    
    void handleBOF(BOFRecord*) {
        //std::cout << "ChartSubStreamHandler BOFRecord" << std::endl;
    }
    void handleEOF(EOFRecord *) {
        //std::cout << "ChartSubStreamHandler EOFRecord" << std::endl;
    }
    void handleFooter(FooterRecord *) {
    }
    void handleHeader(HeaderRecord *) {
    }
    void handleSetup(SetupRecord *) {
    }
    void handleHCenter(HCenterRecord *) {
    }
    void handleVCenter(VCenterRecord *) {
    }
    void handleZoomLevel(ZoomLevelRecord *) {
    }
    void handleDimension(DimensionRecord *record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleDimension firstRow=" << record->firstRow() << " lastRowPlus1=" << record->lastRowPlus1() << " firstColumn=" << record->firstColumn() << " lastColumnPlus1=" << record->lastColumnPlus1() << " lastRow=" << record->lastRow() << " lastColumn=" << record->lastColumn() << std::endl;
    }
    void handleChart(ChartRecord *record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleChart x=" << record->x() << " y=" << record->y() << " width=" << record->width() << " height=" << record->height() <<  std::endl;
        m_chart->x = record->x();
        m_chart->y = record->y();
        m_chart->width = record->width();
        m_chart->height = record->height();
    }
    void handleBegin(BeginRecord *) { // secifies the begin of a collection of records
        //std::cout << "ChartSubStreamHandler::handleBegin" << std::endl;
    }
    void handleEnd(EndRecord *) { // sepcified the end of a collection of records
        //std::cout << "ChartSubStreamHandler::handleEnd" << std::endl;
    }
    void handleFrame(FrameRecord *record) {
        if(!record) return;
        if(record->isAutoPosition()) {
            m_chart->x = -1;
            m_chart->y = -1;
        }
        if(record->isAutoSize()) {
            m_chart->width = -1;
            m_chart->height = -1;
        }
    }
    void handleSeries(SeriesRecord *record) { // series, trendline or errorchars
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleSeries dataTypeX=" << record->dataTypeX() << " dataTypeY=" << record->dataTypeY() << " countXValues=" << record->countXValues() << " countYValues=" << record->countYValues() << " bubbleSizeDataType=" << record->bubbleSizeDataType() << " countBubbleSizeValues=" << record->countBubbleSizeValues() << std::endl;
        m_chart->dataTypeX = record->dataTypeX();
        m_chart->dataTypeY = record->dataTypeY();
        m_chart->countXValues = record->countXValues();
        m_chart->countYValues = record->countYValues();
        m_chart->bubbleSizeDataType = record->bubbleSizeDataType();
        m_chart->countBubbleSizeValues = record->countBubbleSizeValues();
    }
    void handleBRAI(BRAIRecord *record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleBRAI dataId=" << record->m_dataId << " type=" << record->m_type << " isUnlinkedNumberFormat=" << record->m_isUnlinkedFormat << " numberFormat=" << record->m_numberFormat << " formula=" << record->m_formula << std::endl;
        //m_chart->brai[record->dataId()] = ;
        //TODO
    }
    void handleDataFormat(DataFormatRecord *record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleDataFormat xi=" << record->xi() << " yi=" << record->yi() << " iss=" << record->iss() << std::endl;
        //TODO
    }
    void handleChart3DBarShape(Chart3DBarShapeRecord * record) {
        //TODO
    }
    void handleChart3d(Chart3dRecord *record) { // specifies that chart is rendered in 3d scene
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleChart3d" << std::endl;
        //TODO
    }
    void handleLineFormat(LineFormatRecord *) {
        //TODO
    }
    void handleAreaFormat(AreaFormatRecord *) {
        //TODO
    }
    void handlePieFormat(PieFormatRecord *record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handlePieFormat pcExplode="<<record->pcExplode()<<std::endl;
        m_chart->datasetFormat << new PieFormat(record->pcExplode());
    }
    void handleMarkerFormat(MarkerFormatRecord *) {
        //TODO
    }
    void handleChartFormat(ChartFormatRecord *) {
        //TODO
    }
    void handleGelFrame(GelFrameRecord *) {
        //TODO
    }
    void handleSerToCrt(SerToCrtRecord *record) { // specifies the chartgroup for the current series
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleSerToCrt id=" << record->identifier() << std::endl;
    }
    void handleShtProps(ShtPropsRecord *) { // properties
        //TODO
    }
    void handleDefaultText(DefaultTextRecord *record) { // text
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleDefaultText id=" << record->identifier() << std::endl;
        //TODO
    }
    void handleText(TextRecord *record) { // text formatting
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleText" << std::endl;
        //TODO
    }
    void handlePos(PosRecord *record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handlePos mdTopLt=" << record->mdTopLt() << " mdBotRt=" << record->mdBotRt() << " x1=" << record->x1() << " y1=" << record->y1() << " x2=" << record->x2() << " y2=" << record->y2() << std::endl;
        //TODO
    }
    void handleFontX(FontXRecord *) {
        //TODO
    }
    void handlePlotGrowth(PlotGrowthRecord *) {
        //TODO
    }
    void handleLegend(LegendRecord *) {
        //TODO
    }
    void handleAxesUsed(AxesUsedRecord *) {
        //TODO
    }
    void handleAxisParent(AxisParentRecord *) {
        //TODO
    }
    void handlePie(PieRecord *record) { // specifies that the chartgroup is a pie chart
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handlePie anStart=" << record->anStart() << " pcDonut=" << record->pcDonut() << std::endl;
        m_chart->impl = new PieImpl(record->anStart(), record->pcDonut());
    }
    void handleSIIndex(SIIndexRecord *record) { // type of data contained in the Number records following
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleSIIndex numIndex=" << record->numIndex() << std::endl;
        /*TODO
        0x0001 Series values or vertical values (for scatter or bubble chart groups)
        0x0002 Category labels or horizontal values (for scatter or bubble chart groups)
        0x0003 Bubble sizes
        */
    }
    void handleMsoDrawing(MsoDrawingRecord* record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleMsoDrawing" << std::endl;
        //TODO
    }
    void handleShapePropsStream(ShapePropsStreamRecord* record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleShapePropsStream rgb=" << record->rgb().length() << " " << record->rgb() << std::endl;
        //TODO
    }
    void handleTextPropsStream(TextPropsStreamRecord* record) {
        if(!record) return;
        std::cout << "ChartSubStreamHandler::handleTextPropsStream rgb=" << record->rgb().length() << " " << record->rgb() << std::endl;
        //TODO
    }

};

} // namespace Swinder

#endif // SWINDER_CHARTSUBSTREAMHANDLER_H
