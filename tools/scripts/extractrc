#! /usr/bin/perl

###########################################################################################
# 2004-05-08: Changes by Richard Evans <rich@ridas.com>
#
# Add getopt support, tag groups, make code (hopefully) more
# idiomatic. If anything is broken here, you know who to blame!

sub usage
{
  warn <<"EOF";

extractrc [flags] filenames

This script extracts messages from designer (.ui) and XMLGIU (.rc) files and
writes on standard output (usually redirected to rc.cpp) the equivalent
i18n() calls so that xgettext can parse them.

--tag=name        : Also extract the tag name(s). Repeat the flag to specify 
                    multiple names: --tag=tag_one --tag=tag_two

--tag_group=group : Use a group of tags - defaults to 'kdesdk' if omitted.
                    Valid groups are: @{[TAG_GROUPS()]}

--context=name    : Give i18n calls a context name: i18n("name", ...)
--lines           : Include source line numbers in comments
--help|?          : Display this summary

EOF

  exit;
}

###########################################################################################

use strict;
use warnings;
use Getopt::Long;

use constant TAG_GROUP => 
{
  none    => "",
  kdesdk  => "[tT][eE][xX][tT]|title|string|whatsthis|tooltip|label",
  koffice => "Example|GroupName|Text|Comment|Syntax|TypeName",
};

use constant TAG_GROUPS => join ", ", map "'$_'", sort keys %{&TAG_GROUP};


###########################################################################################
# Add options here as necessary - perldoc Getopt::Long for details on GetOptions

die "extractrc --help for usage\n"
  unless GetOptions ( "tag=s"       => \my @opt_extra_tags,
                      "tag_group=s" => \my $opt_tag_group,
                      "context=s"   => \my $opt_context,       # I18N context
                      "lines"       => \my $opt_lines,
                      "help|?"      => \&usage );

die "No filename specified\n" unless @ARGV;

$opt_tag_group ||= "kdesdk";

die "Unknown tag group: '$opt_tag_group', should be one of: " . TAG_GROUPS . "\n"
    if $opt_tag_group and not my $tags = TAG_GROUP->{$opt_tag_group};

my $extra_tags  = join "", map "|" . quotemeta, @opt_extra_tags;
my $text_string = qr/($tags$extra_tags)>/;                       # Precompile regexp


###########################################################################################
# Program start proper - NB $. is the current line number

for my $file_name ( @ARGV )
{
  open my $fh, "<", $file_name or die "Failed to open: '$file_name': $!";

  my $string          = "";
  my $in_text         = 0;
  my $start_line_no   = 0;
  my $in_skipped_prop = 0;

  while ( <$fh> )
  {
     last if $. == 1 and $_ !~ /^(?:<!DOCTYPE|<\?xml)/;

     chomp;

     $string .= '\n' . $_;

     # 'database', 'associations' properties contain strings that shouldn't be translated

     if ( $in_skipped_prop == 0 and $string =~ /<property name=\"(?:database|associations)\"/ )
     {
       $in_skipped_prop = 1;
     }
     elsif ( $in_skipped_prop and $string =~ /<\/property/ )
     {
       $string          = "";
       $in_skipped_prop = 0;
     }

     unless ( $in_skipped_prop or $in_text )
     {
       if ( $string =~ /<$text_string/o )
       {
         $string        =~ s/^.*<$text_string//o;
         $in_text       =  1;
         $start_line_no =  $.;
       }
       else
       {
         $string = "";
       }
     }

     next unless $in_text;
     next unless $string =~ /<\/$text_string/o;

     my $text = $string;

     $text =~ s/<\/$text_string.*$//o;
     $text =~ s/&lt;/</g;
     $text =~ s/&gt;/>/g;
     $text =~ s/&amp;/&/g; 
     $text =~ s/\\([^n])/\\\\$1/g;
     $text =~ s/\"/\\\"/g;

     print  q|i18n("|;
     print qq|$opt_context","|        if $opt_context;   # We have a I18N context
     print qq|$text"); // $file_name|;
     print qq| $.|                    if $opt_lines;
     print qq| \n|;

     $string  =~ s/^.*<\/$text_string//o;
     $in_text =  0;

     # Text can be multiline in .ui files (possibly), but we warn about it in XMLGUI .rc files.

     warn "there is <text> floating in: '$file_name'" if $. != $start_line_no and $file_name =~ /\.rc$/i;
  }

  close $fh or warn "Failed to close: '$file_name': $!";

  die "parsing error in $file_name" if $in_text;
}

